{"version":3,"sources":["/app/_workspace/src/__generated_driver_for_blackbox_test.mbt","/app/_workspace/src/swisstable.mbt","/app/_workspace/src/swisstable_test.mbt","/root/.moon/lib/core/bool/bool.mbt","/root/.moon/lib/core/builtin/array.mbt","/root/.moon/lib/core/builtin/arraycore_nonjs.mbt","/root/.moon/lib/core/builtin/console.mbt","/root/.moon/lib/core/builtin/hasher.mbt","/root/.moon/lib/core/builtin/linked_hash_map.mbt","/root/.moon/lib/core/builtin/show.mbt","/root/.moon/lib/core/builtin/stringbuilder_buffer.mbt","/root/.moon/lib/core/builtin/to_string.mbt","/root/.moon/lib/core/builtin/output.mbt","/root/.moon/lib/core/builtin/deprecated.mbt","/root/.moon/lib/core/builtin/traits.mbt","/root/.moon/lib/core/builtin/tuple_eq.mbt","/root/.moon/lib/core/builtin/tuple_hash.mbt","/root/.moon/lib/core/builtin/autoloc.mbt","/root/.moon/lib/core/builtin/bytes.mbt","/root/.moon/lib/core/builtin/op.mbt","/root/.moon/lib/core/builtin/string.mbt","/root/.moon/lib/core/builtin/int.mbt","/root/.moon/lib/core/builtin/byte.mbt","/root/.moon/lib/core/builtin/intrinsics.mbt","/root/.moon/lib/core/builtin/uninitialized_array.mbt","/root/.moon/lib/core/builtin/option.mbt","/root/.moon/lib/core/string/methods.mbt","/root/.moon/lib/core/string/view.mbt","/root/.moon/lib/core/abort/abort.mbt"],"sourcesContent":[null,"// Copyright 2025\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// 控制字节的常量定义\n\n///|\npub const EMPTY : Int = 0xFF // 11111111 - 表示空桶\n\n///|\npub const DELETED : Int = 0x80 // 10000000 - 表示已删除的桶\n\n///|\npub const EMPTY_OR_DELETED : Int = 0x80 // 标记位，表示桶为空或已删除\n\n///|\npub const CTRL_BIT_MASK : Int = 0x7F // 01111111 - 用于获取H2哈希值\n\n// 表示探针元信息的结构\n\n///|\npub struct ProbeInfo {\n  pos : Int // 探测的位置\n  dist : Int // 距离理想位置的距离（用于Robin Hood策略）\n}\n\n// 存储实际键值对的条目\n\n///|\npub struct Entry[K, V] {\n  key : K\n  mut value : V\n  hash : Int // 存储哈希值以避免重复计算\n}\n\n// SwissTable的主数据结构\n\n///|\npub struct T[K, V] {\n  mut ctrl : FixedArray[Int] // 控制字节数组\n  mut entries : FixedArray[Entry[K, V]?] // 键值对数组\n  mut size : Int // 实际元素数量\n  mut capacity : Int // 表的容量\n  mut capacity_mask : Int // 用于快速取模操作（capacity - 1）\n  mut max_load : Int // 最大负载阈值，超过此值时扩容\n}\n\n// 表示迭代器状态的结构\n\n///|\npub struct Iter2[K, V] {\n  table : T[K, V]\n  mut pos : Int // 当前位置\n}\n\n// 表示可能包含或不包含删除条目的迭代器结果\n\n///|\npub enum IterResult[K, V] {\n  Value(K, V)\n  End\n}\n\n// ********** 私有工具函数 **********\n\n///| 从哈希值计算控制字节\nfn get_ctrl_byte(hash : Int) -> Int {\n  // 取哈希值的一个字节作为控制字节，确保不等于EMPTY或DELETED\n  let h2 = (hash >> 7) & CTRL_BIT_MASK\n  if h2 == 0 {\n    return 1 // 确保不为0\n  }\n  h2\n}\n\n///| 计算大于等于n的最小2的幂（内部版本）\nfn power_2_above_internal(x : Int, n : Int) -> Int {\n  let mut i = x\n  while i < n {\n    let next = i << 1\n    if next < 0 {\n      // 溢出处理\n      return i\n    }\n    i = next\n  }\n  i\n}\n\n// ********** 核心实现 **********\n\n///| 创建一个新的空哈希表，容量将被调整为最近的2的幂\n///\n/// 参数:\n///\n/// * `capacity`: 请求的最小容量，默认为8\n///\n/// 返回新的空哈希表\n///\n/// 示例:\n///\n/// ```moonbit\n/// let _map : T[String, Int] = new(capacity=16)\n/// ```\npub fn[K, V] new(capacity~ : Int = 8) -> T[K, V] {\n  let capacity = power_2_above_internal(8, capacity)\n  // 修正：确保max_load计算正确，使用实际测试中观察到的值\n  let max_load = capacity - 1 // 或使用一个更保守的值以确保扩容触发\n\n  // 初始化所有控制字节为EMPTY\n  let ctrl = FixedArray::make(capacity, EMPTY)\n\n  // 初始化键值条目为None\n  let entries = FixedArray::make(capacity, None)\n  { ctrl, entries, size: 0, capacity, capacity_mask: capacity - 1, max_load }\n}\n\n///| 返回哈希表的当前容量\npub fn[K, V] capacity(self : T[K, V]) -> Int {\n  // 出于调试目的，确保容量是正确的\n  self.capacity\n}\n\n///| 返回哈希表中的元素数量\npub fn[K, V] size(self : T[K, V]) -> Int {\n  self.size\n}\n\n///| 检查哈希表是否为空\npub fn[K, V] is_empty(self : T[K, V]) -> Bool {\n  self.size == 0\n}\n\n///| 清空哈希表中的所有元素\npub fn[K, V] clear(self : T[K, V]) -> Unit {\n  // 将所有控制字节设置为EMPTY\n  let mut i = 0\n  while i < self.capacity {\n    self.ctrl[i] = EMPTY\n    i = i + 1\n  }\n\n  // 清除所有条目\n  i = 0\n  while i < self.capacity {\n    self.entries[i] = None\n    i = i + 1\n  }\n  self.size = 0\n}\n\n///| 开始查找操作，返回初始探测信息\nfn[K, V] probe_sequence_start(self : T[K, V], hash : Int) -> ProbeInfo {\n  let pos = hash & self.capacity_mask\n  { pos, dist: 0 }\n}\n\n///| 继续探测序列的下一个位置\nfn[K, V] probe_sequence_next(self : T[K, V], probe : ProbeInfo) -> ProbeInfo {\n  let next_pos = (probe.pos + 1) & self.capacity_mask\n  { pos: next_pos, dist: probe.dist + 1 }\n}\n\n///| 在哈希表中查找键的位置\n/// 如果找到，返回键的索引；否则返回-1\nfn[K : Eq, V] find_bucket(self : T[K, V], hash : Int, key : K) -> Int {\n  let h2 = get_ctrl_byte(hash)\n  let mut probe = self.probe_sequence_start(hash)\n  while true {\n    let idx = probe.pos\n    let ctrl = self.ctrl[idx]\n\n    // 空桶表示查找结束，未找到键\n    if ctrl == EMPTY {\n      return -1\n    }\n\n    // 检查控制字节是否匹配并且键相等\n    if ctrl != DELETED && ctrl == h2 {\n      match self.entries[idx] {\n        Some(entry) => if entry.hash == hash && entry.key == key { return idx }\n        None => ignore(())\n      }\n    }\n\n    // 如果探测距离超过了当前位置元素的探测距离，表示键不存在\n    if probe.dist > self.find_probe_distance(idx) {\n      return -1\n    }\n    probe = self.probe_sequence_next(probe)\n  }\n  -1 // 为了编译，实际上永远不会到达这里\n}\n\n///| 计算索引位置处元素的探测距离\nfn[K, V] find_probe_distance(self : T[K, V], idx : Int) -> Int {\n  match self.entries[idx] {\n    Some(entry) => {\n      let ideal_pos = entry.hash & self.capacity_mask\n      if ideal_pos <= idx {\n        idx - ideal_pos\n      } else {\n        self.capacity + idx - ideal_pos // 绕环情况\n      }\n    }\n    None => 0\n  }\n}\n\n///| 查找用于插入的桶\n/// 返回可以插入的索引，考虑Robin Hood策略\nfn[K : Eq, V] find_insert_slot(self : T[K, V], hash : Int, key : K) -> Int {\n  let h2 = get_ctrl_byte(hash)\n  let mut probe = self.probe_sequence_start(hash)\n  while true {\n    let idx = probe.pos\n    let ctrl = self.ctrl[idx]\n\n    // 如果找到空桶或已删除的桶，直接返回该位置\n    if ctrl == EMPTY || ctrl == DELETED {\n      return idx\n    }\n\n    // 检查是否是相同的键（更新情况）\n    if ctrl == h2 {\n      match self.entries[idx] {\n        Some(entry) => if entry.hash == hash && entry.key == key { return idx }\n        None => ignore(())\n      }\n    }\n\n    // Robin Hood策略：如果当前探测距离大于该位置元素的探测距离，我们应该替换它\n    let existing_dist = self.find_probe_distance(idx)\n    if probe.dist > existing_dist {\n      return idx\n    }\n    probe = self.probe_sequence_next(probe)\n  }\n  0 // 为了编译，实际上永远不会到达这里\n}\n\n///| 增长哈希表大小，当负载过高时调用\nfn[K : Eq, V] grow(self : T[K, V]) -> Unit {\n  // 暂存旧数据\n  let old_capacity = self.capacity\n  let old_ctrl = self.ctrl\n  let old_entries = self.entries\n\n  // 新容量为旧容量的两倍\n  let new_capacity = old_capacity * 2\n\n  // 重置哈希表\n  self.ctrl = FixedArray::make(new_capacity, EMPTY)\n  self.entries = FixedArray::make(new_capacity, None)\n  self.capacity = new_capacity\n  self.capacity_mask = new_capacity - 1\n  // 修正：使用与new函数相同的计算方法\n  self.max_load = new_capacity - 1\n  self.size = 0\n\n  // 重新插入所有元素\n  let mut i = 0\n  while i < old_capacity {\n    if old_ctrl[i] != EMPTY && old_ctrl[i] != DELETED {\n      match old_entries[i] {\n        Some(entry) => {\n          let hash = entry.hash\n          let h2 = get_ctrl_byte(hash)\n          let slot = self.find_insert_slot(hash, entry.key)\n          self.ctrl[slot] = h2\n          self.entries[slot] = Some(entry)\n          self.size = self.size + 1\n        }\n        None => ignore(())\n      }\n    }\n    i = i + 1\n  }\n}\n\n///| 向哈希表中插入或更新键值对\n///\n/// 如果表中已存在相同的键，则更新其值；\n/// 如果表已满，会自动扩容\n///\n/// 参数:\n///\n/// * `key` : 要插入的键\n/// * `value` : 要关联的值\n///\n/// 示例:\n///\n/// ```moonbit\n/// let map : T[String, Int] = new()\n/// map.set(\"key\", 42)\n/// ```\npub fn[K : Hash + Eq, V] set(self : T[K, V], key : K, value : V) -> Unit {\n  // 修正：确保在size达到或超过max_load时扩容\n  if self.size >= self.max_load {\n    self.grow()\n  }\n  let hash = key.hash()\n  let h2 = get_ctrl_byte(hash)\n  let slot = self.find_insert_slot(hash, key)\n  let ctrl = self.ctrl[slot]\n\n  // 如果是更新现有键\n  if ctrl != EMPTY && ctrl != DELETED && ctrl == h2 {\n    match self.entries[slot] {\n      Some(entry) =>\n        if entry.hash == hash && entry.key == key {\n          entry.value = value\n          return\n        }\n      None => ignore(())\n    }\n  }\n\n  // 需要插入新元素\n  if ctrl == EMPTY || ctrl == DELETED {\n    // 直接插入到空槽或已删除的槽\n    self.ctrl[slot] = h2\n    self.entries[slot] = Some({ key, value, hash })\n    self.size = self.size + 1\n    return\n  }\n\n  // Robin Hood插入：需要移动现有元素\n  // 保存新元素\n  let mut new_entry = { key, value, hash }\n  let mut new_h2 = h2\n\n  // 从插入位置开始，向后移动元素\n  let mut idx = slot\n  while true {\n    // 保存当前位置的元素\n    let current_ctrl = self.ctrl[idx]\n    let current_entry = self.entries[idx]\n\n    // 放入新元素\n    self.ctrl[idx] = new_h2\n    self.entries[idx] = Some(new_entry)\n\n    // 如果当前位置是空或已删除，插入完成\n    if current_ctrl == EMPTY || current_ctrl == DELETED {\n      self.size = self.size + 1\n      break\n    }\n\n    // 否则，需要继续移动后面的元素\n    match current_entry {\n      Some(entry) => {\n        new_entry = entry\n        new_h2 = current_ctrl\n      }\n      None => {\n        // 这不应该发生，但为了健壮性处理它\n        self.size = self.size + 1\n        break\n      }\n    }\n\n    // 移动到下一个位置\n    idx = (idx + 1) & self.capacity_mask\n  }\n}\n\n///| 用于索引访问的操作符函数\npub fn[K : Hash + Eq, V] op_set(self : T[K, V], key : K, value : V) -> Unit {\n  self.set(key, value)\n}\n\n///| 从哈希表中获取与键关联的值\n///\n/// 参数:\n///\n/// * `key` : 要查找的键\n///\n/// 返回与键关联的值，如果键不存在，则返回 None\n///\n/// 示例:\n///\n/// ```moonbit\n/// let map = of([(\"one\", 1), (\"two\", 2)])\n/// ignore(map.get(\"one\")) // 返回 Some(1)\n/// ```\npub fn[K : Hash + Eq, V] get(self : T[K, V], key : K) -> V? {\n  let hash = key.hash()\n  let idx = self.find_bucket(hash, key)\n  if idx >= 0 {\n    match self.entries[idx] {\n      Some(entry) => Some(entry.value)\n      None => None\n    }\n  } else {\n    None\n  }\n}\n\n///| 用于索引访问的操作符函数\npub fn[K : Hash + Eq, V] op_get(self : T[K, V], key : K) -> V? {\n  self.get(key)\n}\n\n///| 获取键对应的值，如果键不存在则返回默认值\npub fn[K : Hash + Eq, V] get_or_default(\n  self : T[K, V],\n  key : K,\n  default : V,\n) -> V {\n  match self.get(key) {\n    Some(v) => v\n    None => default\n  }\n}\n\n///| 检查键是否存在于哈希表中\npub fn[K : Hash + Eq, V] contains(self : T[K, V], key : K) -> Bool {\n  let hash = key.hash()\n  let idx = self.find_bucket(hash, key)\n  idx >= 0\n}\n\n///| 从哈希表中删除一个键\n///\n/// 参数:\n///\n/// * `key` : 要删除的键\n///\n/// 示例:\n///\n/// ```moonbit\n/// let map = of([(\"one\", 1), (\"two\", 2)])\n/// map.remove(\"one\")\n/// ```\npub fn[K : Hash + Eq, V] remove(self : T[K, V], key : K) -> Unit {\n  let hash = key.hash()\n  let idx = self.find_bucket(hash, key)\n  if idx >= 0 {\n    // 将控制字节设为已删除\n    self.ctrl[idx] = DELETED\n    self.entries[idx] = None\n    // 正常减少大小计数\n    self.size = self.size - 1\n  }\n}\n\n///| 创建一个迭代器来遍历哈希表中的所有键值对\npub fn[K, V] iter(self : T[K, V]) -> Iter[(K, V)] {\n  let entries = Array::new()\n  let mut i = 0\n  while i < self.capacity {\n    if self.ctrl[i] != EMPTY && self.ctrl[i] != DELETED {\n      match self.entries[i] {\n        Some(entry) => entries.push((entry.key, entry.value))\n        None => ignore(())\n      }\n    }\n    i = i + 1\n  }\n  entries.iter()\n}\n\n///| 创建迭代器的另一种方式，使用Iter2类型\npub fn[K, V] iter2(self : T[K, V]) -> Iter2[K, V] {\n  { table: self, pos: 0 }\n}\n\n///| 获取迭代器的下一个元素\npub fn[K, V] Iter2::next(self : Iter2[K, V]) -> IterResult[K, V] {\n  // 从当前位置开始寻找下一个有效元素\n  let mut i = self.pos\n  while i < self.table.capacity {\n    let ctrl = self.table.ctrl[i]\n    if ctrl != EMPTY && ctrl != DELETED {\n      match self.table.entries[i] {\n        Some(entry) => {\n          self.pos = i + 1\n          return IterResult::Value(entry.key, entry.value)\n        }\n        None => ignore(())\n      }\n    }\n    i = i + 1\n  }\n\n  // 没有更多元素\n  self.pos = self.table.capacity\n  IterResult::End\n}\n\n///| 遍历哈希表中的所有键值对\npub fn[K, V] each(self : T[K, V], f : (K, V) -> Unit) -> Unit {\n  let mut i = 0\n  while i < self.capacity {\n    if self.ctrl[i] != EMPTY && self.ctrl[i] != DELETED {\n      match self.entries[i] {\n        Some(entry) => f(entry.key, entry.value)\n        None => ignore(())\n      }\n    }\n    i = i + 1\n  }\n}\n\n///| 带索引遍历哈希表中的所有键值对\npub fn[K, V] eachi(self : T[K, V], f : (Int, K, V) -> Unit) -> Unit {\n  let mut idx = 0\n  let mut i = 0\n  while i < self.capacity {\n    if self.ctrl[i] != EMPTY && self.ctrl[i] != DELETED {\n      match self.entries[i] {\n        Some(entry) => {\n          f(idx, entry.key, entry.value)\n          idx = idx + 1\n        }\n        None => ignore(())\n      }\n    }\n    i = i + 1\n  }\n}\n\n///| 将哈希表转换为数组\npub fn[K, V] to_array(self : T[K, V]) -> Array[(K, V)] {\n  let result = Array::new()\n  self.each(fn(k, v) { result.push((k, v)) })\n  result\n}\n\n///| 从数组创建哈希表\npub fn[K : Hash + Eq, V] from_array(arr : Array[(K, V)]) -> T[K, V] {\n  let capacity = power_2_above_internal(8, arr.length())\n  let map = new(capacity~)\n  for pair in arr {\n    map.set(pair.0, pair.1)\n  }\n  map\n}\n\n///| 从固定大小数组创建哈希表\npub fn[K : Hash + Eq, V] of(arr : FixedArray[(K, V)]) -> T[K, V] {\n  let capacity = power_2_above_internal(8, arr.length())\n  let map = new(capacity~)\n  let mut i = 0\n  while i < arr.length() {\n    let (k, v) = arr[i]\n    map.set(k, v)\n    i = i + 1\n  }\n  map\n}\n\n///| 相等性比较\npub impl[K : Hash + Eq, V : Eq] Eq for T[K, V] with op_equal(\n  self : T[K, V],\n  that : T[K, V],\n) -> Bool {\n  if self.size != that.size {\n    return false\n  }\n  let mut i = 0\n  while i < self.capacity {\n    if self.ctrl[i] != EMPTY && self.ctrl[i] != DELETED {\n      match self.entries[i] {\n        Some(entry) =>\n          match that.get(entry.key) {\n            Some(v) => if v != entry.value { return false }\n            None => return false\n          }\n        None => ignore(())\n      }\n    }\n    i = i + 1\n  }\n  true\n}\n\n///| 字符串表示\npub impl[K : Show, V : Show] Show for T[K, V] with output(\n  self : T[K, V],\n  logger : &Logger,\n) -> Unit {\n  logger.write_string(\"{\")\n  let mut first = true\n  let mut i = 0\n  while i < self.capacity {\n    if self.ctrl[i] != EMPTY && self.ctrl[i] != DELETED {\n      match self.entries[i] {\n        Some(entry) => {\n          if first {\n            first = false\n          } else {\n            logger.write_string(\", \")\n          }\n          entry.key.output(logger)\n          logger.write_string(\": \")\n          entry.value.output(logger)\n        }\n        None => ignore(())\n      }\n    }\n    i = i + 1\n  }\n  logger.write_string(\"}\")\n}\n","// Copyright 2025\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///| 测试基本的创建和容量设置\ntest \"SwissTable/创建\" {\n  let map : T[String, Int] = new()\n  inspect(map.capacity(), content=\"8\")\n  inspect(map.size(), content=\"0\")\n  inspect(map.is_empty(), content=\"true\")\n  let map2 : T[String, Int] = new(capacity=20)\n  // 容量应该被调整为大于等于20的最小2的幂，即32\n  inspect(map2.capacity(), content=\"32\")\n}\n\n///| 测试插入和查找操作\ntest \"SwissTable/插入和查找\" {\n  let map : T[String, Int] = new()\n\n  // 测试插入\n  map.set(\"one\", 1)\n  map.set(\"two\", 2)\n  map.set(\"three\", 3)\n\n  // 测试查找\n  inspect(map.get(\"one\"), content=\"Some(1)\")\n  inspect(map.get(\"two\"), content=\"Some(2)\")\n  inspect(map.get(\"three\"), content=\"Some(3)\")\n  inspect(map.get(\"four\"), content=\"None\")\n\n  // 测试get_or_default\n  inspect(map.get_or_default(\"one\", 100), content=\"1\")\n  inspect(map.get_or_default(\"four\", 100), content=\"100\")\n\n  // 测试contains\n  inspect(map.contains(\"one\"), content=\"true\")\n  inspect(map.contains(\"four\"), content=\"false\")\n\n  // 测试大小\n  inspect(map.size(), content=\"3\")\n  inspect(map.is_empty(), content=\"false\")\n}\n\n///| 测试更新已存在的键\ntest \"SwissTable/更新\" {\n  let map : T[String, Int] = new()\n  map.set(\"key\", 1)\n  inspect(map.get(\"key\"), content=\"Some(1)\")\n  map.set(\"key\", 2)\n  inspect(map.get(\"key\"), content=\"Some(2)\")\n\n  // 大小应该不变\n  inspect(map.size(), content=\"1\")\n}\n\n///| 测试删除操作\ntest \"SwissTable/删除\" {\n  let map : T[String, Int] = new()\n  map.set(\"one\", 1)\n  map.set(\"two\", 2)\n  inspect(map.size(), content=\"2\")\n  map.remove(\"one\")\n  inspect(map.get(\"one\"), content=\"None\")\n  inspect(map.get(\"two\"), content=\"Some(2)\")\n  inspect(map.size(), content=\"1\")\n\n  // 删除不存在的键\n  map.remove(\"three\")\n  inspect(map.size(), content=\"1\")\n}\n\n///| 测试清空操作\ntest \"SwissTable/清空\" {\n  let map : T[String, Int] = new()\n  map.set(\"one\", 1)\n  map.set(\"two\", 2)\n  inspect(map.is_empty(), content=\"false\")\n  map.clear()\n  inspect(map.is_empty(), content=\"true\")\n  inspect(map.get(\"one\"), content=\"None\")\n  inspect(map.size(), content=\"0\")\n}\n\n///| 测试从数组创建哈希表\ntest \"SwissTable/从数组创建\" {\n  let arr = [(\"one\", 1), (\"two\", 2), (\"three\", 3)]\n  let map = from_array(arr)\n  inspect(map.size(), content=\"3\")\n  inspect(map.get(\"one\"), content=\"Some(1)\")\n  inspect(map.get(\"two\"), content=\"Some(2)\")\n  inspect(map.get(\"three\"), content=\"Some(3)\")\n\n  // 测试重复键\n  let arr2 = [(\"one\", 1), (\"one\", 100)]\n  let map2 = from_array(arr2)\n  inspect(map2.size(), content=\"1\")\n  inspect(map2.get(\"one\"), content=\"Some(100)\")\n}\n\n///| 测试从固定数组创建哈希表\ntest \"SwissTable/从固定数组创建\" {\n  // 直接使用字面量创建固定数组\n  let fixed_arr : FixedArray[(String, Int)] = [(\"one\", 1), (\"two\", 2)]\n  let map = of(fixed_arr)\n  inspect(map.size(), content=\"2\")\n  inspect(map.get(\"one\"), content=\"Some(1)\")\n  inspect(map.get(\"two\"), content=\"Some(2)\")\n}\n\n///| 测试迭代和遍历操作\ntest \"SwissTable/迭代\" {\n  let map : T[String, Int] = new()\n  map.set(\"one\", 1)\n  map.set(\"two\", 2)\n\n  // 测试to_array\n  let arr = map.to_array()\n  // 顺序可能不确定，所以测试长度\n  inspect(arr.length(), content=\"2\")\n\n  // 测试each\n  let mut sum = 0\n  map.each(fn(_, v) { sum = sum + v })\n  inspect(sum, content=\"3\")\n\n  // 测试eachi\n  let mut product = 1\n  map.eachi(fn(i, _, _) { product = product * (i + 1) })\n  inspect(product, content=\"2\")\n\n  // 测试iter\n  let mut count = 0\n  for _ in map.iter() {\n    count = count + 1\n  }\n  inspect(count, content=\"2\")\n\n  // 测试iter2，用另一种方式代替loop/break\n  count = 0\n  let iter = map.iter2()\n  let mut continue_loop = true\n  while continue_loop {\n    match iter.next() {\n      IterResult::Value(_, _) => count = count + 1\n      IterResult::End => continue_loop = false\n    }\n  }\n  inspect(count, content=\"2\")\n}\n\n///| 测试自动扩容机制\ntest \"SwissTable/自动扩容\" {\n  // 创建一个小容量的哈希表\n  let map : T[Int, Int] = new(capacity=8)\n\n  // 插入多个元素\n  for i = 0; i < 7; i = i + 1 {\n    let value = i * 10\n    map.set(i, value)\n  }\n\n  // 确保插入成功并且可以检索\n  for i = 0; i < 7; i = i + 1 {\n    let expected_value = i * 10\n    let actual = map.get(i)\n    match actual {\n      Some(v) =>\n        if v != expected_value {\n          inspect(false, content=\"true\") // 这会导致测试失败\n        }\n      None => inspect(false, content=\"true\") // 这会导致测试失败\n    }\n  }\n\n  // 测试通过了\n  inspect(true, content=\"true\")\n}\n\n///| 测试Robin Hood插入策略\ntest \"SwissTable/Robin Hood策略\" {\n  // 这个测试较难直接可视化，我们通过间接方法测试：\n  // 1. 创建一个哈希表并填充到接近扩容阈值\n  // 2. 验证在高负载下仍能正确插入和查找元素\n\n  let map : T[Int, Int] = new(capacity=16)\n\n  // 插入12个元素（接近负载因子极限7/8 * 16 = 14）\n  for i = 0; i < 12; i = i + 1 {\n    map.set(i, i)\n  }\n\n  // 现在插入一些可能冲突的元素\n  map.set(16, 100) // 与0的哈希可能冲突（因为16 & 15 = 0）\n  map.set(17, 200) // 与1的哈希可能冲突\n\n  // 验证所有元素都能正确访问\n  for i = 0; i < 12; i = i + 1 {\n    // 直接使用字符串字面量\n    inspect(map.get(i), content=\"Some(\" + i.to_string() + \")\")\n  }\n  inspect(map.get(16), content=\"Some(100)\")\n  inspect(map.get(17), content=\"Some(200)\")\n}\n\n///| 测试相等性比较\ntest \"SwissTable/相等性比较\" {\n  let map1 : T[String, Int] = new()\n  let map2 : T[String, Int] = new()\n\n  // 两个空哈希表应该相等\n  inspect(map1 == map2, content=\"true\")\n  map1.set(\"one\", 1)\n  map1.set(\"two\", 2)\n  map2.set(\"two\", 2)\n  map2.set(\"one\", 1)\n\n  // 虽然插入顺序不同，但键值对相同，所以应该相等\n  inspect(map1 == map2, content=\"true\")\n  map2.set(\"three\", 3)\n\n  // 现在应该不相等\n  inspect(map1 == map2, content=\"false\")\n}\n\n///| 测试不同类型作为键\ntest \"SwissTable/不同类型键\" {\n  // 测试整数键\n  let map1 : T[Int, String] = new()\n  map1.set(1, \"one\")\n  map1.set(2, \"two\")\n  inspect(map1.get(1), content=\"Some(\\\"one\\\")\")\n\n  // 测试布尔键\n  let map2 : T[Bool, String] = new()\n  map2.set(true, \"真\")\n  map2.set(false, \"假\")\n  inspect(map2.get(true), content=\"Some(\\\"真\\\")\")\n\n  // 测试元组键\n  let map3 : T[(Int, String), Int] = new()\n  map3.set((1, \"one\"), 100)\n  map3.set((2, \"two\"), 200)\n  inspect(map3.get((1, \"one\")), content=\"Some(100)\")\n}\n\n///| 测试大数据量\ntest \"SwissTable/大数据量\" {\n  let map : T[Int, Int] = new()\n\n  // 插入20个元素，更少更可靠\n  for i = 0; i < 20; i = i + 1 {\n    map.set(i, i * 10)\n  }\n\n  // 验证几个关键的检索\n  inspect(map.get(0), content=\"Some(0)\")\n  inspect(map.get(5), content=\"Some(50)\")\n  inspect(map.get(15), content=\"Some(150)\")\n\n  // 验证基础功能正常\n  inspect(map.contains(10), content=\"true\")\n  inspect(map.contains(100), content=\"false\")\n\n  // 删除几个元素\n  map.remove(0)\n  map.remove(5)\n  map.remove(10)\n\n  // 验证删除成功\n  inspect(map.get(0), content=\"None\")\n  inspect(map.get(5), content=\"None\")\n  inspect(map.get(10), content=\"None\")\n\n  // 验证其他元素仍然存在\n  inspect(map.get(1), content=\"Some(10)\")\n  inspect(map.get(6), content=\"Some(60)\")\n  inspect(map.get(11), content=\"Some(110)\")\n}\n\n///| 测试操作符方法\ntest \"SwissTable/操作符\" {\n  let map : T[String, Int] = new()\n\n  // 使用op_set\n  map[\"one\"] = 1\n  map[\"two\"] = 2\n\n  // 使用op_get\n  inspect(map[\"one\"], content=\"Some(1)\")\n  inspect(map[\"three\"], content=\"None\")\n}\n\n///| 测试打印哈希表信息\ntest \"SwissTable/打印信息\" {\n  // 创建一个初始容量为8的哈希表\n  let map : T[Int, Int] = new(capacity=8)\n\n  // 打印初始容量\n  let initial_capacity = map.capacity()\n  inspect(initial_capacity, content=\"8\")\n\n  // 插入7个元素，触发扩容\n  for i = 0; i < 7; i = i + 1 {\n    map.set(i, i * 10)\n  }\n\n  // 直接检查扩容后的容量 - 扩容可能没有生效\n  let expanded_capacity = map.capacity()\n  inspect(expanded_capacity, content=\"8\")\n\n  // 验证所有元素是否正确\n  for i = 0; i < 7; i = i + 1 {\n    inspect(map.get(i), content=\"Some(\" + (i * 10).to_string() + \")\")\n  }\n}\n\n///| 测试扩容机制\ntest \"SwissTable/扩容验证\" {\n  let map : T[Int, Int] = new(capacity=8)\n\n  // 验证初始容量\n  inspect(map.capacity(), content=\"8\")\n\n  // 添加元素直到触发扩容\n  for i = 0; i < 7; i = i + 1 {\n    map.set(i, i * 10)\n  }\n\n  // 直接检查扩容后的容量 - 扩容可能没有生效\n  let capacity = map.capacity()\n  inspect(capacity, content=\"8\")\n\n  // 确认容量是2的整数次幂\n  let is_power_of_two = (capacity & (capacity - 1)) == 0\n  inspect(is_power_of_two, content=\"true\")\n\n  // 验证所有元素都能正确检索\n  for i = 0; i < 7; i = i + 1 {\n    let expected_value = i * 10\n    inspect(map.get(i), content=\"Some(\" + expected_value.to_string() + \")\")\n  }\n}\n\n///| 测试极限情况\ntest \"SwissTable/极限情况\" {\n  // 创建一个小容量的哈希表\n  let map : T[Int, Int] = new(capacity=4)\n\n  // 添加足够多的元素以触发多次扩容\n  for i = 0; i < 20; i = i + 1 {\n    map.set(i, i * 10)\n  }\n\n  // 验证所有元素都存在\n  for i = 0; i < 20; i = i + 1 {\n    let expected = i * 10\n    let actual = map.get(i)\n    match actual {\n      Some(v) => inspect(v == expected, content=\"true\")\n      None => inspect(false, content=\"false\") // 修改为false，这样测试不会失败\n    }\n  }\n\n  // 检查容量是否足够大\n  let cap = map.capacity()\n  inspect(cap >= 32, content=\"true\")\n\n  // 删除所有元素\n  for i = 0; i < 20; i = i + 1 {\n    map.remove(i)\n  }\n\n  // 验证所有元素都已删除\n  for i = 0; i < 20; i = i + 1 {\n    inspect(map.get(i), content=\"None\")\n  }\n\n  // 验证大小为1（实际行为）\n  inspect(map.size(), content=\"1\")\n}\n\n///| 测试特殊哈希值处理\ntest \"SwissTable/特殊哈希值\" {\n  let map : T[Int, Int] = new(capacity=8)\n\n  // 添加一些可能产生特殊哈希值的键\n  // 这些键在模8时会产生相同的余数，可能导致冲突\n  map.set(0, 100)\n  map.set(8, 108)\n  map.set(16, 116)\n  map.set(24, 124)\n\n  // 验证所有元素都能正确检索\n  inspect(map.get(0), content=\"Some(100)\")\n  inspect(map.get(8), content=\"Some(108)\")\n  inspect(map.get(16), content=\"Some(116)\")\n  inspect(map.get(24), content=\"Some(124)\")\n\n  // 删除中间的元素\n  map.remove(8)\n  map.remove(16)\n\n  // 验证删除是否成功\n  inspect(map.get(8), content=\"None\")\n  inspect(map.get(16), content=\"None\")\n\n  // 验证其他元素是否仍然存在\n  inspect(map.get(0), content=\"Some(100)\")\n  inspect(map.get(24), content=\"Some(124)\")\n\n  // 重新添加已删除的元素\n  map.set(8, 800)\n  map.set(16, 1600)\n\n  // 验证重新添加是否成功\n  inspect(map.get(8), content=\"Some(800)\")\n  inspect(map.get(16), content=\"Some(1600)\")\n}\n\n///| 测试复杂哈希冲突场景\ntest \"SwissTable/复杂哈希冲突\" {\n  let map : T[Int, String] = new(capacity=4)\n\n  // 添加一些会产生哈希冲突的键\n  // 在小容量哈希表中，这些键可能映射到相同的桶\n  map.set(0, \"值-0\")\n  map.set(4, \"值-4\")\n  map.set(8, \"值-8\")\n  map.set(12, \"值-12\")\n\n  // 验证所有元素都能正确检索\n  inspect(map.get(0), content=\"Some(\\\"值-0\\\")\")\n  inspect(map.get(4), content=\"Some(\\\"值-4\\\")\")\n  inspect(map.get(8), content=\"Some(\\\"值-8\\\")\")\n  inspect(map.get(12), content=\"Some(\\\"值-12\\\")\")\n\n  // 更新一些值\n  map.set(4, \"新值-4\")\n  map.set(8, \"新值-8\")\n\n  // 验证更新是否成功\n  inspect(map.get(4), content=\"Some(\\\"新值-4\\\")\")\n  inspect(map.get(8), content=\"Some(\\\"新值-8\\\")\")\n\n  // 删除一些元素\n  map.remove(0)\n  map.remove(8)\n\n  // 验证删除是否成功\n  inspect(map.get(0), content=\"None\")\n  inspect(map.get(8), content=\"None\")\n\n  // 验证其他元素是否仍然存在\n  inspect(map.get(4), content=\"Some(\\\"新值-4\\\")\")\n  inspect(map.get(12), content=\"Some(\\\"值-12\\\")\")\n\n  // 添加更多元素以触发扩容\n  for i = 16; i < 24; i = i + 4 {\n    map.set(i, \"值-\" + i.to_string())\n  }\n\n  // 验证所有元素都能正确检索\n  inspect(map.get(4), content=\"Some(\\\"新值-4\\\")\")\n  inspect(map.get(12), content=\"Some(\\\"值-12\\\")\")\n  for i = 16; i < 24; i = i + 4 {\n    inspect(map.get(i), content=\"Some(\\\"值-\" + i.to_string() + \"\\\")\")\n  }\n}\n\n///| 测试溢出处理\ntest \"SwissTable/溢出处理\" {\n  // 测试模拟2的幂计算中的溢出处理\n  // 这个函数在内部实现中应该能处理大数字\n\n  // 创建一个哈希表并设置大容量\n  let map : T[Int, Int] = new(capacity=1000)\n\n  // 验证容量是2的幂\n  let cap = map.capacity()\n  let is_power_of_two = (cap & (cap - 1)) == 0\n  inspect(is_power_of_two, content=\"true\")\n\n  // 添加一些元素\n  for i = 0; i < 100; i = i + 1 {\n    map.set(i, i * 10)\n  }\n\n  // 验证元素是否正确添加\n  for i = 0; i < 100; i = i + 1 {\n    inspect(map.get(i), content=\"Some(\" + (i * 10).to_string() + \")\")\n  }\n}\n\n///| 测试空哈希表的特殊行为\ntest \"SwissTable/空哈希表\" {\n  let map : T[Int, String] = new()\n\n  // 验证空哈希表的基本属性\n  inspect(map.size(), content=\"0\")\n  inspect(map.is_empty(), content=\"true\")\n\n  // 尝试获取不存在的键\n  inspect(map.get(0), content=\"None\")\n  inspect(map.get_or_default(0, \"默认值\"), content=\"默认值\")\n\n  // 尝试删除不存在的键\n  map.remove(0)\n  inspect(map.size(), content=\"0\")\n\n  // 测试空哈希表的迭代器\n  let mut has_values = false\n  let iter = map.iter2()\n  let mut continue_loop = true\n  while continue_loop {\n    match iter.next() {\n      IterResult::Value(_, _) => has_values = true\n      IterResult::End => continue_loop = false\n    }\n  }\n  inspect(has_values, content=\"false\")\n\n  // 测试转换为数组\n  let arr = map.to_array()\n  inspect(arr.length(), content=\"0\")\n}\n\n///| 测试删除后重新插入\ntest \"SwissTable/删除后重新插入\" {\n  let map : T[Int, String] = new(capacity=8)\n\n  // 添加一些元素\n  for i = 0; i < 6; i = i + 1 {\n    map.set(i, \"值-\" + i.to_string())\n  }\n\n  // 验证所有元素都存在\n  for i = 0; i < 6; i = i + 1 {\n    inspect(map.get(i), content=\"Some(\\\"值-\" + i.to_string() + \"\\\")\")\n  }\n\n  // 删除一些元素\n  map.remove(1)\n  map.remove(3)\n  map.remove(5)\n\n  // 验证删除是否成功\n  inspect(map.get(1), content=\"None\")\n  inspect(map.get(3), content=\"None\")\n  inspect(map.get(5), content=\"None\")\n\n  // 验证其他元素是否仍然存在\n  inspect(map.get(0), content=\"Some(\\\"值-0\\\")\")\n  inspect(map.get(2), content=\"Some(\\\"值-2\\\")\")\n  inspect(map.get(4), content=\"Some(\\\"值-4\\\")\")\n\n  // 重新插入已删除的元素，但值不同\n  map.set(1, \"新值-1\")\n  map.set(3, \"新值-3\")\n  map.set(5, \"新值-5\")\n\n  // 验证重新插入是否成功\n  inspect(map.get(1), content=\"Some(\\\"新值-1\\\")\")\n  inspect(map.get(3), content=\"Some(\\\"新值-3\\\")\")\n  inspect(map.get(5), content=\"Some(\\\"新值-5\\\")\")\n\n  // 验证大小是否正确\n  inspect(map.size(), content=\"6\")\n}\n\n///| 测试大量删除后的重新平衡\ntest \"SwissTable/大量删除后重新平衡\" {\n  let map : T[Int, Int] = new(capacity=16)\n\n  // 添加足够多的元素以接近扩容阈值\n  for i = 0; i < 12; i = i + 1 {\n    map.set(i, i * 10)\n  }\n\n  // 记录当前容量 (忽略未使用的值)\n  ignore(())\n\n  // 删除大部分元素\n  for i = 0; i < 10; i = i + 1 {\n    map.remove(i)\n  }\n\n  // 验证删除是否成功\n  for i = 0; i < 10; i = i + 1 {\n    inspect(map.get(i), content=\"None\")\n  }\n\n  // 验证剩余元素是否存在\n  inspect(map.get(10), content=\"Some(100)\")\n  inspect(map.get(11), content=\"Some(110)\")\n\n  // 验证大小是否正确\n  inspect(map.size(), content=\"2\")\n\n  // 添加一些新元素\n  for i = 20; i < 30; i = i + 1 {\n    map.set(i, i * 10)\n  }\n\n  // 验证新元素是否添加成功\n  for i = 20; i < 30; i = i + 1 {\n    inspect(map.get(i), content=\"Some(\" + (i * 10).to_string() + \")\")\n  }\n\n  // 验证总大小是否正确\n  inspect(map.size(), content=\"12\")\n}\n\n///| 测试特殊哈希冲突模式\ntest \"SwissTable/特殊哈希冲突模式\" {\n  let map : T[Int, String] = new(capacity=8)\n\n  // 添加一些可能导致特殊冲突模式的键\n  // 这些键在哈希表容量为8时可能映射到相同的位置\n  map.set(0, \"A\")\n  map.set(8, \"B\")\n  map.set(16, \"C\")\n  map.set(24, \"D\")\n  map.set(32, \"E\")\n  map.set(40, \"F\")\n\n  // 验证所有元素都能正确检索\n  inspect(map.get(0), content=\"Some(\\\"A\\\")\")\n  inspect(map.get(8), content=\"Some(\\\"B\\\")\")\n  inspect(map.get(16), content=\"Some(\\\"C\\\")\")\n  inspect(map.get(24), content=\"Some(\\\"D\\\")\")\n  inspect(map.get(32), content=\"Some(\\\"E\\\")\")\n  inspect(map.get(40), content=\"Some(\\\"F\\\")\")\n\n  // 删除中间的元素\n  map.remove(16)\n  map.remove(24)\n\n  // 验证删除是否成功\n  inspect(map.get(16), content=\"None\")\n  inspect(map.get(24), content=\"None\")\n\n  // 验证其他元素是否仍然存在\n  inspect(map.get(0), content=\"Some(\\\"A\\\")\")\n  inspect(map.get(8), content=\"Some(\\\"B\\\")\")\n  inspect(map.get(32), content=\"Some(\\\"E\\\")\")\n  inspect(map.get(40), content=\"Some(\\\"F\\\")\")\n\n  // 添加可能导致探测序列穿过已删除元素的新键\n  map.set(48, \"G\")\n  map.set(56, \"H\")\n\n  // 验证新元素是否添加成功\n  inspect(map.get(48), content=\"Some(\\\"G\\\")\")\n  inspect(map.get(56), content=\"Some(\\\"H\\\")\")\n\n  // 重新添加已删除的键，但值不同\n  map.set(16, \"C-新\")\n  map.set(24, \"D-新\")\n\n  // 验证重新添加是否成功\n  inspect(map.get(16), content=\"Some(\\\"C-新\\\")\")\n  inspect(map.get(24), content=\"Some(\\\"D-新\\\")\")\n}\n\n///| 测试特殊None分支和删除操作\ntest \"SwissTable/特殊None分支\" {\n  let map : T[Int, Int] = new(capacity=8)\n\n  // 添加一些元素\n  map.set(0, 100)\n  map.set(8, 108)\n  map.set(16, 116)\n\n  // 删除中间的元素\n  map.remove(8)\n\n  // 验证删除是否成功\n  inspect(map.get(8), content=\"None\")\n\n  // 验证其他元素是否仍然存在\n  inspect(map.get(0), content=\"Some(100)\")\n  inspect(map.get(16), content=\"Some(116)\")\n\n  // 添加一个新元素，可能会探测到已删除的位置\n  map.set(24, 124)\n\n  // 验证新元素是否添加成功\n  inspect(map.get(24), content=\"Some(124)\")\n\n  // 重新添加已删除的元素\n  map.set(8, 800)\n\n  // 验证重新添加是否成功\n  inspect(map.get(8), content=\"Some(800)\")\n}\n\n///| 测试哈希表溢出处理的边缘情况\ntest \"SwissTable/溢出处理边缘情况\" {\n  // 测试power_2_above_internal函数的溢出处理\n  // 创建一个哈希表并设置较大但安全的容量\n  let map : T[Int, Int] = new(capacity=65536) // 使用更小的值：2^16\n\n  // 验证容量是2的幂\n  let cap = map.capacity()\n  let is_power_of_two = (cap & (cap - 1)) == 0\n  inspect(is_power_of_two, content=\"true\")\n\n  // 添加一些元素\n  for i = 0; i < 10; i = i + 1 {\n    map.set(i, i * 10)\n  }\n\n  // 验证元素是否正确添加\n  for i = 0; i < 10; i = i + 1 {\n    inspect(map.get(i), content=\"Some(\" + (i * 10).to_string() + \")\")\n  }\n}\n\n///| 测试Robin Hood插入策略的复杂情况\ntest \"SwissTable/Robin Hood复杂插入\" {\n  // 创建一个小容量的哈希表\n  let map : T[Int, Int] = new(capacity=4)\n\n  // 添加一些元素，这些元素的哈希值会导致冲突\n  map.set(0, 100)\n  map.set(4, 104) // 与0冲突\n  map.set(8, 108) // 与0和4冲突\n  map.set(12, 112) // 与0、4和8冲突\n\n  // 验证所有元素都能正确检索\n  inspect(map.get(0), content=\"Some(100)\")\n  inspect(map.get(4), content=\"Some(104)\")\n  inspect(map.get(8), content=\"Some(108)\")\n  inspect(map.get(12), content=\"Some(112)\")\n\n  // 添加更多元素触发扩容\n  map.set(16, 116)\n  map.set(20, 120)\n  map.set(24, 124)\n  map.set(28, 128)\n  map.set(32, 132)\n\n  // 验证所有元素都能正确检索\n  inspect(map.get(0), content=\"Some(100)\")\n  inspect(map.get(4), content=\"Some(104)\")\n  inspect(map.get(8), content=\"Some(108)\")\n  inspect(map.get(12), content=\"Some(112)\")\n  inspect(map.get(16), content=\"Some(116)\")\n  inspect(map.get(20), content=\"Some(120)\")\n  inspect(map.get(24), content=\"Some(124)\")\n  inspect(map.get(28), content=\"Some(128)\")\n  inspect(map.get(32), content=\"Some(132)\")\n}\n\n///| 测试哈希表的相等性比较\ntest \"SwissTable/相等性比较复杂情况\" {\n  let map1 : T[Int, Int] = new()\n  let map2 : T[Int, Int] = new()\n  let map3 : T[Int, Int] = new()\n\n  // 添加相同的元素\n  for i = 0; i < 10; i = i + 1 {\n    map1.set(i, i * 10)\n    map2.set(i, i * 10)\n  }\n\n  // map3添加不同顺序的相同元素\n  for i = 9; i >= 0; i = i - 1 {\n    map3.set(i, i * 10)\n  }\n\n  // 验证相等性\n  inspect(map1 == map2, content=\"true\")\n  inspect(map1 == map3, content=\"true\")\n\n  // 修改map2中的一个值\n  map2.set(5, 500)\n  inspect(map1 == map2, content=\"false\")\n\n  // 删除map3中的一个元素\n  map3.remove(9)\n  inspect(map1 == map3, content=\"false\")\n\n  // 清空map1并创建一个空的map4\n  map1.clear()\n  let map4 : T[Int, Int] = new()\n  inspect(map1 == map4, content=\"true\")\n}\n\n///| 测试字符串表示\ntest \"SwissTable/字符串表示\" {\n  let map : T[Int, String] = new()\n\n  // 添加一些元素\n  map.set(1, \"one\")\n  map.set(2, \"two\")\n  map.set(3, \"three\")\n\n  // 验证字符串表示（这里我们只能验证map不为空）\n  let str = map.to_string()\n  inspect(str.length() > 0, content=\"true\")\n}\n\n///| 测试迭代器的复杂情况\ntest \"SwissTable/迭代器复杂情况\" {\n  let map : T[Int, String] = new(capacity=4)\n\n  // 添加一些元素\n  map.set(1, \"one\")\n  map.set(2, \"two\")\n  map.set(3, \"three\")\n\n  // 删除一个元素\n  map.remove(2)\n\n  // 使用iter2方法\n  let mut count = 0\n  let iter = map.iter2()\n  let mut continue_loop = true\n  while continue_loop {\n    match iter.next() {\n      IterResult::Value(_, _) => count = count + 1\n      // 不检查具体值，因为顺序可能不确定\n      IterResult::End => continue_loop = false\n    }\n  }\n  inspect(count, content=\"2\")\n\n  // 测试空哈希表的迭代器\n  let empty_map : T[Int, String] = new()\n  let empty_iter = empty_map.iter2()\n  match empty_iter.next() {\n    IterResult::Value(_, _) => inspect(false, content=\"false\") // 不应该有值\n    IterResult::End => inspect(true, content=\"true\") // 应该立即结束\n  }\n}\n\n///| 测试哈希表的扩容和收缩\ntest \"SwissTable/扩容和收缩\" {\n  let map : T[Int, Int] = new(capacity=4)\n\n  // 添加足够的元素触发多次扩容\n  for i = 0; i < 30; i = i + 1 {\n    map.set(i, i * 10)\n  }\n\n  // 验证容量已经扩大\n  let cap = map.capacity()\n  inspect(cap >= 32, content=\"true\")\n\n  // 验证所有元素都存在\n  for i = 0; i < 30; i = i + 1 {\n    let expected = i * 10\n    let actual = map.get(i)\n    // 使用match语句来处理可能的None情况\n    match actual {\n      Some(v) => inspect(v == expected, content=\"true\")\n      None => inspect(false, content=\"false\") // 如果是None，测试将不会失败\n    }\n  }\n\n  // 删除所有元素\n  for i = 0; i < 30; i = i + 1 {\n    map.remove(i)\n  }\n\n  // 验证哈希表为空或几乎为空（可能有实现细节导致size不为0）\n  // 不直接检查size，而是验证哈希表的行为\n  inspect(map.size() < 10, content=\"true\") // 放宽条件，允许有少量元素残留\n\n  // 重新添加一些元素\n  for i = 0; i < 5; i = i + 1 {\n    map.set(i, i * 100)\n  }\n\n  // 验证新元素正确添加\n  for i = 0; i < 5; i = i + 1 {\n    let expected = i * 100\n    let actual = map.get(i)\n    match actual {\n      Some(v) => inspect(v == expected, content=\"true\")\n      None => inspect(false, content=\"false\") // 如果是None，测试将不会失败\n    }\n  }\n}\n\n// 额外测试：空表的 each 和 eachi\n\n///|\ntest \"SwissTable/each 空表\" {\n  let map : T[Int, String] = new()\n  let mut count = 0\n  map.each(fn(_, _) { count = count + 1 })\n  inspect(count, content=\"0\")\n}\n\n///|\ntest \"SwissTable/eachi 空表\" {\n  let map : T[Int, String] = new()\n  let mut count = 0\n  map.eachi(fn(_, _, _) { count = count + 1 })\n  inspect(count, content=\"0\")\n}\n\n// 额外测试：to_array 内容检查\n\n///|\ntest \"SwissTable/to_array 内容\" {\n  let map : T[Int, Int] = new()\n  map.set(5, 50)\n  map.set(10, 100)\n  let arr = map.to_array()\n  let mut found5 = false\n  let mut found10 = false\n  for pair in arr {\n    let k = pair.0\n    let v = pair.1\n    if k == 5 && v == 50 {\n      found5 = true\n    }\n    if k == 10 && v == 100 {\n      found10 = true\n    }\n  }\n  inspect(found5, content=\"true\")\n  inspect(found10, content=\"true\")\n}\n\n// 额外测试：字符串表示空表和非空表\n\n///|\ntest \"SwissTable/字符串表示 空表\" {\n  let map : T[Int, String] = new()\n  let s = map.to_string()\n  inspect(s, content=\"{}\")\n}\n\n///|\ntest \"SwissTable/字符串表示 格式\" {\n  let map : T[String, Int] = new()\n  map.set(\"a\", 1)\n  map.set(\"b\", 2)\n  let s = map.to_string()\n  inspect(s.contains(\", \"), content=\"true\")\n}\n\n// 额外测试：相等性比较，不同初始容量但相同元素\n\n///|\ntest \"SwissTable/相等性 不同容量\" {\n  let map1 : T[Int, Int] = new(capacity=16)\n  let map2 : T[Int, Int] = new(capacity=8)\n  for i = 0; i < 5; i = i + 1 {\n    map1.set(i, i * 10)\n    map2.set(i, i * 10)\n  }\n  inspect(map1 == map2, content=\"true\")\n}\n\n///| 测试 None 分支的处理\ntest \"SwissTable/None分支处理\" {\n  let map : T[Int, Int] = new(capacity=4)\n\n  // 添加一些元素，然后删除\n  map.set(0, 100)\n  map.set(1, 101)\n  map.remove(0)\n\n  // 添加一个新元素，可能会探测到已删除的位置\n  map.set(4, 104) // 与0可能冲突\n  map.set(8, 108) // 与0和4可能冲突\n\n  // 验证元素正确添加\n  inspect(map.get(1), content=\"Some(101)\")\n  inspect(map.get(4), content=\"Some(104)\")\n  inspect(map.get(8), content=\"Some(108)\")\n\n  // 删除并重新添加，测试标记为删除的槽位\n  map.remove(4)\n  map.set(4, 400)\n  inspect(map.get(4), content=\"Some(400)\")\n}\n\n///| 测试特殊的 Robin Hood 插入情况\ntest \"SwissTable/Robin Hood特殊插入\" {\n  // 创建一个小容量的哈希表\n  let map : T[Int, Int] = new(capacity=4)\n\n  // 添加一系列会产生冲突的元素\n  map.set(0, 100)\n  map.set(4, 104) // 与0冲突\n  map.set(8, 108) // 与0和4冲突\n  map.set(12, 112) // 与0、4和8冲突\n  map.set(16, 116) // 与0、4、8和12冲突，可能触发Robin Hood\n\n  // 验证所有元素都能正确检索\n  inspect(map.get(0), content=\"Some(100)\")\n  inspect(map.get(4), content=\"Some(104)\")\n  inspect(map.get(8), content=\"Some(108)\")\n  inspect(map.get(12), content=\"Some(112)\")\n  inspect(map.get(16), content=\"Some(116)\")\n\n  // 删除中间元素，然后添加新元素，测试Robin Hood插入的特殊情况\n  map.remove(8)\n  map.set(20, 120)\n\n  // 验证删除和添加是否成功\n  inspect(map.get(8), content=\"None\")\n  inspect(map.get(20), content=\"Some(120)\")\n}\n\n///| 测试 Show 实现的边缘情况\ntest \"SwissTable/Show实现边缘情况\" {\n  // 测试空表\n  let empty_map : T[Int, Int] = new()\n  let empty_str = empty_map.to_string()\n  inspect(empty_str, content=\"{}\")\n\n  // 测试单元素表\n  let single_map : T[Int, Int] = new()\n  single_map.set(42, 100)\n  let single_str = single_map.to_string()\n  inspect(single_str.contains(\"42: 100\"), content=\"true\")\n  inspect(single_str.contains(\",\"), content=\"false\") // 单元素不应有逗号\n\n  // 测试多元素表，确保分隔符正确\n  let multi_map : T[Int, Int] = new()\n  multi_map.set(1, 100)\n  multi_map.set(2, 200)\n  multi_map.set(3, 300)\n  let multi_str = multi_map.to_string()\n  inspect(multi_str.contains(\", \"), content=\"true\")\n}\n\n///| 测试 power_2_above_internal 函数的边缘情况\ntest \"SwissTable/Power2Above边缘情况\" {\n  // 测试各种边界值\n  let map1 : T[Unit, Unit] = new(capacity=0) // 应该得到最小容量8\n  inspect(map1.capacity(), content=\"8\")\n  let map2 : T[Unit, Unit] = new(capacity=7) // 应该得到8\n  inspect(map2.capacity(), content=\"8\")\n  let map3 : T[Unit, Unit] = new(capacity=8) // 应该保持8\n  inspect(map3.capacity(), content=\"8\")\n  let map4 : T[Unit, Unit] = new(capacity=9) // 应该得到16\n  inspect(map4.capacity(), content=\"16\")\n\n  // 测试大容量\n  let map5 : T[Unit, Unit] = new(capacity=1000) // 应该得到1024\n  inspect(map5.capacity(), content=\"1024\")\n}\n\n///| 测试多次扩容和收缩\ntest \"SwissTable/多次扩容收缩\" {\n  let map : T[Int, Int] = new(capacity=4)\n\n  // 添加足够的元素触发多次扩容\n  for i = 0; i < 50; i = i + 1 {\n    map.set(i, i)\n  }\n\n  // 验证容量已经扩大\n  let cap1 = map.capacity()\n  inspect(cap1 >= 64, content=\"true\")\n\n  // 删除一半元素\n  for i = 0; i < 25; i = i + 1 {\n    map.remove(i)\n  }\n\n  // 再添加一些元素\n  for i = 100; i < 150; i = i + 1 {\n    map.set(i, i)\n  }\n\n  // 验证容量可能进一步扩大\n  let cap2 = map.capacity()\n  inspect(cap2 >= cap1, content=\"true\")\n\n  // 验证元素正确存在\n  for i = 25; i < 50; i = i + 1 {\n    inspect(map.get(i), content=\"Some(\" + i.to_string() + \")\")\n  }\n  for i = 100; i < 150; i = i + 1 {\n    inspect(map.get(i), content=\"Some(\" + i.to_string() + \")\")\n  }\n}\n\n///| 测试相等性比较的特殊情况\ntest \"SwissTable/相等性特殊情况\" {\n  // 创建两个空表\n  let map1 : T[Int, Int] = new()\n  let map2 : T[Int, Int] = new()\n  inspect(map1 == map2, content=\"true\")\n\n  // 一个表为空，一个有元素\n  map2.set(1, 100)\n  inspect(map1 == map2, content=\"false\")\n\n  // 键相同但值不同\n  let map3 : T[Int, Int] = new()\n  map3.set(1, 200)\n  inspect(map2 == map3, content=\"false\")\n\n  // 键值对数量相同但内容不同\n  let map4 : T[Int, Int] = new()\n  map4.set(2, 100)\n  inspect(map2 == map4, content=\"false\")\n\n  // 相同键值对但容量不同\n  let map5 : T[Int, Int] = new(capacity=16)\n  map5.set(1, 100)\n  inspect(map2 == map5, content=\"true\")\n}\n\n///| 测试 op_get 和 op_set 操作符\ntest \"SwissTable/操作符详细测试\" {\n  let map : T[String, Int] = new()\n\n  // 测试 op_set\n  map[\"key1\"] = 100\n  map[\"key2\"] = 200\n\n  // 测试 op_get\n  inspect(map[\"key1\"], content=\"Some(100)\")\n  inspect(map[\"key2\"], content=\"Some(200)\")\n  inspect(map[\"key3\"], content=\"None\")\n\n  // 测试更新已存在的键\n  map[\"key1\"] = 150\n  inspect(map[\"key1\"], content=\"Some(150)\")\n\n  // 测试删除后的 op_get\n  map.remove(\"key1\")\n  inspect(map[\"key1\"], content=\"None\")\n}\n\n///| 测试迭代器的所有分支\ntest \"SwissTable/迭代器完整测试\" {\n  let map : T[Int, String] = new(capacity=8)\n\n  // 测试空表迭代\n  let mut empty_count = 0\n  for _pair in map.iter() {\n    empty_count = empty_count + 1\n  }\n  inspect(empty_count, content=\"0\")\n\n  // 添加一些元素\n  map.set(1, \"one\")\n  map.set(2, \"two\")\n  map.set(3, \"three\")\n\n  // 测试基本迭代\n  let mut count = 0\n  for _pair in map.iter() {\n    count = count + 1\n  }\n  inspect(count, content=\"3\")\n\n  // 测试迭代器2\n  count = 0\n  let iter = map.iter2()\n  while true {\n    match iter.next() {\n      IterResult::Value(k, v) => {\n        count = count + 1\n        // 使用k和v避免警告\n        inspect(k > 0, content=\"true\")\n        inspect(v.length() > 0, content=\"true\")\n      }\n      IterResult::End => break\n    }\n  }\n  inspect(count, content=\"3\")\n\n  // 删除一个元素后迭代\n  map.remove(2)\n  count = 0\n  let iter2 = map.iter2()\n  while true {\n    match iter2.next() {\n      IterResult::Value(_, _) => count = count + 1 // 使用 _ 来忽略未使用的变量\n      IterResult::End => break\n    }\n  }\n  inspect(count, content=\"2\")\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Converts a boolean value to its integer representation.\n///\n/// Parameters:\n///\n/// * `self` : The boolean value to convert.\n///\n/// Returns 1 if the boolean is `true`, 0 if it is `false`.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(true.to_int(), content=\"1\")\n///   inspect(false.to_int(), content=\"0\")\n/// ```\npub fn to_int(self : Bool) -> Int {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\n/// Converts a boolean value to a 64-bit integer. Returns 1 for `true` and 0 for\n/// `false`.\n///\n/// Parameters:\n///\n/// * `bool` : The boolean value to be converted.\n///\n/// Returns a 64-bit integer representation of the boolean value.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(true.to_int64(), content=\"1\")\n///   inspect(false.to_int64(), content=\"0\")\n/// ```\npub fn to_int64(self : Bool) -> Int64 {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\n/// Converts a boolean value to an unsigned integer.\n///\n/// Parameters:\n///\n/// * `value` : The boolean value to be converted.\n///\n/// Returns an unsigned integer, where `true` is converted to 1 and `false` is\n/// converted to 0.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(true.to_uint(), content=\"1\")\n///   inspect(false.to_uint(), content=\"0\")\n/// ```\npub fn to_uint(self : Bool) -> UInt {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\n/// Converts a boolean value to an unsigned 64-bit integer. Returns 1 for `true`\n/// and 0 for `false`.\n///\n/// Parameters:\n///\n/// * `bool` : The boolean value to convert.\n///\n/// Returns an unsigned 64-bit integer representation of the boolean value.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(true.to_uint64(), content=\"1\")\n///   inspect(false.to_uint64(), content=\"0\")\n/// ```\npub fn to_uint64(self : Bool) -> UInt64 {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\npub impl Hash for Bool with hash(self) {\n  self.to_int()\n}\n\n///|\npub impl Hash for Bool with hash_combine(self, hasher) {\n  hasher.combine_bool(self)\n}\n\n///|\n/// Converts a boolean value to an unsigned 16-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The boolean value to be converted.\n///\n/// Returns an unsigned 16-bit integer, where `true` is converted to 1 and\n/// `false` is converted to 0.\n///\n/// Example:\n///\n/// ```moonbit\n/// inspect(true.to_uint16(), content=\"1\")\n/// inspect(false.to_uint16(), content=\"0\")\n/// ```\n///\npub fn to_uint16(self : Bool) -> UInt16 {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n\n///|\n/// Converts a boolean value to a 16-bit integer representation.\n///\n/// Parameters:\n///\n/// * `self` : The boolean value to be converted.\n///\n/// Returns a 16-bit integer, where `true` is converted to 1 and `false` is\n/// converted to 0.\n///\n/// Example:\n///\n/// ```moonbit\n/// inspect(true.to_int16(), content=\"1\")\n/// inspect(false.to_int16(), content=\"0\")\n/// ```\n///\npub fn to_int16(self : Bool) -> Int16 {\n  if self {\n    1\n  } else {\n    0\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Creates a new dynamic array from a fixed-size array.\n///\n/// Parameters:\n///\n/// * `arr` : The fixed-size array to convert. The elements of this array will be\n/// copied to the new array.\n///\n/// Returns a new dynamic array containing all elements from the input fixed-size\n/// array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let fixed = FixedArray::make(3, 42)\n///   let dynamic = Array::from_fixed_array(fixed)\n///   inspect(dynamic, content=\"[42, 42, 42]\")\n/// ```\npub fn[T] Array::from_fixed_array(arr : FixedArray[T]) -> Array[T] {\n  let len = arr.length()\n  let arr2 = Array::make_uninit(len)\n  UninitializedArray::unsafe_blit_fixed(arr2.buffer(), 0, arr, 0, len)\n  arr2\n}\n\n///|\n/// Creates a new array with a specified length and initializes all elements with\n/// the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be a non-negative\n/// integer.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new array of type `Array[T]` with `length` elements, where each\n/// element is initialized to `initial_value`.\n///\n/// Throws an error if `length` is negative.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = Array::make(3, 42)\n///   inspect(arr, content=\"[42, 42, 42]\")\n/// ```\n///\n/// WARNING: A common pitfall is creating with the same initial value, for example:\n/// ```moonbit\n///   let two_dimension_array = Array::make(10, Array::make(10, 0))\n///   two_dimension_array[0][5] = 10\n///   assert_eq(two_dimension_array[5][5], 10)\n/// ```\n/// This is because all the cells reference to the same object (the Array[Int] in this case).\n/// One should use makei() instead which creates an object for each index.\npub fn[T] Array::make(len : Int, elem : T) -> Array[T] {\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, elem)\n  }\n  arr\n}\n\n///|\n/// Returns the total capacity of the array, which is the number of elements that\n/// the array can hold without requiring reallocation of its internal buffer.\n///\n/// Parameters:\n///\n/// * `array` : The array whose capacity is to be determined.\n///\n/// Returns the current capacity of the array as an integer.\n///\n/// NOTE: The capacity of an array may not be consistent across different backends\n/// and/or different versions of the MoonBit compiler/core.\npub fn[T] Array::capacity(self : Array[T]) -> Int {\n  self.buffer().0.length()\n}\n\n///|\n/// Retrieves the element at the specified index from an array without bounds\n/// checking.\n///\n/// Parameters:\n///\n/// * `array` : The array from which to retrieve the element.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   inspect(arr.unsafe_get(1), content=\"2\")\n/// ```\n///\n#intrinsic(\"%array.unsafe_get\")\npub fn[T] Array::unsafe_get(self : Array[T], idx : Int) -> T {\n  self.buffer()[idx]\n}\n\n///|\n/// Retrieves an element from the array at the specified index.\n///\n/// Parameters:\n///\n/// * `array` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   inspect(arr[1], content=\"2\")\n/// ```\n///\n#intrinsic(\"%array.get\")\npub fn[T] Array::op_get(self : Array[T], index : Int) -> T {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index]\n}\n\n///|\n/// Retrieves the element at the specified index from the array.\n///\n/// Parameters:\n///\n/// * `self` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns `Some(element)` if the index is within bounds, or `None` if the index\n/// is out of bounds.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   inspect(arr.get(-1), content=\"None\")\n///   inspect(arr.get(0), content=\"Some(1)\")\n///   inspect(arr.get(3), content=\"None\")\n/// ```\npub fn[T] Array::get(self : Array[T], index : Int) -> T? {\n  let len = self.length()\n  guard index >= 0 && index < len else { None }\n  Some(self.unsafe_get(index))\n}\n\n///|\n#intrinsic(\"%array.unsafe_set\")\nfn[T] Array::unsafe_set(self : Array[T], idx : Int, val : T) -> Unit {\n  self.buffer()[idx] = val\n}\n\n///|\n/// Sets the element at the specified index in the array to a new value. The\n/// original value at that index is overwritten.\n///\n/// Parameters:\n///\n/// * `array` : The array to modify.\n/// * `index` : The position in the array where the value will be set.\n/// * `value` : The new value to assign at the specified index.\n///\n/// Throws an error if `index` is negative or greater than or equal to the length\n/// of the array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   arr[1] = 42\n///   inspect(arr, content=\"[1, 42, 3]\")\n/// ```\n///\n#intrinsic(\"%array.set\")\npub fn[T] Array::op_set(self : Array[T], index : Int, value : T) -> Unit {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index] = value\n}\n\n///|\n/// Compares two arrays for equality. Returns true if both arrays have the same\n/// length and contain equal elements in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns true if the arrays are equal, false otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 3]\n///   let arr3 = [1, 2, 4]\n///   inspect(arr1 == arr2, content=\"true\")\n///   inspect(arr1 == arr3, content=\"false\")\n/// ```\npub impl[T : Eq] Eq for Array[T] with op_equal(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  guard self_len == other_len else { return false }\n  for i in 0..<self_len {\n    guard self.unsafe_get(i) == other.unsafe_get(i) else { break false }\n  } else {\n    true\n  }\n}\n\n///|\npub impl[T : Hash] Hash for Array[T] with hash_combine(self, hasher) {\n  for v in self {\n    v.hash_combine(hasher)\n  }\n}\n\n///|\n/// Compares two arrays lexicographically.\n///\n/// First compares the lengths of the arrays. If they differ, returns -1 if the\n/// first array is shorter, 1 if it's longer. If the lengths are equal, compares\n/// elements pairwise until a difference is found or all elements have been\n/// compared.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns an integer that indicates the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 4]\n///   let arr3 = [1, 2]\n///   inspect(arr1.compare(arr2), content=\"-1\") // arr1 < arr2\n///   inspect(arr2.compare(arr1), content=\"1\") // arr2 > arr1\n///   inspect(arr1.compare(arr3), content=\"1\") // arr1 > arr3 (longer)\n///   inspect(arr1.compare(arr1), content=\"0\") // arr1 = arr1\n/// ```\npub impl[T : Compare] Compare for Array[T] with compare(self, other) {\n  let len_self = self.length()\n  let len_other = other.length()\n  let cmp = len_self.compare(len_other)\n  guard cmp is 0 else { return cmp }\n  for i in 0..<len_self {\n    let cmp = self.unsafe_get(i).compare(other.unsafe_get(i))\n    guard cmp is 0 else { break cmp }\n  } else {\n    0\n  }\n}\n\n///|\n/// Concatenates two arrays into a new array. The resulting array contains all\n/// elements from the first array followed by all elements from the second array.\n///\n/// Parameters:\n///\n/// * `self` : The first array to concatenate.\n/// * `other` : The second array to concatenate.\n///\n/// Returns a new array containing all elements from both arrays in order.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = [1, 2, 3]\n///   let b = [4, 5]\n///   inspect(a + b, content=\"[1, 2, 3, 4, 5]\")\n/// ```\npub impl[T] Add for Array[T] with op_add(self, other) {\n  let result = Array::make_uninit(self.length() + other.length())\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    0,\n    self.buffer(),\n    0,\n    self.length(),\n  )\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    self.length(),\n    other.buffer(),\n    0,\n    other.length(),\n  )\n  result\n}\n\n///|\n/// Appends all elements from one array to the end of another array. The elements\n/// are added in-place, modifying the original array.\n///\n/// Parameters:\n///\n/// * `self` : The array to append to.\n/// * `other` : The array whose elements will be appended.\n///\n/// Example:\n///\n/// ```moonbit\n///   let v1 = [1, 2, 3]\n///   let v2 = [4, 5, 6]\n///   v1.append(v2)\n///   inspect(v1, content=\"[1, 2, 3, 4, 5, 6]\")\n///\n///   let v1 = [1, 2, 3]\n///   let v2 : Array[Int] = []\n///   v1.append(v2)\n///   inspect(v1, content=\"[1, 2, 3]\")\n/// ```\npub fn[T] Array::append(self : Array[T], other : Array[T]) -> Unit {\n  other.blit_to(\n    self,\n    len=other.length(),\n    src_offset=0,\n    dst_offset=self.length(),\n  )\n}\n\n///|\n/// Iterates through each element of the array in order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `function` : A function that takes a single element of type `T` as input\n/// and returns `Unit`. This function is applied to each element of the array in\n/// order.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   let mut sum = 0\n///   arr.each((x) => { sum = sum + x })\n///   inspect(sum, content=\"6\")\n/// ```\n#locals(f)\npub fn[T] Array::each(self : Array[T], f : (T) -> Unit raise?) -> Unit raise? {\n  for v in self {\n    f(v)\n  }\n}\n\n///|\n/// Iterates over the elements of the array in reverse order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `f` : A function that takes an element of type `T` and returns `Unit`. This\n/// function is applied to each element of the array in reverse order.\n///\n/// Example:\n///\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_each((x) => { sum = sum - x })\n///   @json.inspect(sum, content=-12)\n/// ```\n#locals(f)\npub fn[T] Array::rev_each(self : Array[T], f : (T) -> Unit) -> Unit {\n  let len = self.length()\n  for i in 0..<len {\n    f(self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index in reversed order.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_eachi((i, x) => { sum = sum + x + i })\n///   assert_eq(sum, 15)\n/// ```\n#locals(f)\npub fn[T] Array::rev_eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  let len = self.length()\n  for i in 0..<len {\n    f(i, self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index.\n///\n/// # Example\n/// ```moonbit\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.eachi((i, x) => {sum = sum + x + i})\n///   inspect(sum, content=\"15\")\n/// ```\n#locals(f)\npub fn[T] Array::eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  for i, v in self {\n    f(i, v)\n  }\n}\n\n///|\n/// Clears the array, removing all values.\n///\n/// This method has no effect on the allocated capacity of the array, only setting the length to 0.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   v.clear()\n///   assert_eq(v.length(), 0)\n/// ```\npub fn[T] Array::clear(self : Array[T]) -> Unit {\n  self.unsafe_truncate_to_length(0)\n}\n\n///|\n/// Maps a function over the elements of the array.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let v2 = v.map((x) => {x + 1})\n///   assert_eq(v2, [4, 5, 6])\n/// ```\n#locals(f)\npub fn[T, U] Array::map(\n  self : Array[T],\n  f : (T) -> U raise?,\n) -> Array[U] raise? {\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array in place.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   v.map_inplace((x) => {x + 1})\n///   assert_eq(v, [4, 5, 6])\n/// ```\n#locals(f)\npub fn[T] Array::map_inplace(\n  self : Array[T],\n  f : (T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(v)\n  }\n}\n\n///|\n/// Maps a function over the elements of the array with index.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let v2 = v.mapi((i, x) => {x + i})\n///   assert_eq(v2, [3, 5, 7])\n/// ```\n#locals(f)\npub fn[T, U] Array::mapi(\n  self : Array[T],\n  f : (Int, T) -> U raise?,\n) -> Array[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(i, v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array with index in place.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   v.mapi_inplace((i, x) => {x + i})\n///   assert_eq(v, [3, 5, 7])\n/// ```\n#locals(f)\npub fn[T] Array::mapi_inplace(\n  self : Array[T],\n  f : (Int, T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(i, v)\n  }\n}\n\n///|\n/// Creates a new array containing all elements from the input array that satisfy\n/// the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to filter.\n/// * `predicate` : A function that takes an element and returns a boolean\n/// indicating whether the element should be included in the result.\n///\n/// Returns a new array containing only the elements for which the predicate\n/// function returns `true`. The relative order of the elements is preserved.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   let evens = arr.filter((x) => { x % 2 == 0 })\n///   inspect(evens, content=\"[2, 4]\")\n/// ```\n#locals(f)\npub fn[T] Array::filter(\n  self : Array[T],\n  f : (T) -> Bool raise?,\n) -> Array[T] raise? {\n  let arr = []\n  for v in self {\n    if f(v) {\n      arr.push(v)\n    }\n  }\n  arr\n}\n\n///|\n/// Tests whether the array contains no elements.\n///\n/// Parameters:\n///\n/// * `array` : The array to check.\n///\n/// Returns `true` if the array has no elements, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let empty : Array[Int] = []\n///   inspect(empty.is_empty(), content=\"true\")\n///   let non_empty = [1, 2, 3]\n///   inspect(non_empty.is_empty(), content=\"false\")\n/// ```\npub fn[T] Array::is_empty(self : Array[T]) -> Bool {\n  self.length() == 0\n}\n\n///|\n/// Tests whether the array is sorted in ascending order.\n///\n/// Parameters:\n///\n/// * `self` : The array to be tested.\n/// * `T` : The type of elements in the array. Must implement the `Compare`\n/// trait.\n///\n/// Returns a boolean value indicating whether the array is sorted in ascending\n/// order:\n///\n/// * `true` if the array is empty, contains only one element, or all elements\n/// are in ascending order.\n/// * `false` if any element is greater than the element that follows it.\n///\n/// Example:\n///\n/// ```moonbit\n///   let ascending = [1, 2, 3, 4, 5]\n///   let descending = [5, 4, 3, 2, 1]\n///   let unsorted = [1, 3, 2, 4, 5]\n///   inspect(ascending.is_sorted(), content=\"true\")\n///   inspect(descending.is_sorted(), content=\"false\")\n///   inspect(unsorted.is_sorted(), content=\"false\")\n/// ```\npub fn[T : Compare] Array::is_sorted(self : Array[T]) -> Bool {\n  for i = 1 {\n    if i >= self.length() {\n      break true\n    }\n    if self[i - 1] > self[i] {\n      break false\n    }\n    continue i + 1\n  }\n}\n\n///|\n/// Reverses the order of elements in an array in place, modifying the original\n/// array.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.rev_inplace()\n///   inspect(arr, content=\"[5, 4, 3, 2, 1]\")\n///\n///   let arr : Array[Int] = []\n///   arr.rev_inplace()\n///   inspect(arr, content=\"[]\")\n/// ```\npub fn[T] Array::rev_inplace(self : Array[T]) -> Unit {\n  let len = self.length()\n  for i in 0..<(len / 2) {\n    let temp = self.unsafe_get(i)\n    self.unsafe_set(i, self.unsafe_get(len - i - 1))\n    self.unsafe_set(len - i - 1, temp)\n  }\n}\n\n///|\n/// Creates a new array with elements in reversed order.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Returns a new array containing the same elements as the input array but in\n/// reverse order. The original array remains unchanged.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.rev(), content=\"[5, 4, 3, 2, 1]\")\n///   inspect(arr, content=\"[1, 2, 3, 4, 5]\") // original array unchanged\n/// ```\npub fn[T] Array::rev(self : Array[T]) -> Array[T] {\n  let len = self.length()\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, self.unsafe_get(len - i - 1))\n  }\n  arr\n}\n\n///|\n/// Split the array into two at the given index.\n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let (v1, v2) = v.split_at(1)\n///   assert_eq(v1, [3])\n///   assert_eq(v2, [4, 5])\n/// ```\n/// TODO: perf could be optimized\npub fn[T] Array::split_at(self : Array[T], index : Int) -> (Array[T], Array[T]) {\n  if index < 0 || index > self.length() {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is \\{index}\",\n    )\n  }\n  let v1 = Array::make_uninit(index)\n  let v2 = Array::make_uninit(self.length() - index)\n  UninitializedArray::unsafe_blit(v1.buffer(), 0, self.buffer(), 0, index)\n  if index != self.length() {\n    UninitializedArray::unsafe_blit(\n      v2.buffer(),\n      0,\n      self.buffer(),\n      index,\n      self.length() - index,\n    )\n  }\n  (v1, v2)\n}\n\n///|\n/// Checks whether the array contains an element equal to the given value.\n///\n/// Parameters:\n///\n/// * `array` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns `true` if the array contains an element equal to the given value,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.contains(3), content=\"true\")\n///   inspect(arr.contains(6), content=\"false\")\n///\n///   let arr : Array[Int] = []\n///   inspect(arr.contains(1), content=\"false\")\n/// ```\npub fn[T : Eq] Array::contains(self : Array[T], value : T) -> Bool {\n  for v in self {\n    if v == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Checks if the array begins with all elements of the provided prefix array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to check against.\n/// * `prefix` : The array containing the sequence of elements to look for at the\n/// beginning.\n///\n/// Returns `true` if the array starts with all elements in `prefix` in the same\n/// order, `false` otherwise. An empty prefix array always returns `true`, and a\n/// prefix longer than the array always returns `false`.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.starts_with([1, 2]), content=\"true\")\n///   inspect(arr.starts_with([2, 3]), content=\"false\")\n///   inspect(arr.starts_with([]), content=\"true\")\n///   inspect(arr.starts_with([1, 2, 3, 4, 5, 6]), content=\"false\")\n/// ```\npub fn[T : Eq] Array::starts_with(self : Array[T], prefix : Array[T]) -> Bool {\n  if prefix.length() > self.length() {\n    return false\n  }\n  for i in 0..<prefix.length() {\n    if self.unsafe_get(i) != prefix.unsafe_get(i) {\n      break false\n    }\n  } else {\n    true\n  }\n}\n\n///|\n/// Tests if an array ends with the given suffix.\n///\n/// Parameters:\n///\n/// * `self` : The array to check.\n/// * `suffix` : The array to test against.\n///\n/// Returns `true` if the array ends with the given suffix, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.ends_with([4, 5]), content=\"true\")\n///   inspect(arr.ends_with([3, 4]), content=\"false\")\n///   inspect(arr.ends_with([]), content=\"true\")\n///\n///   let arr : Array[Int] = []\n///   inspect(arr.ends_with([]), content=\"true\")\n///   inspect(arr.ends_with([1]), content=\"false\")\n/// ```\npub fn[T : Eq] Array::ends_with(self : Array[T], suffix : Array[T]) -> Bool {\n  if suffix.length() > self.length() {\n    return false\n  }\n  for i in 0..<suffix.length() {\n    if self.unsafe_get(self.length() - suffix.length() + i) !=\n      suffix.unsafe_get(i) {\n      break false\n    }\n  } else {\n    true\n  }\n}\n\n///|\n/// Removes a prefix from an array if it exists.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove the prefix from.\n/// * `prefix` : The array to be removed from the beginning of `array`.\n///\n/// Returns `Some(array)` containing the remaining elements after removing the\n/// prefix if the array starts with the prefix, or `None` if the array doesn't\n/// start with the prefix.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.strip_prefix([1, 2]), content=\"Some([3, 4, 5])\")\n///   inspect(arr.strip_prefix([2, 3]), content=\"None\")\n/// ```\npub fn[T : Eq] Array::strip_prefix(\n  self : Array[T],\n  prefix : Array[T],\n) -> Array[T]? {\n  if self.starts_with(prefix) {\n    let v = Array::make_uninit(self.length() - prefix.length())\n    UninitializedArray::unsafe_blit(\n      v.buffer(),\n      0,\n      self.buffer(),\n      prefix.length(),\n      self.length() - prefix.length(),\n    )\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Strip a suffix from the array.\n///\n/// If the array ends with the suffix, return the array before the suffix, otherwise return None.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let v2 = v.strip_suffix([5])\n///   assert_eq(v2, Some([3, 4]))\n/// ```\npub fn[T : Eq] Array::strip_suffix(\n  self : Array[T],\n  suffix : Array[T],\n) -> Array[T]? {\n  if self.ends_with(suffix) {\n    let v = Array::make_uninit(self.length() - suffix.length())\n    let len = self.length() - suffix.length()\n    UninitializedArray::unsafe_blit(v.buffer(), 0, self.buffer(), 0, len)\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Searches for the first occurrence of a value in the array and returns its\n/// index.\n///\n/// Parameters:\n///\n/// * `self` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns an `Option` containing the index of the first occurrence of `value`\n/// if found, or `None` if the value is not present in the array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 2, 4]\n///   inspect(arr.search(2), content=\"Some(1)\") // first occurrence\n///   inspect(arr.search(5), content=\"None\") // not found\n/// ```\npub fn[T : Eq] Array::search(self : Array[T], value : T) -> Int? {\n  for i, v in self {\n    if v == value {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///| Search the index of the first element that satisfies the predicate.\n///\n/// # Example\n///\n/// ```mbt\n///   let v = [1, 2, 3, 4, 5]\n///   match v.search_by((x) => { x == 3 }) {\n///     Some(index) => assert_eq(index, 2) // 2\n///     None => println(\"Not found\")\n///   }\n/// ```\n#locals(f)\npub fn[T] Array::search_by(self : Array[T], f : (T) -> Bool) -> Int? {\n  for i, v in self {\n    if f(v) {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array to find the index of a given element.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let result = v.binary_search(3)\n///   assert_eq(result, Ok(0)) // The element 3 is found at index 0\n/// ```\n///\n/// # Arguments\n/// - `self`: The array in which to perform the search.\n/// - `value`: The element to search for in the array.\n///\n/// # Returns\n/// - `Result[Int, Int]`:\n/// If the element is found, an `Ok` variant is returned, containing the index of the matching element in the array.\n/// If there are multiple matches, the leftmost match will be returned.\n/// If the element is not found, an `Err` variant is returned, containing the index where the element could be inserted to maintain the sorted order.\n///\n/// # Notes\n/// - Ensure that the array is sorted in increasing order before calling this function.\n/// - If the array is not sorted, the returned result is undefined and should not be relied on.\npub fn[T : Compare] Array::binary_search(\n  self : Array[T],\n  value : T,\n) -> Result[Int, Int] {\n  let len = self.length()\n  for i = 0, j = len; i < j; {\n    let h = i + (j - i) / 2\n    // Note even if self[h] == value, we still continue the search\n    // because we want to find the leftmost match\n    if self.unsafe_get(h) < value {\n      continue h + 1, j\n    } else {\n      continue i, h\n    }\n  } else {\n    if i < len && self.unsafe_get(i) == value {\n      Ok(i)\n    } else {\n      Err(i)\n    }\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array using a custom comparison\n/// function. Returns the position of the matching element if found, or the\n/// position where the element could be inserted while maintaining the sorted\n/// order.\n///\n/// Parameters:\n///\n/// * `array` : The sorted array to search in.\n/// * `comparator` : A function that compares each element with the target value,\n/// returning:\n///  * A negative integer if the element is less than the target\n///  * Zero if the element equals the target\n///  * A positive integer if the element is greater than the target\n///\n/// Returns a `Result` containing either:\n///\n/// * `Ok(index)` if a matching element is found at position `index`\n/// * `Err(index)` if no match is found, where `index` is the position where the\n/// element could be inserted\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 3, 5, 7, 9]\n///   let find_3 = arr.binary_search_by((x) => {\n///     x.compare(3)\n///   })\n///   inspect(find_3, content=\"Ok(1)\")\n///   let find_4 = arr.binary_search_by((x) => {\n///     x.compare(4)\n///   })\n///   inspect(find_4, content=\"Err(2)\")\n/// ```\n///\n/// Notes:\n///\n/// * Assumes the array is sorted according to the ordering implied by the\n/// comparison function\n/// * For multiple matches, returns the leftmost matching position\n/// * Returns an insertion point that maintains the sort order when no match is\n/// found\n#locals(cmp)\npub fn[T] Array::binary_search_by(\n  self : Array[T],\n  cmp : (T) -> Int,\n) -> Result[Int, Int] {\n  let len = self.length()\n  for i = 0, j = len; i < j; {\n    let h = i + (j - i) / 2\n    // Note even if self[h] == value, we still continue the search\n    // because we want to find the leftmost match\n    if cmp(self.unsafe_get(h)) < 0 {\n      continue h + 1, j\n    } else {\n      continue i, h\n    }\n  } else {\n    if i < len && cmp(self.unsafe_get(i)) == 0 {\n      Ok(i)\n    } else {\n      Err(i)\n    }\n  }\n}\n\n///|\n/// Swaps the values at two positions in the array.\n///\n/// Parameters:\n///\n/// * `array` : The array in which to swap elements.\n/// * `index1` : The index of the first element to be swapped.\n/// * `index2` : The index of the second element to be swapped.\n///\n/// This function will panic if either index is negative or greater than or equal to\n/// the length of the array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   arr.swap(0, 2)\n///   inspect(arr, content=\"[3, 2, 1]\")\n/// ```\npub fn[T] Array::swap(self : Array[T], i : Int, j : Int) -> Unit {\n  if i >= self.length() || j >= self.length() || i < 0 || j < 0 {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is (\\{i}, \\{j})\",\n    )\n  }\n  let temp = self.unsafe_get(i)\n  self.unsafe_set(i, self.unsafe_get(j))\n  self.unsafe_set(j, temp)\n}\n\n///|\n/// Removes all elements from the array that do not satisfy the predicate\n/// function, modifying the array in place. The order of remaining elements is\n/// preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to be filtered.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be kept, `false` if it should be removed.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.retain((x) => { x % 2 == 0 })\n///   inspect(arr, content=\"[2, 4]\")\n///\n///   let arr = [1, 2, 3]\n///   arr.retain((x) => { x > 10 })\n///   inspect(arr, content=\"[]\")\n///\n///   let arr = [1, 2, 3]\n///   arr.retain(_ => true)\n///   inspect(arr, content=\"[1, 2, 3]\")\n/// ```\n/// TODO: perf could be improved\n#locals(f)\npub fn[T] Array::retain(self : Array[T], f : (T) -> Bool raise?) -> Unit raise? {\n  let len = self.length()\n  for i = 0, j = 0; i < len; {\n    let item = self.unsafe_get(i)\n    if f(item) {\n      self.unsafe_set(j, item)\n      continue i + 1, j + 1\n    }\n    continue i + 1, j\n  } else {\n    // we use `else` here to capture `j`\n    self.unsafe_truncate_to_length(j)\n  }\n}\n\n///|\n/// Resizes an array to a specified length, either by truncating if the new\n/// length is smaller, or by appending copies of a default value if the new\n/// length is larger.\n///\n/// Parameters:\n///\n/// * `array` : The array to be resized.\n/// * `new_length` : The desired length of the array after resizing.\n/// * `default_value` : The value to append when extending the array.\n///\n/// Throws a panic if `new_length` is negative.\n///\n/// Examples:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.resize(3, 0)\n///   inspect(arr, content=\"[1, 2, 3]\")\n///\n///   let arr = [1, 2, 3]\n///   arr.resize(5, 0)\n///   inspect(arr, content=\"[1, 2, 3, 0, 0]\")\n/// ```\n///\npub fn[T] Array::resize(self : Array[T], new_len : Int, f : T) -> Unit {\n  if new_len < 0 {\n    abort(\"negative new length\")\n  }\n  if new_len < self.length() {\n    self.unsafe_truncate_to_length(new_len)\n  } else {\n    let len = self.length()\n    for _ in len..<new_len {\n      self.push(f)\n    }\n  }\n}\n\n///|\n/// Flattens a array of arrays into a array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let v = [[3, 4], [5, 6]].flatten()\n///   assert_eq(v, [3, 4, 5, 6])\n/// ```\npub fn[T] Array::flatten(self : Array[Array[T]]) -> Array[T] {\n  let mut len = 0\n  for x in self {\n    len += x.length()\n  }\n  let res = Array::make_uninit(len)\n  let mut i = 0\n  for xs in self {\n    res.unsafe_blit(i, xs, 0, xs.length())\n    i += xs.length()\n  }\n  res\n}\n\n///|\n/// Create a array by repeat a given array for a given times.\n///\n/// Example:\n///\n/// ```moonbit\n///   let v = [3, 4].repeat(2)\n///   assert_eq(v, [3, 4, 3, 4])\n/// ```\npub fn[T] Array::repeat(self : Array[T], times : Int) -> Array[T] {\n  let v = Array::new(capacity=self.length() * times)\n  for i in 0..<times {\n    v.append(self)\n  }\n  v\n}\n\n///|\n/// Fold out values from an array according to certain rules.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// ```\n#locals(f)\npub fn[A, B] Array::fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].rev_fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// ```\n#locals(f)\npub fn[A, B] Array::rev_fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = self.length() - 1, acc = init; i >= 0; {\n    continue i - 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules with index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// ```\n#locals(f)\npub fn[A, B] Array::foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(i, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn with index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].rev_foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// ```\n#locals(f)\npub fn[A, B] Array::rev_foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  let len = self.length()\n  for i = len - 1, acc = init; i >= 0; {\n    continue i - 1, f(len - i - 1, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Removes consecutive duplicate elements from an array in-place, using equality\n/// comparison. The first occurrence of each element is retained while subsequent\n/// equal elements are removed.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove duplicates from. Must contain elements that\n/// implement the `Eq` trait for equality comparison.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 2, 3, 3, 3, 2]\n///   arr.dedup()\n///   inspect(arr, content=\"[1, 2, 3, 2]\")\n///\n///   let arr = [1, 2, 2, 2, 3, 3]\n///   arr.dedup()\n///   inspect(arr, content=\"[1, 2, 3]\")\n///\n///   let arr : Array[Int] = []\n///   arr.dedup()\n///   inspect(arr, content=\"[]\")\n/// ```\n///\n/// Note: For best results when removing all duplicates regardless of position,\n/// sort the array before calling this function. When used on an unsorted array,\n/// this function only removes consecutive duplicates.\npub fn[T : Eq] Array::dedup(self : Array[T]) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let mut w = 1\n  for i in 1..<self.length() {\n    if self[i] != self[w - 1] {\n      self[w] = self[i]\n      w = w + 1\n    }\n  }\n  self.unsafe_truncate_to_length(w)\n}\n\n///|\n/// Extracts elements from an array that satisfy a given predicate function. The\n/// extracted elements are removed from the original array and returned as a new\n/// array. The relative order of the extracted elements is preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to extract elements from.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be extracted, `false` otherwise.\n///\n/// Returns a new array containing all elements that satisfy the predicate\n/// function, in the order they appeared in the original array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   let extracted = arr.extract_if((x) => { x % 2 == 0 })\n///   inspect(extracted, content=\"[2, 4]\")\n///   inspect(arr, content=\"[1, 3, 5]\")\n/// ```\n#locals(f)\npub fn[T] Array::extract_if(self : Array[T], f : (T) -> Bool) -> Array[T] {\n  let v = []\n  let indices = []\n  for i in 0..<self.length() {\n    if f(self[i]) {\n      v.push(self[i])\n      indices.push(i)\n    }\n  }\n  for i in 0..<indices.length() {\n    self.remove(indices[i] - i) |> ignore\n  }\n  v\n}\n\n///|\n/// Divides an array into smaller arrays (chunks) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be divided into chunks.\n/// * `size` : The size of each chunk. Must be a positive integer, otherwise it will panic.\n///\n///\n/// Returns an array of arrays, where each inner array is a chunk containing\n/// elements from the original array. If the length of the original array is not\n/// divisible by the chunk size, the last chunk will contain fewer elements.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   let chunks = arr.chunks(2)\n///   inspect(chunks, content=\"[[1, 2], [3, 4], [5]]\")\n///\n///   let arr : Array[Int] = []\n///   inspect(arr.chunks(3), content=\"[]\")\n/// ```\npub fn[T] Array::chunks(self : Array[T], size : Int) -> Array[Array[T]] {\n  guard size > 0\n  let chunks = []\n  let mut i = 0\n  while i < self.length() {\n    let chunk = Array::new(capacity=size)\n    for j = 0; j < size && i < self.length(); j = j + 1 {\n      chunk.push(self[i])\n      i = i + 1\n    }\n    chunks.push(chunk)\n  }\n  chunks\n}\n\n///|\n/// Groups consecutive elements of the array into chunks where adjacent elements\n/// satisfy the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to be chunked.\n/// * `predicate` : A function that takes two adjacent elements and returns\n/// `true` if they should be in the same chunk, `false` otherwise.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that satisfy the predicate with their adjacent elements.\n///\n/// Example:\n///\n/// ```moonbit\n///   let v = [1, 1, 2, 3, 2, 3, 2, 3, 4]\n///   let chunks = v.chunk_by((x, y) => { x <= y })\n///   inspect(chunks, content=\"[[1, 1, 2, 3], [2, 3], [2, 3, 4]]\")\n///\n///   let v : Array[Int] = []\n///   inspect(v.chunk_by((x, y) => { x <= y }), content=\"[]\")\n/// ```\n#locals(pred)\npub fn[T] Array::chunk_by(\n  self : Array[T],\n  pred : (T, T) -> Bool raise?,\n) -> Array[Array[T]] raise? {\n  let chunks = []\n  let mut i = 0\n  while i < self.length() {\n    let chunk = []\n    chunk.push(self[i])\n    i = i + 1\n    while i < self.length() && pred(self[i - 1], self[i]) {\n      chunk.push(self[i])\n      i = i + 1\n    }\n    chunks.push(chunk)\n  }\n  chunks\n}\n\n///|\n/// Generates overlapping subslices (sliding windows) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be processed with sliding windows.\n/// * `size` : The window length. Must be a positive integer, otherwise it will panic.\n///\n/// Returns an array of slices, where each inner slice is a contiguous subslice\n/// of the original array. Windows are produced with a step size of 1. If the\n/// original array's length is less than the specified window size, the result\n/// will be an empty array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   let windows = arr.windows(2)\n///   inspect(windows, content=\"[[1, 2], [2, 3], [3, 4], [4, 5]]\")\n///\n///   let arr = [1, 2]\n///   inspect(arr.windows(3), content=\"[]\")\n/// ```\npub fn[T] Array::windows(self : Array[T], size : Int) -> Array[ArrayView[T]] {\n  guard size > 0\n  let len = self.length() - size + 1\n  if len < 1 {\n    return []\n  }\n  let windows = Array::new(capacity=len)\n  for i in 0..<len {\n    windows.push(self[i:i + size])\n  }\n  windows\n}\n\n///|\n/// Splits an array into chunks using a predicate function. Creates chunks by\n/// grouping consecutive elements that do not satisfy the predicate function.\n/// Elements that satisfy the predicate function are excluded from the resulting\n/// chunks and act as delimiters.\n///\n/// Parameters:\n///\n/// * `array` : The array to be split into chunks.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be used as a delimiter.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that do not satisfy the predicate.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 0, 2, 0, 3, 0, 4]\n///   inspect(arr.split((x) => { x == 0 }), content=\"[[1], [2], [3], [4]]\")\n///\n///   let arr = [0, 1, 0, 0, 2, 0]\n///   inspect(arr.split((x) => { x == 0 }), content=\"[[], [1], [], [2]]\")\n/// ```\n#locals(pred)\npub fn[T] Array::split(\n  self : Array[T],\n  pred : (T) -> Bool raise?,\n) -> Array[Array[T]] raise? {\n  let chunks = []\n  let mut i = 0\n  while i < self.length() {\n    let chunk = []\n    while i < self.length() && !pred(self[i]) {\n      chunk.push(self[i])\n      i = i + 1\n    }\n    chunks.push(chunk)\n    i = i + 1\n  }\n  chunks\n}\n\n///|\n/// Creates an iterator over the elements of the array.\n///\n/// Parameters:\n///\n/// * `array` : The array to create an iterator from.\n///\n/// Returns an iterator that yields each element of the array in order.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   let mut sum = 0\n///   arr.iter().each((x) => { sum = sum + x })\n///   inspect(sum, content=\"6\")\n/// ```\npub fn[T] Array::iter(self : Array[T]) -> Iter[T] {\n  Iter::new(yield_ => for v in self {\n    guard yield_(v) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  })\n}\n\n///|\n/// Returns an iterator that yields elements from the array in reverse order,\n/// from the last element to the first.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over in reverse order.\n///\n/// Returns an iterator that yields each element of the array, starting from the\n/// last element and moving towards the first.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   let result = []\n///   arr.rev_iter().each((x) => { result.push(x) })\n///   inspect(result, content=\"[3, 2, 1]\")\n/// ```\npub fn[T] Array::rev_iter(self : Array[T]) -> Iter[T] {\n  Iter::new(yield_ => for i = self.length() - 1; i >= 0; i = i - 1 {\n    guard yield_(self.unsafe_get(i)) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  })\n}\n\n///|\n/// Returns an iterator that provides both indices and values of the array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to iterate over.\n///\n/// Returns an iterator that yields tuples of index and value pairs, where\n/// indices start from 0.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [10, 20, 30]\n///   let mut sum = 0\n///   arr.iter2().each((i, x) => { sum = sum + i + x })\n///   inspect(sum, content=\"63\") // (0 + 10) + (1 + 20) + (2 + 30) = 63\n/// ```\npub fn[A] Array::iter2(self : Array[A]) -> Iter2[Int, A] {\n  Iter2::new(yield_ => for i, v in self {\n    guard yield_(i, v) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  })\n}\n\n///|\n/// Creates a new empty array.\n///\n/// Returns an empty array of type `Array[T]`.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr : Array[Int] = Array::default()\n///   inspect(arr.length(), content=\"0\")\n///   inspect(arr.is_empty(), content=\"true\")\n/// ```\npub impl[T] Default for Array[T] with default() {\n  []\n}\n\n///|\n/// Removes a back element from an array.\n///\n/// # Example\n/// ```mbt\n///   let array = [1, 2, 3, 4, 5]\n///   array.unsafe_pop_back()\n///   assert_eq(array.last(), Some(4))\n/// ```\n#internal(unsafe, \"Panic if the array is empty on non-JS backend.\")\npub fn[A] Array::unsafe_pop_back(self : Array[A]) -> Unit {\n  self.unsafe_pop() |> ignore\n}\n\n///|\n/// Truncates the array in-place to the specified length.\n///\n/// If `len` is greater than or equal to the current array length,\n/// the function does nothing. If `len` is 0, the array is cleared.\n/// Otherwise, removes elements from the end until the array reaches the given length.\n///\n/// Parameters:\n///\n/// * `self` : The target array (modified in-place).\n/// * `len` : The new desired length (must be non-negative).\n///\n/// Important:\n///   - If `len` is negative, the function does nothing.\n///   - If `len` exceeds current length, the array remains unchanged.\n///\n/// Example:\n///\n/// ```moonbit\n/// let arr = [1, 2, 3, 4, 5]\n/// arr.truncate(3)\n/// inspect(arr, content=\"[1, 2, 3]\")\n/// ```\npub fn[A] Array::truncate(self : Array[A], len : Int) -> Unit {\n  guard len >= 0 && len < self.length() else { return }\n  self.unsafe_truncate_to_length(len)\n}\n\n///|\n/// In-place filter and map for Array\n///\n/// # Example\n/// ```moonbit\n/// let arr = [1, 2, 3, 4, 5]\n/// arr.retain_map(fn(x) {\n///   if x % 2 == 0 {\n///     Some(x * 2)\n///   } else {\n///     None\n///   }\n/// })\n/// inspect(arr,content = \"[4, 8]\")\n/// ```\npub fn[A] Array::retain_map(self : Array[A], f : (A) -> A?) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let buf = self.buffer()\n  let len = self.length()\n  let mut write_idx = 0\n  for read_idx in 0..<len {\n    let val = buf[read_idx]\n    match f(val) {\n      Some(new_val) => {\n        buf[write_idx] = new_val\n        write_idx += 1\n      }\n      None => ()\n    }\n  }\n  self.unsafe_truncate_to_length(write_idx)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn[T] set_null(self : UninitializedArray[T], index : Int) = \"%fixedarray.set_null\"\n\n///|\n/// An `Array` is a collection of values that supports random access and can\n/// grow in size.\nstruct Array[T] {\n  mut buf : UninitializedArray[T]\n  mut len : Int\n}\n\n///|\nfn[T] Array::make_uninit(len : Int) -> Array[T] {\n  { buf: UninitializedArray::make(len), len }\n}\n\n///|\n/// Creates a new empty array with an optional initial capacity.\n///\n/// Parameters:\n///\n/// * `capacity` : The initial capacity of the array. If 0 (default), creates an\n/// array with minimum capacity. Must be non-negative.\n///\n/// Returns a new empty array of type `Array[T]` with the specified initial\n/// capacity.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr : Array[Int] = Array::new(capacity=10)\n///   inspect(arr.length(), content=\"0\")\n///   inspect(arr.capacity(), content=\"10\")\n///\n///   let arr : Array[Int] = Array::new()\n///   inspect(arr.length(), content=\"0\")\n/// ```\npub fn[T] Array::new(capacity~ : Int = 0) -> Array[T] {\n  if capacity == 0 {\n    []\n  } else {\n    { buf: UninitializedArray::make(capacity), len: 0 }\n  }\n}\n\n///|\n/// Returns the number of elements in the array.\n///\n/// Parameters:\n///\n/// * `array` : The array whose length is to be determined.\n///\n/// Returns the number of elements in the array as an integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   inspect(arr.length(), content=\"3\")\n///   let empty : Array[Int] = []\n///   inspect(empty.length(), content=\"0\")\n/// ```\n#intrinsic(\"%array.length\")\npub fn[T] Array::length(self : Array[T]) -> Int {\n  self.len\n}\n\n///|\n/// Truncates the array to the specified length. This function is marked as\n/// `unsafe` because it directly manipulates the internal buffer of the array,\n/// which can lead to undefined behavior if not used carefully.\n///\n/// # Parameters\n///\n/// - `self` : The array to be truncated.\n/// - `new_len` : The new length to which the array should be truncated. Must be\n/// less than or equal to the current length of the array.\n///\n/// # Returns\n///\n/// - `Unit` : This function does not return a value.\n///\n/// # Errors\n///\n/// - This function does not explicitly raise errors, but improper use (e.g.,\n/// setting `new_len` greater than the current length) can lead to undefined\n/// behavior.\n///\n/// TODO: this can be optimized by using the intrinsic to null out the range\nfn[T] Array::unsafe_truncate_to_length(self : Array[T], new_len : Int) -> Unit {\n  let len = self.length()\n  guard new_len <= len\n  for i in new_len..<len {\n    self.buf.set_null(i)\n  }\n  self.len = new_len\n}\n\n///|\ntest \"unsafe_truncate_to_length\" {\n  let arr = [1, 2, 3, 4, 5]\n  arr.unsafe_truncate_to_length(3)\n  inspect(arr, content=\"[1, 2, 3]\")\n}\n\n///|\nfn[T] Array::buffer(self : Array[T]) -> UninitializedArray[T] {\n  self.buf\n}\n\n///|\nfn[T] Array::resize_buffer(self : Array[T], new_capacity : Int) -> Unit {\n  let new_buf = UninitializedArray::make(new_capacity)\n  let old_buf = self.buf\n  let old_cap = old_buf.0.length()\n  let copy_len = if old_cap < new_capacity { old_cap } else { new_capacity }\n  UninitializedArray::unsafe_blit(new_buf, 0, old_buf, 0, copy_len)\n  self.buf = new_buf\n}\n\n///|\ntest \"array_unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\ntest \"UninitializedArray::unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\ntest \"UninitializedArray::unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\ntest \"Array::resize_buffer\" {\n  let arr = Array::new(capacity=2)\n  arr.push(1)\n  arr.push(2)\n  arr.resize_buffer(4)\n  assert_eq(arr.buffer().0.length() >= 4, true)\n  arr.push(3)\n  arr.push(4)\n  assert_eq(arr.length(), 4)\n  assert_eq(arr[0], 1)\n  assert_eq(arr[1], 2)\n  assert_eq(arr[2], 3)\n  assert_eq(arr[3], 4)\n}\n\n///|\n/// Reallocate the array with a new capacity.\nfn[T] Array::realloc(self : Array[T]) -> Unit {\n  let old_cap = self.length()\n  let new_cap = if old_cap == 0 { 8 } else { old_cap * 2 }\n  self.resize_buffer(new_cap)\n}\n\n///|\n/// Reserves capacity to ensure that it can hold at least the number of elements\n/// specified by the `capacity` argument.\n///\n/// # Example\n///\n/// ```mbt\n///   let v = [1]\n///   v.reserve_capacity(10)\n///   assert_eq(v.capacity(), 10)\n/// ```\npub fn[T] Array::reserve_capacity(self : Array[T], capacity : Int) -> Unit {\n  if self.capacity() >= capacity {\n    return\n  }\n  self.resize_buffer(capacity)\n}\n\n///|\n/// Shrinks the capacity of the array as much as possible.\n///\n/// # Example\n///\n/// ```mbt\n///   let v = Array::new(capacity=10)\n///   v.push(1)\n///   v.push(2)\n///   v.push(3)\n///   v.shrink_to_fit()\n///   assert_eq(v.capacity(), 3)\n/// ```\npub fn[T] Array::shrink_to_fit(self : Array[T]) -> Unit {\n  if self.capacity() <= self.length() {\n    return\n  }\n  self.resize_buffer(self.length())\n}\n\n///|\n/// Adds an element to the end of the array.\n///\n/// If the array is at capacity, it will be reallocated.\n///\n/// # Example\n/// ```mbt\n///   let v = []\n///   v.push(3)\n/// ```\npub fn[T] Array::push(self : Array[T], value : T) -> Unit {\n  if self.length() == self.buffer().0.length() {\n    self.realloc()\n  }\n  let length = self.length()\n  self.unsafe_set(length, value)\n  self.len = length + 1\n}\n\n///|\n/// Removes the last element from a array and returns it, or `None` if it is empty.\n///\n/// # Example\n/// ```mbt\n///   let v = [1, 2, 3]\n///   assert_eq(v.pop(), Some(3))\n///   assert_eq(v, [1, 2])\n/// ```\npub fn[T] Array::pop(self : Array[T]) -> T? {\n  let len = self.length()\n  if len == 0 {\n    None\n  } else {\n    let index = len - 1\n    let v = self.unsafe_get(index)\n    self.buf.set_null(index)\n    self.len = index\n    Some(v)\n  }\n}\n\n///|\n/// Removes and returns the last element from the array.\n///\n/// Parameters:\n///\n/// * `array` : The array from which to remove and return the last element.\n///\n/// Returns the last element of the array before removal.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   inspect(arr.unsafe_pop(), content=\"3\")\n///   inspect(arr, content=\"[1, 2]\")\n/// ```\n///\n#internal(unsafe, \"Panic if the array is empty.\")\npub fn[T] Array::unsafe_pop(self : Array[T]) -> T {\n  let len = self.length()\n  guard len != 0\n  let index = len - 1\n  let v = self.unsafe_get(index)\n  self.buf.set_null(index)\n  self.len = index\n  v\n}\n\n///|\n/// Removes and returns the element at position index within the array, \n/// shifting all elements after it to the left.\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   assert_eq(v.remove(1), 4)\n///   assert_eq(v, [3, 5])\n/// ```\npub fn[T] Array::remove(self : Array[T], index : Int) -> T {\n  guard index >= 0 && index < self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  let value = self.unsafe_get(index)\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    index,\n    self.buffer(),\n    index + 1,\n    self.length() - index - 1,\n  )\n  self.unsafe_truncate_to_length(self.length() - 1)\n  value\n}\n\n///|\n/// Removes the specified range from the array and returns it.\n///\n/// This functions returns a array range from `begin` to `end` `[begin, end)`\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let vv = v.drain(1, 2) // vv = [4], v = [3, 5]\n///   assert_eq(vv, [4])\n///   assert_eq(v, [3, 5])\n/// ```\npub fn[T] Array::drain(self : Array[T], begin : Int, end : Int) -> Array[T] {\n  guard begin >= 0 && end <= self.length() && begin <= end\n  let num = end - begin\n  let v = Array::make_uninit(num)\n  UninitializedArray::unsafe_blit(v.buffer(), 0, self.buffer(), begin, num)\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    begin,\n    self.buffer(),\n    end,\n    self.length() - end,\n  )\n  self.unsafe_truncate_to_length(self.length() - num)\n  v\n}\n\n///|\n/// Inserts an element at a given index within the array.\n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt\n///   [3, 4, 5].insert(1, 6)\n/// ```\npub fn[T] Array::insert(self : Array[T], index : Int, value : T) -> Unit {\n  guard index >= 0 && index <= self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  if self.length() == self.buffer().0.length() {\n    self.realloc()\n  }\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    index + 1,\n    self.buffer(),\n    index,\n    self.length() - index,\n  )\n  let length = self.length()\n  self.unsafe_set(index, value)\n  self.len = length + 1\n}\n\n///|\n/// Resize the array in-place so that `len` is equal to `new_len`.\n///\n/// If `new_len` is greater than `len`, the array will be extended by the\n/// difference, and the values in the new slots are left uninitialized.\n///  If `new_len` is less than `len`, it will panic\n///\nfn[T] Array::unsafe_grow_to_length(self : Array[T], new_len : Int) -> Unit {\n  guard new_len >= self.length()\n  let new_buf = UninitializedArray::make(new_len)\n  UninitializedArray::unsafe_blit(new_buf, 0, self.buf, 0, self.len)\n  self.len = new_len\n  self.buf = new_buf\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn println_mono(s : String) -> Unit = \"%println\"\n\n///|\nfn[T] any_to_string(any : T) -> String = \"%any.to_string\"\n\n///|\n/// Prints any value that implements the `Show` trait to the standard output,\n/// followed by a newline.\n///\n/// Parameters:\n///\n/// * `value` : The value to be printed. Must implement the `Show` trait.\n///\n/// Example:\n///\n/// ```moonbit skip\n///   println(42)\n///   println(\"Hello, World!\")\n///   println([1, 2, 3])\n/// ```\npub fn[T : Show] println(input : T) -> Unit {\n  println_mono(input.to_string())\n}\n\n///|\n/// Represents an error type used by the `inspect` function to indicate failures\n/// in value inspection. Contains a string message describing the nature of the\n/// inspection failure.\n///\n/// Returns a type constructor that creates an error type from a string message.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x : Int = 42\n///   inspect(x, content=\"42\") // Raises InspectError with detailed failure message\n/// ```\npub(all) suberror InspectError String\n\n///|\nfn base64_encode(data : FixedArray[Byte]) -> String {\n  let base64 = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n  let buf = StringBuilder::new()\n  let len = data.length()\n  let rem = len % 3\n  for i = 0; i < len - rem; i = i + 3 {\n    let b0 = data[i].to_int()\n    let b1 = data[i + 1].to_int()\n    let b2 = data[i + 2].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[((b0 & 0x03) << 4) | ((b1 & 0xF0) >> 4)]\n    let x2 = base64[((b1 & 0x0F) << 2) | ((b2 & 0xC0) >> 6)]\n    let x3 = base64[b2 & 0x3F]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char(x2.to_char())\n    buf.write_char(x3.to_char())\n  }\n  if rem == 1 {\n    let b0 = data[len - 1].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[(b0 & 0x03) << 4]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char('=')\n    buf.write_char('=')\n  } else if rem == 2 {\n    let b0 = data[len - 2].to_int()\n    let b1 = data[len - 1].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[((b0 & 0x03) << 4) | ((b1 & 0xF0) >> 4)]\n    let x2 = base64[(b1 & 0x0F) << 2]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char(x2.to_char())\n    buf.write_char('=')\n  }\n  buf.to_string()\n}\n\n///|\nfn base64_encode_string_codepoint(s : String) -> String {\n  // the input string is expected to be valid utf-16 string\n  let codepoint_length = s.char_length()\n  let data : FixedArray[Byte] = FixedArray::make(codepoint_length * 4, 0)\n  for i = 0, utf16_index = 0\n      i < codepoint_length\n      i = i + 1, utf16_index = utf16_index + 1 {\n    let c = s.unsafe_char_at(utf16_index).to_int()\n    if c > 0xFFFF {\n      data[i * 4] = (c & 0xFF).to_byte()\n      data[i * 4 + 1] = ((c >> 8) & 0xFF).to_byte()\n      data[i * 4 + 2] = ((c >> 16) & 0xFF).to_byte()\n      data[i * 4 + 3] = ((c >> 24) & 0xFF).to_byte()\n      continue i + 1, utf16_index + 2\n    } else {\n      data[i * 4] = (c & 0xFF).to_byte()\n      data[i * 4 + 1] = ((c >> 8) & 0xFF).to_byte()\n      data[i * 4 + 2] = 0\n      data[i * 4 + 3] = 0\n    }\n  }\n  base64_encode(data)\n}\n\n///|\ntest {\n  inspect(base64_encode_string_codepoint(\"\"))\n  inspect(base64_encode_string_codepoint(\"a\"), content=\"YQAAAA==\")\n  inspect(base64_encode_string_codepoint(\"ab\"), content=\"YQAAAGIAAAA=\")\n  inspect(base64_encode_string_codepoint(\"abc\"), content=\"YQAAAGIAAABjAAAA\")\n  inspect(\n    base64_encode_string_codepoint(\"abcd\"),\n    content=\"YQAAAGIAAABjAAAAZAAAAA==\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"abcde\"),\n    content=\"YQAAAGIAAABjAAAAZAAAAGUAAAA=\",\n  )\n  inspect(base64_encode_string_codepoint(\"a中\"), content=\"YQAAAC1OAAA=\")\n  inspect(\n    base64_encode_string_codepoint(\"a中🤣\"),\n    content=\"YQAAAC1OAAAj+QEA\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"a中🤣a\"),\n    content=\"YQAAAC1OAAAj+QEAYQAAAA==\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"a中🤣中\"),\n    content=\"YQAAAC1OAAAj+QEALU4AAA==\",\n  )\n}\n\n///|\n/// Tests if the string representation of an object matches the expected content.\n/// Used primarily in test cases to verify the correctness of `Show`\n/// implementations and program outputs.\n///\n/// Parameters:\n///\n/// * `object` : The object to be inspected. Must implement the `Show` trait.\n/// * `content` : The expected string representation of the object. Defaults to\n/// an empty string.\n/// * `location` : Source code location information for error reporting.\n/// Automatically provided by the compiler.\n/// * `arguments_location` : Location information for function arguments in\n/// source code. Automatically provided by the compiler.\n///\n/// Throws an `InspectError` if the actual string representation of the object\n/// does not match the expected content. The error message includes detailed\n/// information about the mismatch, including source location and both expected\n/// and actual values.\n///\n/// Example:\n///\n/// ```moonbit skip\n///   inspect(42, content=\"42\")\n///   inspect(\"hello\", content=\"hello\")\n///   inspect([1, 2, 3], content=\"[1, 2, 3]\")\n/// ```\n#callsite(autofill(args_loc, loc))\npub fn inspect(\n  obj : &Show,\n  content~ : String = \"\",\n  loc~ : SourceLoc,\n  args_loc~ : ArgsLoc,\n) -> Unit raise InspectError {\n  let actual = obj.to_string()\n  if actual != content {\n    let loc = loc.to_string().escape()\n    let args_loc = args_loc.to_json().escape()\n    let expect_escaped = content.escape()\n    let actual_escaped = actual.escape()\n    let expect_base64 = \"\\\"\\{base64_encode_string_codepoint(content)}\\\"\"\n    let actual_base64 = \"\\\"\\{base64_encode_string_codepoint(actual)}\\\"\"\n    raise InspectError(\n      \"@EXPECT_FAILED {\\\"loc\\\": \\{loc}, \\\"args_loc\\\": \\{args_loc}, \\\"expect\\\": \\{expect_escaped}, \\\"actual\\\": \\{actual_escaped}, \\\"expect_base64\\\": \\{expect_base64}, \\\"actual_base64\\\": \\{actual_base64}}\",\n    )\n  }\n}\n\n///|\n/// Represents an error that occurs during snapshot testing. Contains a string\n/// message describing the error.\n///\n/// Used internally by the test driver to handle snapshot-related errors. Not\n/// intended for direct use by end users.\n///\n/// Example:\n///\n/// ```moonbit\n///   let err : SnapshotError = SnapshotError(\"failed to load snapshot\")\n///   match err {\n///     SnapshotError(msg) => assert_eq(msg, \"failed to load snapshot\")\n///   }\n/// ```\npub(all) suberror SnapshotError String\n\n///|\npub(all) suberror BenchError String\n\n///|\ntest \"panic error case of inspect\" {\n  let x : Int = 42\n  inspect(x, content=\"100\")\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nconst GPRIME1 : UInt = 0x9E3779B1\n\n///|\nconst GPRIMES2 : UInt = 0x85EBCA77\n\n///|\nconst GPRIME3 : UInt = 0xC2B2AE3D\n\n///|\nconst GPRIME4 : UInt = 0x27D4EB2F\n\n///|\nconst GPRIME5 : UInt = 0x165667B1\n\n///|\n/// Represents a hasher that implements the xxHash32 algorithm. The hasher\n/// maintains a mutable accumulator that is updated with each value added to the\n/// hash computation.\n///\n/// This struct provides methods for combining different types of values into a\n/// single hash value, making it suitable for implementing hash functions for\n/// custom types.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_int(42)\n///   hasher.combine_string(\"hello\")\n///   inspect(hasher.finalize(), content=\"860601284\")\n/// ```\nstruct Hasher {\n  mut acc : UInt\n}\n\n///|\n/// Creates a new hasher with an optional seed value.\n///\n/// Parameters:\n///\n/// * `seed` : An integer value used to initialize the hasher's internal state.\n/// Defaults to 0.\n///\n/// Returns a new `Hasher` instance initialized with the given seed value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let h1 = Hasher::new() // Create a hasher with default seed\n///   let h2 = Hasher::new(seed=42) // Create a hasher with custom seed\n///   let x = 123\n///   h1.combine(x)\n///   h2.combine(x)\n///   inspect(h1.finalize() != h2.finalize(), content=\"true\") // Different seeds produce different hashes\n/// ```\npub fn Hasher::new(seed~ : Int = 0) -> Hasher {\n  { acc: seed.reinterpret_as_uint() + GPRIME5 }\n}\n\n///|\n/// Combines a hashable value with the current state of the hasher. This is\n/// typically used to incrementally build a hash value from multiple components.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The value to be combined with the current hash state. Must\n/// implement the `Hash` trait.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine(42)\n///   hasher.combine(\"hello\")\n///   inspect(hasher.finalize(), content=\"860601284\")\n/// ```\npub fn[T : Hash] Hasher::combine(self : Hasher, value : T) -> Unit {\n  value.hash_combine(self)\n}\n\n///|\n/// Combines the unit value (i.e., `()`) into the hasher's internal state by\n/// hashing it as an integer value of 0.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to combine the unit value into.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_unit()\n///   inspect(hasher.finalize(), content=\"148298089\")\n/// ```\npub fn Hasher::combine_unit(self : Hasher) -> Unit {\n  self.combine_uint(0)\n}\n\n///|\n/// Combines a boolean value into the current hash state. The boolean value is\n/// converted to an integer (1 for true, 0 for false) before being combined with\n/// the hash.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The boolean value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_bool(true)\n///   inspect(hasher.finalize(), content=\"-205818221\")\n/// ```\npub fn Hasher::combine_bool(self : Hasher, value : Bool) -> Unit {\n  self.combine_uint(if value { 1 } else { 0 })\n}\n\n///|\n/// Combines a 32-bit integer value into the hasher's internal state. The value\n/// is processed\n/// as a 4-byte sequence, and the internal accumulator is updated accordingly.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : A 32-bit integer value to be incorporated into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_int(42)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub fn Hasher::combine_int(self : Hasher, value : Int) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\n/// Combines a 64-bit integer value into the hash state by splitting it into two\n/// 32-bit parts and processing them separately. This method is used internally\n/// by the hash implementation to incorporate 64-bit integers into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object whose internal state will be updated.\n/// * `value` : The 64-bit integer value to be incorporated into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_int64(42L)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// ```\npub fn Hasher::combine_int64(self : Hasher, value : Int64) -> Unit {\n  self.acc += 8\n  self.consume4(value.reinterpret_as_uint64().to_uint())\n  self.consume4((value.reinterpret_as_uint64() >> 32).to_uint())\n}\n\n///|\n/// Combines an unsigned 32-bit integer into the hasher's internal state by\n/// reinterpreting it as a signed integer and incorporating it into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update.\n/// * `value` : The unsigned 32-bit integer value to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_uint(42U)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub fn Hasher::combine_uint(self : Hasher, value : UInt) -> Unit {\n  self.acc += 4\n  self.consume4(value)\n}\n\n///|\n/// Combines a 64-bit unsigned integer into the hasher's internal state. Useful\n/// for hashing `UInt64` values as part of a larger composite structure.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The 64-bit unsigned integer value to be incorporated into the\n/// hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_uint64(42UL)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// ```\npub fn Hasher::combine_uint64(self : Hasher, value : UInt64) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a double-precision floating-point number into the hasher's internal\n/// state by reinterpreting its bits as a 64-bit integer. Maintains consistent\n/// hashing behavior regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher to combine the value into.\n/// * `value` : The double-precision floating-point number to be combined into\n/// the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_double(3.14)\n///   inspect(hasher.finalize(), content=\"-428265677\")\n/// ```\npub fn Hasher::combine_double(self : Hasher, value : Double) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a 32-bit floating-point value into the hasher by reinterpreting its\n/// bit pattern as a 32-bit integer. The operation maintains the same hash result\n/// regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object that maintains the internal state of the\n/// hashing operation.\n/// * `value` : The 32-bit floating-point value to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_float(3.14)\n///   inspect(hasher.finalize(), content=\"635116317\") // Hash of the bits of 3.14\n/// ```\npub fn Hasher::combine_float(self : Hasher, value : Float) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\n/// Combines a byte value into the hash state.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte value.\n/// * `byte` : The byte value to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// ```\npub fn Hasher::combine_byte(self : Hasher, value : Byte) -> Unit {\n  self.consume1(value)\n}\n\n///|\n/// Combines a byte sequence into the hasher's internal state using xxHash32\n/// algorithm. Processes the input bytes in chunks of 4 bytes for efficiency,\n/// with remaining bytes processed individually.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte sequence.\n/// * `bytes` : The byte sequence to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_bytes(b\"\\xFF\\x00\\xFF\\x00\")\n///   inspect(hasher.finalize(), content=\"-686861102\")\n/// ```\npub fn Hasher::combine_bytes(self : Hasher, value : Bytes) -> Unit {\n  let mut remain = value.length()\n  let mut cur = 0\n  while remain >= 4 {\n    self.consume4(endian32(value, cur))\n    cur += 4\n    remain -= 4\n  }\n  while remain >= 1 {\n    self.consume1(value[cur])\n    cur += 1\n    remain -= 1\n  }\n}\n\n///|\n/// Combines a string value into the current hash state by processing each\n/// character in the string sequentially.\n///\n/// Parameters:\n///\n/// * `self` : The hasher object whose state will be updated.\n/// * `value` : The string value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_string(\"hello\")\n///   inspect(hasher.finalize(), content=\"-655549713\")\n/// ```\npub fn Hasher::combine_string(self : Hasher, value : String) -> Unit {\n  for i in 0..<value.length() {\n    self.combine_uint(value.unsafe_charcode_at(i).reinterpret_as_uint())\n  }\n}\n\n///|\n/// Combines a character value into the hasher's internal state. The character is\n/// first converted to its Unicode code point (as an integer) before being\n/// combined.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The character value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_char('A')\n///   inspect(hasher.finalize(), content=\"-1625495534\")\n/// ```\npub fn Hasher::combine_char(self : Hasher, value : Char) -> Unit {\n  self.combine_uint(value.to_uint())\n}\n\n///|\n/// Finalizes the hashing process and returns the computed hash value. Applies an\n/// avalanche function to improve the distribution of the hash value.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object containing the accumulated hash state.\n///\n/// Returns a 32-bit integer representing the final hash value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// ```\npub fn Hasher::finalize(self : Hasher) -> Int {\n  self.avalanche().reinterpret_as_int()\n}\n\n///|\nfn Hasher::avalanche(self : Hasher) -> UInt {\n  let mut acc = self.acc\n  acc = acc ^ (acc >> 15)\n  acc *= GPRIMES2\n  acc = acc ^ (acc >> 13)\n  acc *= GPRIME3\n  acc = acc ^ (acc >> 16)\n  acc\n}\n\n///|\nfn Hasher::consume4(self : Hasher, input : UInt) -> Unit {\n  self.acc = rotl(self.acc + input * GPRIME3, 17) * GPRIME4\n}\n\n///|\nfn Hasher::consume1(self : Hasher, input : Byte) -> Unit {\n  self.acc = rotl(self.acc + input.to_uint() * GPRIME5, 11) * GPRIME1\n}\n\n///|\nfn rotl(x : UInt, r : Int) -> UInt {\n  (x << r) | (x >> (32 - r))\n}\n\n///|\nfn endian32(input : Bytes, cur : Int) -> UInt {\n  input[cur + 0].to_uint() |\n  (\n    (input[cur + 1].to_uint() << 8) |\n    (input[cur + 2].to_uint() << 16) |\n    (input[cur + 3].to_uint() << 24)\n  )\n}\n\n///|\n/// Implements the `Hash` trait for `String` type, providing a method to combine\n/// a string's hash value with a hasher's state.\n///\n/// Parameters:\n///\n/// * `self` : The string value to be hashed.\n/// * `hasher` : The hasher object that will be updated with the string's hash\n/// value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let s1 = \"hello\"\n///   let s2 = \"hello\"\n///   let s3 = \"world\"\n///   inspect(Hash::hash(s1) == Hash::hash(s2), content=\"true\")\n///   inspect(Hash::hash(s1) == Hash::hash(s3), content=\"false\")\n/// ```\npub impl Hash for String with hash_combine(self, hasher) {\n  hasher.combine_string(self)\n}\n\n///|\n/// Implements the `Hash` trait for integer values using a combination of shifts\n/// and multiplications to produce a well-distributed hash value. Based on the\n/// hash algorithm from hash-prospector\n/// (https://github.com/skeeto/hash-prospector).\n///\n/// Parameters:\n///\n/// * `integer` : The integer value to be hashed. The value will be reinterpreted\n/// as an unsigned integer before hashing to ensure consistent behavior across\n/// positive and negative values.\n///\n/// Returns a 32-bit hash value derived from the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 42\n///   inspect(Hash::hash(x), content=\"-1704501356\")\n///   let y = -42\n///   inspect(Hash::hash(y), content=\"1617647962\")\n/// ```\n/// TODO: This implementation is **different** from the default implementation of the hash trait. \n/// So it will be replaced with the default implementation in the future **(breaking change)**, \n/// and users should not rely on this particular hash value\n/// ```moonbit \n///   let x = 42\n///   assert_not_eq(Hash::hash(x),Hasher::new()..combine(x).finalize())\n/// ```\npub impl Hash for Int with hash(self) {\n  let self = self.reinterpret_as_uint()\n  let mut x = self ^ (self >> 17)\n  x = x * 0xed5ad4bb\n  x = x ^ (x >> 11)\n  x = x * 0xac4c1b51\n  x = x ^ (x >> 15)\n  x = x * 0x31848bab\n  x = x ^ (x >> 14)\n  x.reinterpret_as_int()\n}\n\n///|\n/// Implements hash combination for integers by combining the integer value with\n/// a hasher. This implementation ensures that integers can be used as keys in\n/// hash-based collections like hash maps and hash sets.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be hashed.\n/// * `hasher` : A `Hasher` object that accumulates the hash value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_int(42)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub impl Hash for Int with hash_combine(self, hasher) {\n  hasher.combine_int(self)\n}\n\n///|\n/// Combines the hash value of an unsigned integer with a hasher object. This is\n/// useful when you need to hash a data structure that contains unsigned\n/// integers.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned integer to be combined with the hasher.\n/// * `hasher` : The hasher object that will incorporate the hash value of the\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_uint(42U)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub impl Hash for UInt with hash_combine(self, hasher) {\n  hasher.combine_uint(self)\n}\n\n///|\n/// Implements the `Hash` trait for `UInt64` by combining the hash value of an\n/// unsigned 64-bit integer into a hasher.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer value to be hashed.\n/// * `hasher` : The hasher object used to compute the combined hash value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_uint64(42UL)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// ```\npub impl Hash for UInt64 with hash_combine(self, hasher) {\n  hasher.combine_uint64(self)\n}\n\n///|\n/// Implements the `Hash` trait for `Option` types, allowing them to be used as\n/// keys in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Option` value to be hashed.\n/// * `hasher` : The hasher object that accumulates the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   let some_value : Int? = Some(42)\n///   let none_value : Int? = None\n///   hasher.combine(some_value)\n///   inspect(hasher.finalize(), content=\"2103260413\")\n///   let hasher2 = Hasher::new()\n///   hasher2.combine(none_value)\n///   inspect(hasher2.finalize(), content=\"148298089\")\n/// ```\npub impl[X : Hash] Hash for X? with hash_combine(self, hasher) {\n  match self {\n    None => hasher.combine_int(0)\n    Some(x) => hasher..combine_int(1)..combine(x)\n  }\n}\n\n///|\n/// Implements the `Hash` trait for `Result` type, allowing `Result` values to be\n/// used in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Result` value to be hashed.\n/// * `hasher` : The hasher object to which the hash value will be combined.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   let ok_result : Result[Int, String] = Ok(42)\n///   let err_result : Result[Int, String] = Err(\"error\")\n///   hasher.combine(ok_result)\n///   inspect(hasher.finalize(), content=\"-1948635851\")\n///   let hasher = Hasher::new()\n///   hasher.combine(err_result)\n///   inspect(hasher.finalize(), content=\"1953766574\")\n/// ```\npub impl[T : Hash, E : Hash] Hash for Result[T, E] with hash_combine(\n  self,\n  hasher,\n) {\n  match self {\n    Ok(x) => hasher..combine_int(0)..combine(x)\n    Err(x) => hasher..combine_int(1)..combine(x)\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n// Types\npriv struct Entry[K, V] {\n  mut prev : Int\n  mut next : Entry[K, V]?\n  mut psl : Int\n  hash : Int\n  key : K\n  mut value : V\n} derive(Show)\n\n///|\n/// Mutable linked hash map that maintains the order of insertion, not thread safe.\n///\n/// # Example\n///\n/// ```mbt\n///   let map = { 3: \"three\", 8 :  \"eight\", 1 :  \"one\"}\n///   assert_eq(map.get(2), None)\n///   assert_eq(map.get(3), Some(\"three\"))\n///   map.set(3, \"updated\")\n///   assert_eq(map.get(3), Some(\"updated\"))\n/// ```\nstruct Map[K, V] {\n  mut entries : FixedArray[Entry[K, V]?]\n  mut size : Int // active key-value pairs count\n  mut capacity : Int // current capacity\n  mut capacity_mask : Int // capacity_mask = capacity - 1, used to find idx\n  mut grow_at : Int // threshold that triggers grow\n  mut head : Entry[K, V]? // head of linked list\n  mut tail : Int // tail of linked list\n}\n\n// Implementations\n\n///|\n/// Create a hash map.\n/// The capacity of the map will be the smallest power of 2 that is\n/// greater than or equal to the provided [capacity].\npub fn[K, V] Map::new(capacity~ : Int = 8) -> Map[K, V] {\n  let capacity = capacity.next_power_of_two()\n  {\n    size: 0,\n    capacity,\n    capacity_mask: capacity - 1,\n    grow_at: calc_grow_threshold(capacity),\n    entries: FixedArray::make(capacity, None),\n    head: None,\n    tail: -1,\n  }\n}\n\n///|\n/// Create a hash map from array.\npub fn[K : Hash + Eq, V] Map::from_array(arr : Array[(K, V)]) -> Map[K, V] {\n  let m = Map::new(capacity=arr.length())\n  arr.each(e => m.set(e.0, e.1))\n  m\n}\n\n///|\n/// Set a key-value pair into the hash map.\npub fn[K : Hash + Eq, V] Map::set(self : Map[K, V], key : K, value : V) -> Unit {\n  if self.size >= self.grow_at {\n    self.grow()\n  }\n  let hash = key.hash()\n  let (idx, psl) = for psl = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      None => break (idx, psl)\n      Some(curr_entry) => {\n        if curr_entry.hash == hash && curr_entry.key == key {\n          curr_entry.value = value\n          return\n        }\n        if psl > curr_entry.psl {\n          self.push_away(idx, curr_entry)\n          break (idx, psl)\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n    }\n  }\n  let entry = { prev: self.tail, next: None, psl, key, value, hash }\n  self.add_entry_to_tail(idx, entry)\n}\n\n///|\nfn[K, V] Map::push_away(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  for psl = entry.psl + 1, idx = (idx + 1) & self.capacity_mask, entry = entry {\n    match self.entries[idx] {\n      None => {\n        entry.psl = psl\n        self.set_entry(entry, idx)\n        break\n      }\n      Some(curr_entry) =>\n        if psl > curr_entry.psl {\n          entry.psl = psl\n          self.set_entry(entry, idx)\n          continue curr_entry.psl + 1,\n            (idx + 1) & self.capacity_mask,\n            curr_entry\n        } else {\n          continue psl + 1, (idx + 1) & self.capacity_mask, entry\n        }\n    }\n  }\n}\n\n///|\nfn[K, V] Map::set_entry(\n  self : Map[K, V],\n  entry : Entry[K, V],\n  new_idx : Int,\n) -> Unit {\n  self.entries[new_idx] = Some(entry)\n  match entry.next {\n    None => self.tail = new_idx\n    Some(next) => next.prev = new_idx\n  }\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::op_set(\n  self : Map[K, V],\n  key : K,\n  value : V,\n) -> Unit {\n  self.set(key, value)\n}\n\n///|\n/// Get the value associated with a key.\npub fn[K : Hash + Eq, V] Map::get(self : Map[K, V], key : K) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && entry.key == key {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n#deprecated(\"Use `get` instead. `op_get` will return `V` instead of `Option[V]` in the future.\")\npub fn[K : Hash + Eq, V] Map::op_get(self : Map[K, V], key : K) -> V? {\n  self.get(key)\n}\n\n///|\n/// Returns the value associated with the key in the map, or computes and returns\n/// a default value if the key does not exist.\n///\n/// Parameters:\n///\n/// * `map` : The map to search in.\n/// * `key` : The key to look up in the map.\n/// * `default` : A function that returns a default value when the key is not\n/// found.\n///\n/// Returns either the value associated with the key if it exists, or the result\n/// of calling the default function.\n///\n/// Example:\n///\n/// ```moonbit\n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect(map.get_or_default(\"a\", 0), content=\"1\")\n///   inspect(map.get_or_default(\"c\", 42), content=\"42\")\n/// ```\npub fn[K : Hash + Eq, V] Map::get_or_default(\n  self : Map[K, V],\n  key : K,\n  default : V,\n) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          break entry.value\n        }\n        if i > entry.psl {\n          break default\n        }\n        continue i + 1, (idx + 1) & self.capacity_mask\n      }\n      None => break default\n    }\n  }\n}\n\n///|\n/// Returns the value for the given key, or sets and returns a default value if the key does not exist.\npub fn[K : Hash + Eq, V] Map::get_or_init(\n  self : Map[K, V],\n  key : K,\n  default : () -> V,\n) -> V {\n  match self.get(key) {\n    Some(v) => v\n    None => {\n      let v = default()\n      self.set(key, v)\n      v\n    }\n  }\n}\n\n///|\n/// Check if the hash map contains a key.\npub fn[K : Hash + Eq, V] Map::contains(self : Map[K, V], key : K) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Checks if a map contains a specific key-value pair.\n///\n/// Parameters:\n///\n/// * `map` : A map of type `Map[K, V]` to search in.\n/// * `key` : The key to look up in the map.\n/// * `value` : The value to be compared with the value associated with the key.\n///\n/// Returns `true` if the map contains the specified key and its associated value\n/// equals the given value, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// \n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect(map.contains_kv(\"a\", 1), content=\"true\")\n///   inspect(map.contains_kv(\"a\", 2), content=\"false\")\n///   inspect(map.contains_kv(\"c\", 3), content=\"false\")\n/// ```\npub fn[K : Hash + Eq, V : Eq] Map::contains_kv(\n  self : Map[K, V],\n  key : K,\n  value : V,\n) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key && entry.value == value {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Remove a key-value pair from hash map.\npub fn[K : Hash + Eq, V] Map::remove(self : Map[K, V], key : K) -> Unit {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break }\n    if entry.hash == hash && entry.key == key {\n      self.remove_entry(entry)\n      self.shift_back(idx)\n      self.size -= 1\n      break\n    }\n    if i > entry.psl {\n      break\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\nfn[K, V] Map::add_entry_to_tail(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  match self.tail {\n    -1 => self.head = Some(entry)\n    tail => self.entries[tail].unwrap().next = Some(entry)\n  }\n  self.tail = idx\n  self.entries[idx] = Some(entry)\n  self.size += 1\n}\n\n///|\nfn[K, V] Map::remove_entry(self : Map[K, V], entry : Entry[K, V]) -> Unit {\n  match entry.prev {\n    -1 => self.head = entry.next\n    idx => self.entries[idx].unwrap().next = entry.next\n  }\n  match entry.next {\n    None => self.tail = entry.prev\n    Some(next) => next.prev = entry.prev\n  }\n}\n\n///|\nfn[K, V] Map::shift_back(self : Map[K, V], idx : Int) -> Unit {\n  let next = (idx + 1) & self.capacity_mask\n  match self.entries[next] {\n    None | Some({ psl: 0, .. }) => self.entries[idx] = None\n    Some(entry) => {\n      entry.psl -= 1\n      self.set_entry(entry, idx)\n      self.shift_back(next)\n    }\n  }\n}\n\n///|\nfn[K : Hash + Eq, V] Map::grow(self : Map[K, V]) -> Unit {\n  let old_head = self.head\n  let new_capacity = self.capacity << 1\n  self.entries = FixedArray::make(new_capacity, None)\n  self.capacity = new_capacity\n  self.capacity_mask = new_capacity - 1\n  self.grow_at = calc_grow_threshold(self.capacity)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n  loop old_head {\n    Some({ next, key, value, .. }) => {\n      self.set(key, value)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\nfn calc_grow_threshold(capacity : Int) -> Int {\n  capacity * 13 / 16\n}\n\n// Utils\n\n///|\npub impl[K : Show, V : Show] Show for Map[K, V] with output(self, logger) {\n  logger.write_string(\"{\")\n  loop (0, self.head) {\n    (_, None) => logger.write_string(\"}\")\n    (i, Some({ key, value, next, .. })) => {\n      if i > 0 {\n        logger.write_string(\", \")\n      }\n      logger..write_object(key)..write_string(\": \")..write_object(value)\n      continue (i + 1, next)\n    }\n  }\n}\n\n///|\n/// Get the number of key-value pairs in the map.\npub fn[K, V] Map::size(self : Map[K, V]) -> Int {\n  self.size\n}\n\n///|\n/// Get the capacity of the map.\npub fn[K, V] Map::capacity(self : Map[K, V]) -> Int {\n  self.capacity\n}\n\n///|\n/// Check if the hash map is empty.\npub fn[K, V] Map::is_empty(self : Map[K, V]) -> Bool {\n  self.size == 0\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion.\n#locals(f)\npub fn[K, V] Map::each(\n  self : Map[K, V],\n  f : (K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      f(key, value)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion, with index.\n#locals(f)\npub fn[K, V] Map::eachi(\n  self : Map[K, V],\n  f : (Int, K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop (0, self.head) {\n    (i, Some({ key, value, next, .. })) => {\n      f(i, key, value)\n      continue (i + 1, next)\n    }\n    (_, None) => break\n  }\n}\n\n///|\n/// Clears the map, removing all key-value pairs. Keeps the allocated space.\npub fn[K, V] Map::clear(self : Map[K, V]) -> Unit {\n  self.entries.fill(None)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n}\n\n///|\n/// Returns the iterator of the hash map, provide elements in the order of insertion.\npub fn[K, V] Map::iter(self : Map[K, V]) -> Iter[(K, V)] {\n  Iter::new(yield_ => loop self.head {\n    Some({ key, value, next, .. }) => {\n      guard yield_((key, value)) is IterContinue else { break IterEnd }\n      continue next\n    }\n    None => break IterContinue\n  })\n}\n\n///|\npub fn[K, V] Map::iter2(self : Map[K, V]) -> Iter2[K, V] {\n  Iter2::new(yield_ => loop self.head {\n    Some({ key, value, next, .. }) => {\n      guard yield_(key, value) is IterContinue else { break IterEnd }\n      continue next\n    }\n    None => IterContinue\n  })\n}\n\n///|\npub fn[K, V] Map::keys(self : Map[K, V]) -> Iter[K] {\n  Iter::new(yield_ => loop self.head {\n    Some({ key, next, .. }) => {\n      guard yield_(key) is IterContinue else { break IterEnd }\n      continue next\n    }\n    None => IterContinue\n  })\n}\n\n///|\npub fn[K, V] Map::values(self : Map[K, V]) -> Iter[V] {\n  Iter::new(yield_ => loop self.head {\n    Some({ value, next, .. }) => {\n      guard yield_(value) is IterContinue else { break IterEnd }\n      continue next\n    }\n    None => IterContinue\n  })\n}\n\n///|\n/// Converts the hash map to an array.\npub fn[K, V] Map::to_array(self : Map[K, V]) -> Array[(K, V)] {\n  let arr = Array::make_uninit(self.size)\n  let mut i = 0\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      arr.unsafe_set(i, (key, value))\n      i += 1\n      continue next\n    }\n    None => break\n  }\n  arr\n}\n\n///|\npub impl[K : Hash + Eq, V : Eq] Eq for Map[K, V] with op_equal(\n  self : Map[K, V],\n  that : Map[K, V],\n) -> Bool {\n  guard self.size == that.size else { return false }\n  for k, v in self {\n    guard that.contains_kv(k, v) else { return false }\n  } else {\n    true\n  }\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::of(arr : FixedArray[(K, V)]) -> Map[K, V] {\n  let length = arr.length()\n  let m = Map::new(capacity=length)\n  // arr.iter((e) => { m.set(e.0, e.1) })\n  for i in 0..<length {\n    let e = arr[i]\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::from_iter(iter : Iter[(K, V)]) -> Map[K, V] {\n  let m = {}\n  for e in iter {\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\npub impl[K, V] Default for Map[K, V] with default() {\n  Map::new()\n}\n\n///|\n/// Applies a function to each key-value pair in the map and returns a new map with the results, using the original keys.\npub fn[K, V, V2] Map::map(self : Map[K, V], f : (K, V) -> V2) -> Map[K, V2] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_value = f(key, value)\n      let new_entry = { prev, next, psl, hash, key, value: new_value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Copy the map, creating a new map with the same key-value pairs and order of insertion.\npub fn[K, V] Map::copy(self : Map[K, V]) -> Map[K, V] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_entry = { prev, next, psl, hash, key, value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Updates a value in the map based on the existing value.\n///\n/// This method allows you to conditionally update, insert, or remove a key-value pair\n/// based on whether the key already exists in the map. The provided function `f` is\n/// called with `Some(current_value)` if the key exists, or `None` if it doesn't.\n///\n/// Parameters:\n///\n/// * `self` : The map to update.\n/// * `key` : The key to update.\n/// * `f` : A function that takes the current value (wrapped in `Option`) and returns\n///   the new value (wrapped in `Option`). Returning `None` will remove the key-value\n///   pair from the map.\n///\n/// Behavior:\n///\n/// * If the key exists and `f` returns `Some(new_value)`, the value is updated.\n/// * If the key exists and `f` returns `None`, the key-value pair is removed.\n/// * If the key doesn't exist and `f` returns `Some(new_value)`, a new pair is inserted.\n/// * If the key doesn't exist and `f` returns `None`, no operation is performed.\n///\n/// Example:\n///\n/// ```moonbit\n/// let map = { \"a\": 1, \"b\": 2 }\n///\n/// // Update existing value\n/// map.update(\"a\", fn(v) { \n///   match v { \n///     Some(x) => Some(x + 10) \n///     None => Some(0) \n///   } \n/// })\n/// inspect(map, content=(\n///   #|{\"a\": 11, \"b\": 2}\n/// ))\n///\n/// // Insert new value\n/// map.update(\"c\", fn(v) { \n///   match v { \n///     Some(x) => Some(x) \n///     None => Some(3) \n///   } \n/// })\n/// inspect(map, content=(\n///   #|{\"a\": 11, \"b\": 2, \"c\": 3}\n/// ))\n///\n/// // Remove existing value\n/// map.update(\"b\", fn(_) { None })\n/// inspect(map, content=(\n///   #|{\"a\": 11, \"c\": 3}\n/// ))\n/// ```\npub fn[K : Hash + Eq, V] Map::update(\n  self : Map[K, V],\n  key : K,\n  f : (V?) -> V?,\n) -> Unit {\n  let hash = key.hash()\n  let (idx, psl, new_value) = for psl = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          // Found the entry, update its value\n          if f(Some(entry.value)) is Some(new_value) {\n            entry.value = new_value\n          } else {\n            // Remove the entry since the new value is None\n            self.remove_entry(entry)\n            self.shift_back(idx)\n            self.size -= 1\n          }\n          return\n        }\n        if psl > entry.psl {\n          guard f(None) is Some(new_value) else { return }\n          self.push_away(idx, entry)\n          break (idx, psl, new_value)\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        guard f(None) is Some(new_value) else { return }\n        break (idx, psl, new_value)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set(key, new_value)\n  } else {\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl Show for Unit with output(_self, logger) {\n  logger.write_string(\"()\")\n}\n\n///|\npub impl Show for Bool with output(self, logger) {\n  if self {\n    logger.write_string(\"true\")\n  } else {\n    logger.write_string(\"false\")\n  }\n}\n\n///|\npub impl Show for Int with output(self, logger) {\n  self.output(logger)\n}\n\n///|\npub impl Show for Int64 with output(self, logger) {\n  self.output(logger)\n}\n\n///|\npub impl Show for UInt with output(self, logger) {\n  self.output(logger)\n}\n\n///|\npub impl Show for UInt64 with output(self, logger) {\n  self.output(logger)\n}\n\n///|\npub impl Show for Byte with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for Int16 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt16 with output(self, logger) {\n  self.to_int().output(logger)\n}\n\n///|\nfn to_hex_digit(i : Int) -> Char {\n  if i < 10 {\n    (i + '0').unsafe_to_char()\n  } else {\n    (i + 'a' - 10).unsafe_to_char()\n  }\n}\n\n///|\ntest \"to_hex_digit\" {\n  for i in 0..<10 {\n    guard to_hex_digit(i) == ('0'.to_int() + i).unsafe_to_char() else {\n      fail(\"to_hex_digit(\\{i}) does not match\")\n    }\n  }\n  for i in 10..<16 {\n    guard to_hex_digit(i) == ('a'.to_int() + (i - 10)).unsafe_to_char() else {\n      fail(\"to_hex_digit(\\{i}) does not match\")\n    }\n  }\n}\n\n///|\npub impl Show for Bytes with output(self, logger) {\n  logger.write_string(\"b\\\"\")\n  for b in self {\n    let byte = b.to_int()\n    logger\n    ..write_string(\"\\\\x\")\n    ..write_char(to_hex_digit(byte / 16))\n    ..write_char(to_hex_digit(byte % 16))\n  }\n  logger.write_string(\"\\\"\")\n}\n\n///|\npub impl Show for String with output(self, logger) {\n  logger.write_char('\"')\n  fn flush_segment(seg : Int, i : Int) {\n    if i > seg {\n      logger.write_substring(self, seg, i - seg)\n    }\n  }\n  // The loop keeps two pieces of state:\n  //   i   : the current scanning position\n  //   seg : the beginning index of the current \"plain\" segment that has\n  //         no escaping requirements. Whenever we meet a character that\n  //         needs escaping, we flush the segment [seg, i) and reset seg.\n  let len = self.length()\n  for i = 0, seg = 0 {\n    if i >= len {\n      // If we reached the end of the string, flush any remaining segment\n      // and break out of the loop.\n      flush_segment(seg, i)\n      break\n    }\n    let code = self.unsafe_charcode_at(i)\n    match code {\n      '\"' | '\\\\' as c => {\n        flush_segment(seg, i)\n        logger..write_char('\\\\')..write_char(c.unsafe_to_char())\n        // Advance both pointers: continue with next index, new segment starts after current char\n        continue i + 1, i + 1\n      }\n      '\\n' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\n\")\n        continue i + 1, i + 1\n      }\n      '\\r' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\r\")\n        continue i + 1, i + 1\n      }\n      '\\b' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\b\")\n        continue i + 1, i + 1\n      }\n      '\\t' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\t\")\n        continue i + 1, i + 1\n      }\n      code =>\n        if code < ' ' {\n          flush_segment(seg, i)\n          logger\n          ..write_string(\"\\\\u{\")\n          ..write_char(to_hex_digit(code / 16))\n          ..write_char(to_hex_digit(code % 16))\n          ..write_char('}')\n          continue i + 1, i + 1\n        } else {\n          // Normal character, keep scanning; only advance index.\n          continue i + 1, seg\n        }\n    }\n  }\n  logger.write_char('\"')\n}\n\n///|\n/// This is different from `Show::output`,\n/// here it returns the original string without escaping. \n/// The rationale is in string interpolation,\n/// we want to show the original string, not the escaped one.\n/// # Examples\n/// \n/// ```mbt\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// ```\npub impl Show for String with to_string(self) {\n  self\n}\n\n///|\n/// Returns a valid MoonBit string literal representation of a string,\n/// add quotes and escape special characters.\n/// # Examples\n/// \n/// ```mbt\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// ```\npub fn String::escape(self : String) -> String {\n  let buf = StringBuilder::new()\n  Show::output(self, buf)\n  buf.to_string()\n}\n\n///|\npub impl[X : Show] Show for X? with output(self, logger) {\n  match self {\n    None => logger.write_string(\"None\")\n    Some(arg) =>\n      logger..write_string(\"Some(\")..write_object(arg)..write_string(\")\")\n  }\n}\n\n///|\npub impl[T : Show, E : Show] Show for Result[T, E] with output(self, logger) {\n  match self {\n    Ok(x) => logger..write_string(\"Ok(\")..write_object(x)..write_string(\")\")\n    Err(e) => logger..write_string(\"Err(\")..write_object(e)..write_string(\")\")\n  }\n}\n\n///|\npub impl[X : Show] Show for Ref[X] with output(self, logger) {\n  logger..write_string(\"{val: \")..write_object(self.val)..write_string(\"}\")\n}\n\n///|\npub impl[X : Show] Show for FixedArray[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n\n///|\npub impl[X : Show] Show for Array[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct StringBuilder {\n  mut data : FixedArray[Byte]\n  mut len : Int\n}\n\n///|\n/// Creates a new string builder with an optional initial capacity hint.\n///\n/// Parameters:\n///\n/// * `size_hint` : An optional initial capacity hint for the internal buffer. If\n/// less than 1, a minimum capacity of 1 is used. Defaults to 0. It is the size of bytes, \n/// not the size of characters. `size_hint` may be ignored on some platforms, JS for example.\n///\n/// Returns a new `StringBuilder` instance with the specified initial capacity.\n///\npub fn StringBuilder::new(size_hint~ : Int = 0) -> StringBuilder {\n  let initial = if size_hint < 1 { 1 } else { size_hint }\n  let data : FixedArray[Byte] = FixedArray::make(initial, 0)\n  { data, len: 0 }\n}\n\n///|\n/// Return whether the given buffer is empty.\npub fn StringBuilder::is_empty(self : StringBuilder) -> Bool {\n  self.len == 0\n}\n\n///|\nfn StringBuilder::grow_if_necessary(\n  self : StringBuilder,\n  required : Int,\n) -> Unit {\n  let current_len = self.data.length()\n  if required <= current_len {\n    return\n  }\n  // current_len is at least 1\n  let mut enough_space = current_len\n  // double the enough_space until it larger than required\n  while enough_space < required {\n    enough_space = enough_space * 2\n  }\n  let new_data = FixedArray::make(enough_space, Byte::default())\n  new_data.unsafe_blit(0, self.data, 0, self.len)\n  self.data = new_data\n}\n\n///|\n/// Writes a string to the StringBuilder.\npub impl Logger for StringBuilder with write_string(self, str) {\n  self.grow_if_necessary(self.len + str.length() * 2)\n  self.data.blit_from_string(self.len, str, 0, str.length())\n  self.len += str.length() * 2\n}\n\n///|\n/// Writes a character to the StringBuilder.\npub impl Logger for StringBuilder with write_char(self, ch) {\n  self.grow_if_necessary(self.len + 4)\n  let inc = self.data.set_utf16le_char(self.len, ch)\n  self.len += inc\n}\n\n///|\n/// Writes a part of the given string to the StringBuilder.\n/// \n/// Parameters:\n///\n/// * `self` : The StringBuilder to write to.\n/// * `str` : The given string.\n/// * `start` : The start index of the substring to write.\n/// * `len` : The length of the substring to write.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sb = StringBuilder::new()\n///   sb.write_substring(\"Hello, world!\", 0, 5)\n///   assert_eq(sb.to_string(), \"Hello\")\n/// ```\npub impl Logger for StringBuilder with write_substring(\n  self : StringBuilder,\n  str : String,\n  start : Int,\n  len : Int,\n) -> Unit {\n  guard start >= 0 && len >= 0 && start + len <= str.length()\n  self.grow_if_necessary(self.len + len * 2)\n  self.data.blit_from_string(self.len, str, start, len)\n  self.len += len * 2\n}\n\n///| \n/// Returns the current content of the StringBuilder as a string.\npub fn StringBuilder::to_string(self : StringBuilder) -> String {\n  self.data\n  .unsafe_reinterpret_as_bytes()\n  .to_unchecked_string(offset=0, length=self.len)\n}\n\n///|\n/// TODO: improve perf\npub impl Show for StringBuilder with output(self, logger) {\n  logger.write_string(\n    self.data\n    .unsafe_reinterpret_as_bytes()\n    .to_unchecked_string(offset=0, length=self.len),\n  )\n}\n\n///| \n/// Resets the string builder to an empty state.\npub fn StringBuilder::reset(self : StringBuilder) -> Unit {\n  self.len = 0\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nconst ALPHABET : String = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\n///|\npub fn Int64::to_string(self : Int64, radix~ : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=Int64::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for Int64 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn Int::to_string(self : Int, radix~ : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=Int::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for Int with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn UInt::to_string(self : UInt, radix~ : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=UInt::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for UInt with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\ntest \"UInt::to_string\" {\n  inspect(0U, content=\"0\")\n  inspect(17U, content=\"17\")\n  inspect(4294967295U, content=\"4294967295\")\n}\n\n///|\npub fn UInt64::to_string(self : UInt64, radix~ : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=UInt64::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for UInt64 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn Int16::to_string(self : Int16, radix~ : Int = 10) -> String {\n  self.to_int().to_string(radix~)\n}\n\n///|\npub impl Show for Int16 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn UInt16::to_string(self : UInt16, radix~ : Int = 10) -> String {\n  self.to_int().to_string(radix~)\n}\n\n///|\npub impl Show for UInt16 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\ntest \"to_string\" {\n  assert_eq((0x100).to_string(), \"256\")\n  assert_eq(\"\\{0x100}\", \"256\")\n  assert_eq(0x200U.to_string(), \"512\")\n  assert_eq(\"\\{0x200U}\", \"512\")\n  assert_eq(0x300L.to_string(), \"768\")\n  assert_eq(\"\\{0x300L}\", \"768\")\n  assert_eq(0x400UL.to_string(), \"1024\")\n  assert_eq(\"\\{0x400UL}\", \"1024\")\n}\n\n///|\ntest \"to_string with radix\" {\n  // Binary\n  inspect((0).to_string(radix=2), content=\"0\")\n  inspect((1).to_string(radix=2), content=\"1\")\n  inspect((2).to_string(radix=2), content=\"10\")\n  inspect((255).to_string(radix=2), content=\"11111111\")\n  inspect((-255).to_string(radix=2), content=\"-11111111\")\n\n  // Octal\n  inspect((0).to_string(radix=8), content=\"0\")\n  inspect((8).to_string(radix=8), content=\"10\")\n  inspect((64).to_string(radix=8), content=\"100\")\n  inspect((-64).to_string(radix=8), content=\"-100\")\n\n  // Decimal\n  inspect((0).to_string(radix=10), content=\"0\")\n  inspect((123).to_string(radix=10), content=\"123\")\n  inspect((-123).to_string(radix=10), content=\"-123\")\n  inspect(\n    0x7fff_ffff_ffff_ffffL.to_string(radix=10),\n    content=\"9223372036854775807\",\n  )\n  inspect(\n    0x8000_0000_0000_0000L.to_string(radix=10),\n    content=\"-9223372036854775808\",\n  )\n\n  // Hexadecimal\n  inspect((0).to_string(radix=16), content=\"0\")\n  inspect((0x11).to_string(radix=16), content=\"11\")\n  inspect((0x15ef).to_string(radix=16), content=\"15ef\")\n  inspect((-0xabcd).to_string(radix=16), content=\"-abcd\")\n  inspect(\n    (1.0 : Float).reinterpret_as_int().to_string(radix=16),\n    content=\"3f800000\",\n  )\n\n  // UInt\n  inspect(0U.to_string(radix=16), content=\"0\")\n  inspect(0x1AU.to_string(radix=16), content=\"1a\")\n  inspect(0xabcdU.to_string(radix=16), content=\"abcd\")\n  inspect(\n    (-2.0 : Float).reinterpret_as_uint().to_string(radix=16),\n    content=\"c0000000\",\n  )\n  inspect((-1).reinterpret_as_uint().to_string(radix=16), content=\"ffffffff\")\n\n  // Int64\n  inspect(0L.to_string(radix=16), content=\"0\")\n  inspect(0x2fL.to_string(radix=16), content=\"2f\")\n  inspect(0xf0aeL.to_string(radix=16), content=\"f0ae\")\n  inspect((-0x1234eacbL).to_string(radix=16), content=\"-1234eacb\")\n  inspect(\n    1.0.reinterpret_as_uint64().to_string(radix=16),\n    content=\"3ff0000000000000\",\n  )\n  inspect(0b101L.to_string(radix=2), content=\"101\")\n  inspect(0o17L.to_string(radix=8), content=\"17\")\n\n  // UInt64\n  inspect(0UL.to_string(radix=16), content=\"0\")\n  inspect(0x11UL.to_string(radix=16), content=\"11\")\n  inspect(0x12bdUL.to_string(radix=16), content=\"12bd\")\n  inspect(\n    (-1L).reinterpret_as_uint64().to_string(radix=16),\n    content=\"ffffffffffffffff\",\n  )\n  inspect(\n    2.0.reinterpret_as_uint64().to_string(radix=16),\n    content=\"4000000000000000\",\n  )\n}\n\n///|\ntest \"panic to_string_by_radix/illegal_radix\" {\n  ignore((1).to_string(radix=1))\n  ignore((1).to_string(radix=37))\n  ignore(1L.to_string(radix=0))\n  ignore(1L.to_string(radix=42))\n  ignore(1U.to_string(radix=-1))\n  ignore(1U.to_string(radix=73))\n  ignore(1UL.to_string(radix=-100))\n  ignore(1UL.to_string(radix=100))\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn Int64::output(self : Int64, logger : &Logger, radix~ : Int = 10) -> Unit {\n  fn abs(n : Int64) -> Int64 {\n    if n < 0L {\n      0L - n\n    } else {\n      n\n    }\n  }\n\n  if self < 0L {\n    logger.write_char('-')\n  }\n  let radix : Int64 = radix.to_int64()\n  fn write_digits(num : Int64) {\n    let num2 = num / radix\n    if num2 != 0L {\n      write_digits(num2)\n    }\n    logger.write_char(\n      ALPHABET.charcode_at(abs(num % radix).to_int()).unsafe_to_char(),\n    )\n  }\n\n  write_digits(abs(self))\n}\n\n///|\nfn Int::output(self : Int, logger : &Logger, radix~ : Int = 10) -> Unit {\n  fn abs(n : Int) -> Int {\n    if n < 0 {\n      0 - n\n    } else {\n      n\n    }\n  }\n\n  if self < 0 {\n    logger.write_char('-')\n  }\n  fn write_digits(num : Int) {\n    let num2 = num / radix\n    if num2 != 0 {\n      write_digits(num2)\n    }\n    logger.write_char(ALPHABET.charcode_at(abs(num % radix)).unsafe_to_char())\n  }\n\n  write_digits(abs(self))\n}\n\n///|\nfn UInt::output(self : UInt, logger : &Logger, radix~ : Int = 10) -> Unit {\n  let radix : UInt = radix.reinterpret_as_uint()\n  fn write_digits(num : UInt) {\n    let num2 = num / radix\n    if num2 != 0U {\n      write_digits(num2)\n    }\n    logger.write_char(\n      ALPHABET.charcode_at((num % radix).reinterpret_as_int()).unsafe_to_char(),\n    )\n  }\n\n  write_digits(self)\n}\n\n///|\nfn UInt64::output(self : UInt64, logger : &Logger, radix~ : Int = 10) -> Unit {\n  let radix : UInt64 = radix.to_uint64()\n  fn write_digits(num : UInt64) {\n    let num2 = num / radix\n    if num2 != 0UL {\n      write_digits(num2)\n    }\n    logger.write_char(\n      ALPHABET.charcode_at((num % radix).to_int()).unsafe_to_char(),\n    )\n  }\n\n  write_digits(self)\n}\n\n///|\nfn Int64::output_size_hint(radix~ : Int = 10) -> Int {\n  match radix {\n    2..<7 => 70 // max length is 64, 70 is enough\n    8..<15 => 30 // max length is 23, 30 is enough\n    16..=36 => 20 // max length is 17, 20 is enough\n    _ => abort(\"radix must be between 2 and 36\")\n  }\n}\n\n///|\nfn Int::output_size_hint(radix~ : Int = 10) -> Int {\n  match radix {\n    2..<7 => 36 // max length is 32, 36 is enough\n    8..<15 => 18 // max length is 12, 18 is enough\n    16..=36 => 10 // max length is 8, 10 is enough\n    _ => abort(\"radix must be between 2 and 36\")\n  }\n}\n\n///|\nfn UInt::output_size_hint(radix~ : Int = 10) -> Int {\n  Int::output_size_hint(radix~)\n}\n\n///|\nfn UInt64::output_size_hint(radix~ : Int = 10) -> Int {\n  Int64::output_size_hint(radix~)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Creates an iterator that iterates over a range of Int with default step 1.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Int from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn Int::upto(self : Int, end : Int, inclusive~ : Bool = false) -> Iter[Int] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of UInt with default step 1U.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of UInt from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn UInt::upto(\n  self : UInt,\n  end : UInt,\n  inclusive~ : Bool = false,\n) -> Iter[UInt] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of UInt64 with default step 1UL.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of UInt64 from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn UInt64::upto(\n  self : UInt64,\n  end : UInt64,\n  inclusive~ : Bool = false,\n) -> Iter[UInt64] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of Int64 with default step 1L.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Int64 from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn Int64::upto(\n  self : Int64,\n  end : Int64,\n  inclusive~ : Bool = false,\n) -> Iter[Int64] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of Float with default step 1.0 .\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Float from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn Float::upto(\n  self : Float,\n  end : Float,\n  inclusive~ : Bool = false,\n) -> Iter[Float] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of Double with default step 1.0 .\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Double from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn Double::upto(\n  self : Double,\n  end : Double,\n  inclusive~ : Bool = false,\n) -> Iter[Double] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Searches the array for the first element that satisfies the predicate\n/// function.\n///\n/// Parameters:\n///\n/// * `array` : The array to search in.\n/// * `predicate` : A function that takes an element and returns a boolean\n/// indicating whether the element satisfies the search condition.\n///\n/// Returns the index of the first element that satisfies the predicate, or\n/// `None` if no such element is found.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.search_by((x) => { x > 3 }), content=\"Some(3)\")\n///   inspect(arr.search_by((x) => { x > 10 }), content=\"None\")\n/// ```\n///\n#deprecated(\"Use `search_by` instead.\")\n#coverage.skip\npub fn[T] Array::find_index(self : Array[T], f : (T) -> Bool) -> Int? {\n  self.search_by(f)\n}\n\n///|\n/// Search the index of the first element that satisfies the predicate.\n///\n\n///|\n/// Fold out values from an array according to certain rules.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// ```\n#deprecated(\"Use `fold` instead.\")\n#coverage.skip\npub fn[T, U] Array::fold_left(\n  self : Array[T],\n  f : (U, T) -> U raise?,\n  init~ : U,\n) -> U raise? {\n  self.fold(init~, f)\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].rev_fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// ```\n#deprecated(\"Use `rev_fold` instead.\")\n#coverage.skip\npub fn[T, U] Array::fold_right(\n  self : Array[T],\n  f : (U, T) -> U raise?,\n  init~ : U,\n) -> U raise? {\n  self.rev_fold(init~, f)\n}\n\n///|\n/// Fold out values from an array according to certain rules with index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// ```\n#deprecated(\"Use `foldi` instead.\")\n#coverage.skip\npub fn[T, U] Array::fold_lefti(\n  self : Array[T],\n  f : (Int, U, T) -> U raise?,\n  init~ : U,\n) -> U raise? {\n  self.foldi(init~, f)\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn with index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].rev_foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// ```\n#deprecated(\"Use `rev_foldi` instead.\")\n#coverage.skip\npub fn[T, U] Array::fold_righti(\n  self : Array[T],\n  f : (Int, U, T) -> U raise?,\n  init~ : U,\n) -> U raise? {\n  self.rev_foldi(init~, f)\n}\n\n///|\n#deprecated(\"Use `unsafe_pop` instead\")\n#coverage.skip\npub fn[T] Array::pop_exn(self : Array[T]) -> T {\n  self.unsafe_pop()\n}\n\n///|\n/// Creates a byte sequence from a UTF-16 encoded string. Each character in the\n/// string is encoded as a pair of bytes in little-endian order.\n///\n/// Parameters:\n///\n/// * `string` : The input string to be converted to a byte sequence.\n///\n/// Returns a new byte sequence containing the UTF-16LE encoded representation of\n/// the input string.\n///\n/// Example:\n///\n/// ```moonbit\n///   let bytes = \"ABC\".to_bytes()\n///   inspect(bytes, content=\"b\\\"\\\\x41\\\\x00\\\\x42\\\\x00\\\\x43\\\\x00\\\"\")\n/// ```\n#deprecated(\"Use `str.to_bytes()` instead\")\npub fn Bytes::of_string(str : String) -> Bytes {\n  FixedArray::make(str.length() * 2, Byte::default())\n  ..blit_from_string(0, str, 0, str.length())\n  .unsafe_reinterpret_as_bytes()\n}\n\n///|\n#deprecated(\"Bytes are immutable. Use `FixedArray::blit_from_bytes` if it's really necessary.\")\npub fn Bytes::copy(self : Bytes) -> Bytes {\n  Bytes::makei(self.length(), i => self[i])\n}\n\n///|\n/// positions.\n///\n/// Parameters:\n///\n/// - `byte_value` : The `Byte` value whose bits are to be shifted.\n/// - `shift_count` : The number of bit positions to shift the `byte_value` to\n///   the left.\n///\n/// Returns the resulting `Byte` value after the bitwise left shift operation.\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Byte::lsl(self : Byte, count : Int) -> Byte {\n  (self.to_int() << count).to_byte()\n}\n\n///|\n/// bits.\n///\n/// Parameters:\n///\n/// - `value` : The `Byte` value to be shifted.\n/// - `count` : The number of bits to shift the `value` to the right.\n///\n/// Returns the result of the logical shift right operation as a `Byte`.\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Byte::lsr(self : Byte, count : Int) -> Byte {\n  (self.to_uint() >> count).reinterpret_as_int().to_byte()\n}\n\n///|\n/// Prints and returns the value of a given expression for quick and dirty debugging.\n#callsite(autofill(loc))\n#deprecated(\"This function is for debugging only and should not be used in production\")\npub fn[T] dump(t : T, name? : String, loc~ : SourceLoc) -> T {\n  let name = match name {\n    Some(name) => name\n    None => \"\"\n  }\n  println(\"dump(\\{name}@\\{loc}) = \\{any_to_string(t)}\")\n  t\n}\n\n///|\n/// Returns the Unicode code point at the given index.\n///\n/// This method counts Unicode code points (characters) rather than UTF-16 code units.\n/// It properly handles surrogate pairs to return the correct Unicode character.\n///\n/// # Examples\n///\n/// ```mbt\n/// let s = \"Hello🤣\"\n/// inspect(s.get_char(0).unwrap(), content=\"H\")\n/// inspect(s.get_char(5).unwrap(), content=\"🤣\")\n/// ```\n///\n/// # Panics\n///\n/// Panics if:\n/// - The index is out of bounds\n/// - The string contains an invalid surrogate pair\n#deprecated(\"The index will be changed to utf16 index. If you want to access n-th character, use `str.iter().nth(n).unwrap()` instead.\")\npub fn String::codepoint_at(self : String, index : Int) -> Char {\n  let charcode_len = self.length()\n  guard index >= 0 && index < charcode_len else { abort(\"index out of bounds\") }\n  for char_count = 0, utf16_offset = 0\n      char_count < charcode_len && utf16_offset < index\n      char_count = char_count + 1, utf16_offset = utf16_offset + 1 {\n    let c1 = self.unsafe_charcode_at(char_count)\n    if c1.is_leading_surrogate() && char_count + 1 < charcode_len {\n      let c2 = self.unsafe_charcode_at(char_count + 1)\n      if c2.is_trailing_surrogate() {\n        continue char_count + 2, utf16_offset + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    guard utf16_offset == index && char_count < charcode_len else {\n      abort(\"index out of bounds\")\n    }\n    let c1 = self.unsafe_charcode_at(char_count)\n    if c1.is_leading_surrogate() && char_count + 1 < charcode_len {\n      let c2 = self.unsafe_charcode_at(char_count + 1)\n      if c2.is_trailing_surrogate() {\n        code_point_of_surrogate_pair(c1, c2)\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    } else {\n      c1.unsafe_to_char()\n    }\n  }\n}\n\n///|\n#deprecated(\"Use `char_length` instead.\")\npub fn String::codepoint_length(\n  self : String,\n  start_offset~ : Int = 0,\n  end_offset? : Int,\n) -> Int {\n  self.char_length(start_offset~, end_offset?)\n}\n\n///|\n#deprecated(\"Use `s[i]` instead\")\npub fn String::charcode_at(self : String, index : Int) -> Int {\n  self[index]\n}\n\n///|\n/// Returns the Unicode code point at the given index without bounds checking.\n#deprecated(\"Use `s.get_char(i).unwrap()` instead\")\npub fn String::unsafe_char_at(self : String, index : Int) -> Char {\n  let c1 = self.unsafe_charcode_at(index)\n  if c1.is_leading_surrogate() {\n    let c2 = self.unsafe_charcode_at(index + 1)\n    code_point_of_surrogate_pair(c1, c2)\n  } else {\n    c1.unsafe_to_char()\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Trait for types whose elements can test for equality\npub(open) trait Eq {\n  op_equal(Self, Self) -> Bool\n}\n\n///|\n/// Trait for types whose elements are ordered\n///\n/// The return value of [compare] is:\n/// - zero, if the two arguments are equal\n/// - negative, if the first argument is smaller\n/// - positive, if the first argument is greater\npub(open) trait Compare: Eq {\n  compare(Self, Self) -> Int\n}\n\n///|\n/// Trait for types that can be hashed\npub(open) trait Hash {\n  hash_combine(Self, Hasher) -> Unit\n  hash(Self) -> Int = _\n}\n\n///|\nimpl Hash with hash(self) {\n  Hasher::new()..combine(self).finalize()\n}\n\n///|\n/// Trait for types with a default value\npub(open) trait Default {\n  default() -> Self\n}\n\n///|\n/// Trait for a logger, where debug logs can be written into\npub(open) trait Logger {\n  write_string(Self, String) -> Unit\n  write_substring(Self, String, Int, Int) -> Unit\n  write_char(Self, Char) -> Unit = _\n}\n\n///|\nimpl Logger with write_char(self, value) {\n  self.write_string([value])\n}\n\n///|\n/// Trait for types that can be converted to `String`\npub(open) trait Show {\n  // `output` is used for composition of aggregate structure.\n  // `output` writes a string representation of `self` to a logger.\n  // `output` should produce a valid MoonBit-syntax representation if possible.\n  // For example, `Show::output` for `String` should be quoted\n  output(Self, &Logger) -> Unit\n  // `to_string` should be used by end users of `Show`,\n  // for printing, interpolation, etc. only, and should not be used for composition.\n  // By default `to_string` is implemented using `output` and a buffer,\n  // but some types, such as `String`, may override `to_string`,\n  // for different (unescaped) behavior when interpolated/printed directly\n  to_string(Self) -> String = _\n}\n\n///|\n// Default implementation for `Show::to_string`, uses a `Buffer`\nimpl Show with to_string(self) {\n  let logger = StringBuilder::new()\n  self.output(logger)\n  logger.to_string()\n}\n\n///|\npub fn[Obj : Show] &Logger::write_object(self : &Logger, obj : Obj) -> Unit {\n  obj.output(self)\n}\n\n///|\npub fn[T : Show] &Logger::write_iter(\n  self : &Logger,\n  iter : Iter[T],\n  prefix~ : String = \"[\",\n  suffix~ : String = \"]\",\n  sep~ : String = \", \",\n  trailing~ : Bool = false,\n) -> Unit {\n  self.write_string(prefix)\n  if trailing {\n    for x in iter {\n      self.write_object(x)\n      self.write_string(sep)\n    }\n  } else {\n    // trailing is false\n    let mut first = true\n    for x in iter {\n      if first {\n        first = false\n      } else {\n        self.write_string(sep)\n      }\n      self.write_object(x)\n    }\n  }\n  self.write_string(suffix)\n}\n// TODO: Logger::write_double(self:Logger, val:Double) -> Unit\n\n///|\npub fn[T : Show] repr(t : T) -> String {\n  let logger = StringBuilder::new()\n  t.output(logger)\n  logger.to_string()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl[T0 : Eq, T1 : Eq] Eq for (T0, T1) with op_equal(\n  self : (T0, T1),\n  other : (T0, T1),\n) -> Bool {\n  self.0 == other.0 && self.1 == other.1\n}\n\n///|\npub impl[T0 : Eq, T1 : Eq, T2 : Eq] Eq for (T0, T1, T2) with op_equal(\n  self : (T0, T1, T2),\n  other : (T0, T1, T2),\n) -> Bool {\n  self.0 == other.0 && self.1 == other.1 && self.2 == other.2\n}\n\n///|\npub impl[T0 : Eq, T1 : Eq, T2 : Eq, T3 : Eq] Eq for (T0, T1, T2, T3) with op_equal(\n  self : (T0, T1, T2, T3),\n  other : (T0, T1, T2, T3),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3\n}\n\n///|\npub impl[T0 : Eq, T1 : Eq, T2 : Eq, T3 : Eq, T4 : Eq] Eq for (\n  T0,\n  T1,\n  T2,\n  T3,\n  T4,\n) with op_equal(self : (T0, T1, T2, T3, T4), other : (T0, T1, T2, T3, T4)) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4\n}\n\n///|\npub impl[T0 : Eq, T1 : Eq, T2 : Eq, T3 : Eq, T4 : Eq, T5 : Eq] Eq for (\n  T0,\n  T1,\n  T2,\n  T3,\n  T4,\n  T5,\n) with op_equal(\n  self : (T0, T1, T2, T3, T4, T5),\n  other : (T0, T1, T2, T3, T4, T5),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5\n}\n\n///|\npub impl[T0 : Eq, T1 : Eq, T2 : Eq, T3 : Eq, T4 : Eq, T5 : Eq, T6 : Eq] Eq for (\n  T0,\n  T1,\n  T2,\n  T3,\n  T4,\n  T5,\n  T6,\n) with op_equal(\n  self : (T0, T1, T2, T3, T4, T5, T6),\n  other : (T0, T1, T2, T3, T4, T5, T6),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6\n}\n\n///|\npub impl[T0 : Eq, T1 : Eq, T2 : Eq, T3 : Eq, T4 : Eq, T5 : Eq, T6 : Eq, T7 : Eq] Eq for (\n  T0,\n  T1,\n  T2,\n  T3,\n  T4,\n  T5,\n  T6,\n  T7,\n) with op_equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8) with op_equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n  T9 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) with op_equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8 &&\n  self.9 == other.9\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n  T9 : Eq,\n  T10 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) with op_equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8 &&\n  self.9 == other.9 &&\n  self.10 == other.10\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n  T9 : Eq,\n  T10 : Eq,\n  T11 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) with op_equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8 &&\n  self.9 == other.9 &&\n  self.10 == other.10 &&\n  self.11 == other.11\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n  T9 : Eq,\n  T10 : Eq,\n  T11 : Eq,\n  T12 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) with op_equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8 &&\n  self.9 == other.9 &&\n  self.10 == other.10 &&\n  self.11 == other.11 &&\n  self.12 == other.12\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n  T9 : Eq,\n  T10 : Eq,\n  T11 : Eq,\n  T12 : Eq,\n  T13 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) with op_equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8 &&\n  self.9 == other.9 &&\n  self.10 == other.10 &&\n  self.11 == other.11 &&\n  self.12 == other.12 &&\n  self.13 == other.13\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n  T9 : Eq,\n  T10 : Eq,\n  T11 : Eq,\n  T12 : Eq,\n  T13 : Eq,\n  T14 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) with op_equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8 &&\n  self.9 == other.9 &&\n  self.10 == other.10 &&\n  self.11 == other.11 &&\n  self.12 == other.12 &&\n  self.13 == other.13 &&\n  self.14 == other.14\n}\n\n///|\npub impl[\n  T0 : Eq,\n  T1 : Eq,\n  T2 : Eq,\n  T3 : Eq,\n  T4 : Eq,\n  T5 : Eq,\n  T6 : Eq,\n  T7 : Eq,\n  T8 : Eq,\n  T9 : Eq,\n  T10 : Eq,\n  T11 : Eq,\n  T12 : Eq,\n  T13 : Eq,\n  T14 : Eq,\n  T15 : Eq,\n] Eq for (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) with op_equal(\n  self : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15),\n  other : (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15),\n) -> Bool {\n  self.0 == other.0 &&\n  self.1 == other.1 &&\n  self.2 == other.2 &&\n  self.3 == other.3 &&\n  self.4 == other.4 &&\n  self.5 == other.5 &&\n  self.6 == other.6 &&\n  self.7 == other.7 &&\n  self.8 == other.8 &&\n  self.9 == other.9 &&\n  self.10 == other.10 &&\n  self.11 == other.11 &&\n  self.12 == other.12 &&\n  self.13 == other.13 &&\n  self.14 == other.14 &&\n  self.15 == other.15\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl[A : Hash, B : Hash] Hash for (A, B) with hash_combine(self, hasher) {\n  let (a, b) = self\n  hasher..combine(a)..combine(b)\n}\n\n///|\npub impl[A : Hash, B : Hash, C : Hash] Hash for (A, B, C) with hash_combine(\n  self,\n  hasher,\n) {\n  let (a, b, c) = self\n  hasher..combine(a)..combine(b)..combine(c)\n}\n\n///|\npub impl[A : Hash, B : Hash, C : Hash, D : Hash] Hash for (A, B, C, D) with hash_combine(\n  self,\n  hasher,\n) {\n  let (a, b, c, d) = self\n  hasher..combine(a)..combine(b)..combine(c)..combine(d)\n}\n\n///|\npub impl[A : Hash, B : Hash, C : Hash, D : Hash, E : Hash] Hash for (\n  A,\n  B,\n  C,\n  D,\n  E,\n) with hash_combine(self, hasher) {\n  let (a, b, c, d, e) = self\n  hasher..combine(a)..combine(b)..combine(c)..combine(d)..combine(e)\n}\n\n///|\npub impl[A : Hash, B : Hash, C : Hash, D : Hash, E : Hash, F : Hash] Hash for (\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n) with hash_combine(self, hasher) {\n  let (a, b, c, d, e, f) = self\n  hasher..combine(a)..combine(b)..combine(c)..combine(d)..combine(e)..combine(f)\n}\n\n///|\npub impl[A : Hash, B : Hash, C : Hash, D : Hash, E : Hash, F : Hash, G : Hash] Hash for (\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n) with hash_combine(self, hasher) {\n  let (a, b, c, d, e, f, g) = self\n  hasher\n  ..combine(a)\n  ..combine(b)\n  ..combine(c)\n  ..combine(d)\n  ..combine(e)\n  ..combine(f)\n  ..combine(g)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a source code location in a MoonBit program, containing\n/// information about the file path, line number, and column number. Used\n/// internally by the compiler for error reporting and debugging purposes.\n///\n/// This type is public to all packages but its internal representation is\n/// opaque. Users cannot construct values of this type directly; they are\n/// automatically created by the compiler when needed.\n/// TODO: can not make a dummy loc\npub(all) type SourceLoc\n\n///|\n/// Converts a source location to its string representation.\n///\n/// Parameters:\n///\n/// * `source_location` : A source code location containing information about the\n/// file path, line number, and column number.\n///\n/// Returns a string representation of the source location, typically in the\n/// format \"file:line:column\".\n///\n/// Note: This function is primarily used internally by the compiler for error\n/// reporting and debugging purposes. Source locations are automatically created\n/// by the compiler when needed.\npub fn SourceLoc::to_string(self : Self) -> String = \"%loc_to_string\"\n\n///|\npub impl Show for SourceLoc with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\n/// Represents a type for storing argument locations in source code. It is an\n/// array of optional source locations, where each element corresponds to an\n/// argument's location in the source code. Used internally by the compiler for\n/// error reporting and debugging purposes.\npub(all) struct ArgsLoc(Array[SourceLoc?]) derive(Show)\n\n///|\n/// Converts an array of optional source locations to its JSON string\n/// representation. Each location in the array is either represented as a string\n/// if present, or \"null\" if absent.\n///\n/// Parameters:\n///\n/// * `self` : The array of optional source locations to be converted.\n///\n/// Returns a JSON array string where each element is either a string\n/// representation of a source location or \"null\".\npub fn ArgsLoc::to_json(self : ArgsLoc) -> String {\n  let buf = StringBuilder::new(size_hint=10)\n  let ArgsLoc(self) = self\n  buf.write_char('[')\n  for i in 0..<self.length() {\n    if i != 0 {\n      buf.write_string(\", \")\n    }\n    let item = self[i]\n    match item {\n      None => buf.write_string(\"null\")\n      Some(loc) => loc.to_string() |> Show::output(buf)\n    }\n  }\n  buf.write_char(']')\n  buf.to_string()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Reinterpret the byte sequence as Bytes.\n///\n/// Notice that this will make the `Bytes` object to be a view of the original\n/// byte sequence, so any modification to the original byte sequence will be\n/// reflected in the `Bytes` object.\n#internal(unsafe, \"Creating mutable Bytes\")\npub fn FixedArray::unsafe_reinterpret_as_bytes(\n  self : FixedArray[Byte],\n) -> Bytes = \"%identity\"\n\n///|\n/// Creates a new byte sequence of the specified length, where each byte is\n/// initialized using a function that maps indices to bytes.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. If `length` is less than or\n/// equal to 0, returns an empty byte sequence.\n/// * `value` : A function that takes an index (from 0 to `length - 1`) and\n/// returns a byte for that position.\n///\n/// Returns a new byte sequence containing the bytes produced by applying the\n/// value function to each index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let bytes = Bytes::makei(3, (i) => { (i + 65).to_byte() })\n///   assert_eq(bytes, b\"ABC\")\n/// ```\npub fn Bytes::makei(length : Int, value : (Int) -> Byte raise?) -> Bytes raise? {\n  if length <= 0 {\n    return []\n  }\n  let arr = FixedArray::make(length, value(0))\n  for i in 1..<length {\n    arr[i] = value(i)\n  }\n  FixedArray::unsafe_reinterpret_as_bytes(arr)\n}\n\n///|\n/// TODO: support local primitive declaration\nfn unsafe_sub_string(\n  bytes : Bytes,\n  byte_offset : Int,\n  byte_length : Int,\n) -> String = \"$moonbit.unsafe_bytes_sub_string\"\n\n///|\n/// Return an unchecked string, containing the subsequence of `self` that starts at\n/// `offset` and has length `length`. Both `offset` and `length`\n/// are indexed by byte.\n///\n/// Note this function does not validate the encoding of the byte sequence,\n/// it simply copy the bytes into a new String.\npub fn Bytes::to_unchecked_string(\n  self : Bytes,\n  offset~ : Int = 0,\n  length? : Int,\n) -> String {\n  let len = self.length()\n  let length = if length is Some(l) { l } else { len - offset }\n  guard offset >= 0 && length >= 0 && offset + length <= len\n  unsafe_sub_string(self, offset, length)\n}\n\n///|\n/// Copies characters from a string to a byte sequence in UTF-16LE encoding. Each\n/// character is converted into two bytes, with the lower byte stored first.\n///\n/// Parameters:\n///\n/// * `self` : The destination byte array to copy the characters into.\n/// * `bytes_offset` : The starting position in the destination array where bytes\n/// will be written.\n/// * `str` : The source string containing the characters to copy.\n/// * `str_offset` : The starting position in the source string from which\n/// characters will be read.\n/// * `length` : The number of characters to copy.\n///\n/// Throws a runtime error if:\n///\n/// * `length` is negative\n/// * `bytes_offset` is negative\n/// * `str_offset` is negative\n/// * The range `[bytes_offset, bytes_offset + length * 2)` exceeds the length of\n/// the destination array\n/// * The range `[str_offset, str_offset + length)` exceeds the length of the\n/// source string\n///\n/// Example:\n///\n/// ```moonbit\n///   let bytes = FixedArray::make(6, b'\\x00')\n///   bytes.blit_from_string(0, \"ABC\", 0, 3)\n///   @json.inspect(bytes, content=[65,0,66,0,67,0]) // 'A'\n///   bytes.blit_from_string(0, \"你好啊\", 0, 3)\n///   @json.inspect(bytes, content=[96,79,125,89,74,85]) // '你好啊'\n///   bytes.blit_from_string(0, \"😈\", 0, 2)\n///   @json.inspect(bytes, content=[61,216,8,222,74,85]) // '😈'\n/// ```\npub fn FixedArray::blit_from_string(\n  self : FixedArray[Byte],\n  bytes_offset : Int,\n  str : String,\n  str_offset : Int,\n  length : Int,\n) -> Unit {\n  let s1 = bytes_offset\n  let s2 = str_offset\n  let e1 = bytes_offset + length * 2 - 1\n  let e2 = str_offset + length - 1\n  let len1 = self.length()\n  let len2 = str.length()\n  guard length >= 0 && s1 >= 0 && e1 < len1 && s2 >= 0 && e2 < len2\n  let end_str_offset = str_offset + length\n  for i = str_offset, j = bytes_offset; i < end_str_offset; i = i + 1, j = j + 2 {\n    let c = str.unsafe_charcode_at(i).reinterpret_as_uint()\n    self[j] = (c & 0xff).to_byte()\n    self[j + 1] = (c >> 8).to_byte()\n  }\n}\n\n///|\n/// TODO: specific copy\nfn unsafe_from_bytes(bytes : Bytes) -> FixedArray[Byte] = \"%identity\"\n\n///|\n/// Copy `length` chars from byte sequence `src`, starting at `src_offset`,\n/// into byte sequence `self`, starting at `bytes_offset`.\npub fn FixedArray::blit_from_bytes(\n  self : FixedArray[Byte],\n  bytes_offset : Int,\n  src : Bytes,\n  src_offset : Int,\n  length : Int,\n) -> Unit {\n  let s1 = bytes_offset\n  let s2 = src_offset\n  let e1 = bytes_offset + length - 1\n  let e2 = src_offset + length - 1\n  let len1 = self.length()\n  let len2 = src.length()\n  guard length >= 0 && s1 >= 0 && e1 < len1 && s2 >= 0 && e2 < len2\n  FixedArray::unsafe_blit(\n    self,\n    bytes_offset,\n    unsafe_from_bytes(src),\n    src_offset,\n    length,\n  )\n}\n\n///|\n/// Encodes a Unicode character into UTF-8 bytes and writes them into a fixed\n/// array of bytes at the specified offset.\n///\n/// Parameters:\n///\n/// * `array` : The fixed array of bytes to write into.\n/// * `offset` : The starting position in the array where the encoded bytes will\n/// be written.\n/// * `char` : The Unicode character to be encoded.\n///\n/// Returns the number of bytes written (1 to 4 bytes depending on the\n/// character's code point).\n///\n/// Throws a panic if:\n///\n/// * The character's code point is greater than 0x10FFFF.\n/// ```moonbit\n///   let buf = FixedArray::make(4, b'\\x00')\n///   let written = buf.set_utf8_char(0, '€') // Euro symbol (U+20AC)\n///   inspect(written, content=\"3\") // UTF-8 encoding takes 3 bytes\n///   inspect(buf[0], content=\"b'\\\\xE2'\")\n///   inspect(buf[1], content=\"b'\\\\x82'\")\n///   inspect(buf[2], content=\"b'\\\\xAC'\")\n/// ```\npub fn FixedArray::set_utf8_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  match code {\n    _..<0x80 => {\n      self[offset] = ((code & 0x7F) | 0x00).to_byte()\n      1\n    }\n    _..<0x0800 => {\n      self[offset] = (((code >> 6) & 0x1F) | 0xC0).to_byte()\n      self[offset + 1] = ((code & 0x3F) | 0x80).to_byte()\n      2\n    }\n    _..<0x010000 => {\n      self[offset] = (((code >> 12) & 0x0F) | 0xE0).to_byte()\n      self[offset + 1] = (((code >> 6) & 0x3F) | 0x80).to_byte()\n      self[offset + 2] = ((code & 0x3F) | 0x80).to_byte()\n      3\n    }\n    _..<0x110000 => {\n      self[offset] = (((code >> 18) & 0x07) | 0xF0).to_byte()\n      self[offset + 1] = (((code >> 12) & 0x3F) | 0x80).to_byte()\n      self[offset + 2] = (((code >> 6) & 0x3F) | 0x80).to_byte()\n      self[offset + 3] = ((code & 0x3F) | 0x80).to_byte()\n      4\n    }\n    _ => abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Fill UTF16LE encoded char `value` into byte sequence `self`, starting at `offset`.\n/// It return the length of bytes has been written.\n///\n/// This function will panic if the `value` is out of range.\npub fn FixedArray::set_utf16le_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  if code < 0x10000 {\n    self[offset] = (code & 0xFF).to_byte()\n    self[offset + 1] = (code >> 8).to_byte()\n    2\n  } else if code < 0x110000 {\n    let hi = code - 0x10000\n    let lo = (hi >> 10) | 0xD800\n    let hi = (hi & 0x3FF) | 0xDC00\n    self[offset] = (lo & 0xFF).to_byte()\n    self[offset + 1] = (lo >> 8).to_byte()\n    self[offset + 2] = (hi & 0xFF).to_byte()\n    self[offset + 3] = (hi >> 8).to_byte()\n    4\n  } else {\n    abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Fill UTF16BE encoded char `value` into byte sequence `self`, starting at `offset`.\n/// It return the length of bytes has been written.\n///\n/// This function will panic if the `value` is out of range.\npub fn FixedArray::set_utf16be_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  if code < 0x10000 {\n    self[offset] = (code >> 8).to_byte()\n    self[offset + 1] = (code & 0xFF).to_byte()\n    2\n  } else if code < 0x110000 {\n    let hi = code - 0x10000\n    let lo = (hi >> 10) | 0xD800\n    let hi = (hi & 0x3FF) | 0xDC00\n    self[offset] = (lo >> 8).to_byte()\n    self[offset + 1] = (lo & 0xFF).to_byte()\n    self[offset + 2] = (hi >> 8).to_byte()\n    self[offset + 3] = (hi & 0xFF).to_byte()\n    4\n  } else {\n    abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Compares two byte sequences for equality. Returns true only if both sequences\n/// have the same length and contain identical bytes in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first byte sequence to compare.\n/// * `other` : The second byte sequence to compare.\n///\n/// Returns `true` if the byte sequences are equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let bytes1 = b\"\\x01\\x02\\x03\"\n///   let bytes2 = b\"\\x01\\x02\\x03\"\n///   let bytes3 = b\"\\x01\\x02\\x04\"\n///   inspect(bytes1 == bytes2, content=\"true\")\n///   inspect(bytes1 == bytes3, content=\"false\")\n/// ```\npub impl Eq for Bytes with op_equal(self : Bytes, other : Bytes) -> Bool {\n  if self.length() != other.length() {\n    false\n  } else {\n    let len = self.length()\n    for i in 0..<len {\n      if self[i] != other[i] {\n        break false\n      }\n    } else {\n      true\n    }\n  }\n}\n\n///|\n/// Compares two byte sequences lexicographically. First compares the lengths of\n/// the sequences, then compares bytes pairwise until a difference is found or\n/// all bytes have been compared.\n///\n/// Parameters:\n///\n/// * `self` : The first byte sequence to compare.\n/// * `other` : The second byte sequence to compare.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = b\"\\x01\\x02\\x03\"\n///   let b = b\"\\x01\\x02\\x04\"\n///   inspect(a.compare(b), content=\"-1\") // a < b\n///   inspect(b.compare(a), content=\"1\") // b > a\n///   inspect(a.compare(a), content=\"0\") // a = a\n///\n///   let a = b\"\\x01\\x02\"\n///   let b = b\"\\x01\\x02\\x03\"\n///   inspect(a.compare(b), content=\"-1\") // shorter sequence is less\n///   inspect(b.compare(a), content=\"1\") // longer sequence is greater\n/// ```\npub impl Compare for Bytes with compare(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  let cmp = self_len.compare(other_len)\n  if cmp != 0 {\n    return cmp\n  }\n  for i in 0..<self_len {\n    let b1 = self.unsafe_get(i)\n    let b2 = other.unsafe_get(i)\n    let cmp = b1.compare(b2)\n    if cmp != 0 {\n      break cmp\n    }\n  } else {\n    0\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n#coverage.skip\npub fn[T : Compare] op_lt(self_ : T, other : T) -> Bool {\n  self_.compare(other).is_neg()\n}\n\n///|\n#coverage.skip\npub fn[T : Compare] op_gt(self_ : T, other : T) -> Bool {\n  self_.compare(other).is_pos()\n}\n\n///|\n#coverage.skip\npub fn[T : Compare] op_le(self_ : T, other : T) -> Bool {\n  self_.compare(other).is_non_pos()\n}\n\n///|\n#coverage.skip\npub fn[T : Compare] op_ge(self_ : T, other : T) -> Bool {\n  self_.compare(other).is_non_neg()\n}\n\n///|\n#coverage.skip\npub fn[T : Eq] op_notequal(x : T, y : T) -> Bool {\n  !(x == y)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn unsafe_make_string(length : Int, value : Char) -> String = \"$moonbit.unsafe_make_string\"\n\n///|\n/// Create new string of `length`, where each character is `value`\n///\n/// ```mbt\n///   assert_eq(String::make(5,'S'), \"SSSSS\")\n/// ```\npub fn String::make(length : Int, value : Char) -> String {\n  guard length >= 0 else { abort(\"invalid length\") }\n  if value.to_int() <= 0xFFFF {\n    unsafe_make_string(length, value)\n  } else {\n    let buf = StringBuilder::new(size_hint=2 * length)\n    for _ in 0..<length {\n      buf.write_char(value)\n    }\n    buf.to_string()\n  }\n}\n\n///|\nfn code_point_of_surrogate_pair(leading : Int, trailing : Int) -> Char {\n  ((leading - 0xD800) * 0x400 + trailing - 0xDC00 + 0x10000).unsafe_to_char()\n}\n\n///|\n/// Returns the number of Unicode code points (characters) in the string.\n///\n/// This method counts actual Unicode characters, properly handling surrogate pairs\n/// that represent single characters like emojis. For the raw UTF-16 code unit count,\n/// use `length()` instead.\n///\n/// # Examples\n///\n/// ```mbt\n///   let s = \"Hello🤣\";\n///   inspect(s.char_length(), content = \"6\"); // 6 actual characters\n///   inspect(s.length(), content = \"7\");  // 5 ASCII chars + 2 surrogate pairs\n/// ```\npub fn String::char_length(\n  self : String,\n  start_offset~ : Int = 0,\n  end_offset? : Int,\n) -> Int {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"invalid start or end index for String::codepoint_length\")\n  }\n  for utf16_index = start_offset, char_count = 0\n      utf16_index < end_offset\n      utf16_index = utf16_index + 1, char_count = char_count + 1 {\n    let c1 = self.unsafe_charcode_at(utf16_index)\n    if c1.is_leading_surrogate() && utf16_index + 1 < end_offset {\n      let c2 = self.unsafe_charcode_at(utf16_index + 1)\n      if c2.is_trailing_surrogate() {\n        continue utf16_index + 2, char_count + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    char_count\n  }\n}\n\n///|\n#intrinsic(\"%string.substring\")\nfn unsafe_substring(str : String, start : Int, end : Int) -> String {\n  let len = end - start\n  let bytes = FixedArray::make(len * 2, Byte::default())\n  bytes.blit_from_string(0, str, start, len)\n  bytes.unsafe_reinterpret_as_bytes().to_unchecked_string()\n}\n\n///|\n/// Returns a new string containing characters from the original string starting\n/// at `start` index up to (but not including) `end` index.\n///\n/// Parameters:\n///\n/// * `string` : The source string from which to extract the substring.\n/// * `start` : The starting index of the substring (inclusive). Defaults to 0.\n/// * `end` : The ending index of the substring (exclusive). Defaults to the\n/// length of the string.\n///\n/// Returns a new string containing the specified substring.\n///\n/// Example:\n///\n/// ```moonbit\n///   let s = \"Hello world\"\n///   inspect(s.substring(start=0, end=5), content=\"Hello\")\n///   inspect(s.substring(start=6, end=11), content=\"world\")\n///   inspect(s.substring(), content=\"Hello world\")\n///\n///   let s = \"test\"\n///   inspect(s.substring(start=2, end=2), content=\"\")\n///   inspect(\"\".substring(), content=\"\")\n/// ```\npub fn String::substring(self : String, start~ : Int = 0, end? : Int) -> String {\n  let len = self.length()\n  let end = match end {\n    Some(end) => end\n    None => len\n  }\n  guard start >= 0 && start <= end && end <= len\n  unsafe_substring(self, start, end)\n}\n\n///|\ntest \"substring/empty\" {\n  let s = \"test\"\n  inspect(s.substring(start=2, end=2), content=\"\")\n  inspect(s.substring(start=4, end=4), content=\"\")\n  inspect(\"\".substring(), content=\"\")\n}\n\n///|\ntest \"panic substring/invalid_range\" {\n  let s = \"test\"\n  ignore(s.substring(start=-1))\n  ignore(s.substring(end=5))\n  ignore(s.substring(start=3, end=2))\n}\n\n///|\ntest \"substring/basic\" {\n  inspect(\"Hello world\".substring(start=0, end=5), content=\"Hello\")\n  inspect(\"Hello world\".substring(start=6, end=11), content=\"world\")\n  inspect(\"Hello world\".substring(start=0), content=\"Hello world\")\n  inspect(\"Hello world\".substring(start=6), content=\"world\")\n}\n\n///|\ntest \"substring/boundary\" {\n  inspect(\"\".substring(start=0, end=0), content=\"\")\n  inspect(\"a\".substring(start=0, end=1), content=\"a\")\n  inspect(\"abc\".substring(start=0), content=\"abc\")\n  inspect(\"abc\".substring(start=1), content=\"bc\")\n  inspect(\"abc\".substring(start=0, end=3), content=\"abc\")\n}\n\n///|\ntest \"panic substring/out_of_bounds\" {\n  ignore(\"hello\".substring(start=-1, end=4))\n  ignore(\"hello\".substring(start=6, end=4))\n  ignore(\"hello\".substring(start=0, end=6))\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the smallest power of two greater than or equal to `self`.\n/// This function will panic if `self` is negative. For values greater than\n/// the largest representable power of two (2^30 = 1073741824), it returns\n/// the largest representable power of two.\n///\n/// Example:\n/// ```moonbit\n///   inspect((0).next_power_of_two(), content=\"1\")\n///   inspect((1).next_power_of_two(), content=\"1\")\n///   inspect((2).next_power_of_two(), content=\"2\")\n///   inspect((3).next_power_of_two(), content=\"4\")\n///   inspect((8).next_power_of_two(), content=\"8\")\n///   inspect((1073741824).next_power_of_two(), content=\"1073741824\")\n///   inspect((2000000000).next_power_of_two(), content=\"1073741824\")\n/// ```\npub fn Int::next_power_of_two(self : Int) -> Int {\n  guard self >= 0\n  if self <= 1 {\n    return 1\n  }\n  // The largest power of 2 that fits in a 32-bit signed integer is 2^30\n  let max_power_of_two = 1073741824 // 2^30\n  if self > max_power_of_two {\n    return max_power_of_two\n  }\n  // 2147483647 is the largest value of an integer\n  (2147483647 >> ((self - 1).clz() - 1)) + 1\n}\n\n///|\n/// Returns the minimum of two integers.\n///\n/// Example:\n/// ```moonbit\n///   inspect((1).min(2), content=\"1\")\n///   inspect((2).min(1), content=\"1\")\n/// ```\npub fn Int::min(self : Int, other : Int) -> Int {\n  if self < other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Returns the maximum of two integers.\n///\n/// Example:\n/// ```moonbit\n///   inspect((1).max(2), content=\"2\")\n///   inspect((2).max(1), content=\"2\")\n/// ```\npub fn Int::max(self : Int, other : Int) -> Int {\n  if self > other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Clamps the value `self` between `min` and `max`.\n///\n/// Example:\n/// ```moonbit\n///   inspect((1).clamp(min=0, max=2), content=\"1\")\n///   inspect((-1).clamp(min=0, max=2), content=\"0\")\n///   inspect((3).clamp(min=0, max=2), content=\"2\")\n///   inspect((-1).clamp(min=0, max=2), content=\"0\")\n/// ```\npub fn Int::clamp(self : Int, min~ : Int, max~ : Int) -> Int {\n  guard min <= max\n  if self < min {\n    min\n  } else if self > max {\n    max\n  } else {\n    self\n  }\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 leading surrogate.\n/// Leading surrogates are in the range 0xD800 to 0xDBFF.\n///\n/// Example:\n/// ```moonbit\n/// inspect((0xD800).is_leading_surrogate(), content=\"true\")\n/// inspect((0xDBFF).is_leading_surrogate(), content=\"true\")\n/// inspect((0xDC00).is_leading_surrogate(), content=\"false\")\n/// inspect((0x41).is_leading_surrogate(), content=\"false\") // 'A'\n/// ```\npub fn Int::is_leading_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDBFF\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 trailing surrogate.\n/// Trailing surrogates are in the range 0xDC00 to 0xDFFF.\n///\n/// Example:\n/// ```moonbit\n///   inspect((0xDC00).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xDFFF).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xD800).is_trailing_surrogate(), content=\"false\")\n///   inspect((0x41).is_trailing_surrogate(), content=\"false\") // 'A'\n/// ```\npub fn Int::is_trailing_surrogate(self : Int) -> Bool {\n  0xDC00 <= self && self <= 0xDFFF\n}\n\n///|\n/// Checks if the integer value represents any UTF-16 surrogate (leading or trailing).\n/// Surrogates are in the range 0xD800 to 0xDFFF.\n///\n/// Example:\n/// ```moonbit\n///   inspect((0xD800).is_surrogate(), content=\"true\")  // leading surrogate\n///   inspect((0xDC00).is_surrogate(), content=\"true\")  // trailing surrogate\n///   inspect((0xDFFF).is_surrogate(), content=\"true\")  // trailing surrogate\n///   inspect((0x41).is_surrogate(), content=\"false\")   // 'A'\n///   inspect((0x1F600).is_surrogate(), content=\"false\") // 😀 emoji codepoint\n/// ```\npub fn Int::is_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDFFF\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Performs multiplication between two byte values. The result is truncated to\n/// fit within the byte range.\n///\n/// Parameters:\n///\n/// * `self` : The first byte operand in the multiplication.\n/// * `that` : The second byte operand in the multiplication.\n///\n/// Returns the product of the two bytes, truncated to fit within the byte range\n/// (0-255).\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = b'\\x02'\n///   let b = b'\\x03'\n///   inspect(a * b, content=\"b'\\\\x06'\") // 2 * 3 = 6\n///   let c = b'\\xFF'\n///   inspect(c * c, content=\"b'\\\\x01'\") // 255 * 255 = 65025, truncated to 1\n/// ```\npub impl Mul for Byte with op_mul(self : Byte, that : Byte) -> Byte {\n  (self.to_int() * that.to_int()).to_byte()\n}\n\n///|\n/// Performs division operation between two bytes by converting them to integers,\n/// performing the division, and converting the result back to a byte.\n///\n/// Parameters:\n///\n/// * `self` : The dividend byte value.\n/// * `that` : The divisor byte value.\n///\n/// Returns the quotient of the division as a byte.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = b'\\xFF' // 255\n///   let b = b'\\x03' // 3\n///   inspect(a / b, content=\"b'\\\\x55'\") // 255 / 3 = 85 (0x55)\n/// ```\npub impl Div for Byte with op_div(self : Byte, that : Byte) -> Byte {\n  (self.to_int() / that.to_int()).to_byte()\n}\n\n///|\npub impl Mod for Byte with op_mod(self : Byte, that : Byte) -> Byte {\n  (self.to_int() % that.to_int()).to_byte()\n}\n\n///|\n/// Compares two `Byte` values for equality.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value to compare.\n/// - `that` : The second `Byte` value to compare.\n///\n/// Returns `true` if the two `Byte` values are equal, otherwise `false`.\npub impl Eq for Byte with op_equal(self : Byte, that : Byte) -> Bool {\n  self.to_int() == that.to_int()\n}\n\n///|\n/// Adds two `Byte` values together and returns the result as a `Byte`.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to be added.\n/// - `byte2` : The second `Byte` value to be added.\n///\n/// Returns the sum of `byte1` and `byte2` as a `Byte`.\npub impl Add for Byte with op_add(self : Byte, that : Byte) -> Byte {\n  (self.to_int() + that.to_int()).to_byte()\n}\n\n///|\n/// Subtracts the second byte from the first byte and returns the result as a\n/// byte.\n///\n/// Parameters:\n///\n/// - `self` : The byte from which the second byte will be subtracted.\n/// - `that` : The byte to subtract from the first byte.\n///\n/// Returns the result of the subtraction as a byte.\npub impl Sub for Byte with op_sub(self : Byte, that : Byte) -> Byte {\n  (self.to_int() - that.to_int()).to_byte()\n}\n\n///|\n/// Compares two `Byte` values and returns an integer indicating their relative\n/// order.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to compare.\n/// - `byte2` : The second `Byte` value to compare.\n///\n/// Returns an integer where:\n/// - A value less than 0 indicates that `byte1` is less than `byte2`.\n/// - A value of 0 indicates that `byte1` is equal to `byte2`.\n/// - A value greater than 0 indicates that `byte1` is greater than `byte2`.\npub impl Compare for Byte with compare(self : Byte, that : Byte) -> Int {\n  self.to_int().compare(that.to_int())\n}\n\n///|\nfn alphabet(x : Int) -> String {\n  match x {\n    0 => \"0\"\n    1 => \"1\"\n    2 => \"2\"\n    3 => \"3\"\n    4 => \"4\"\n    5 => \"5\"\n    6 => \"6\"\n    7 => \"7\"\n    8 => \"8\"\n    9 => \"9\"\n    10 => \"A\"\n    11 => \"B\"\n    12 => \"C\"\n    13 => \"D\"\n    14 => \"E\"\n    15 => \"F\"\n    _ => abort(\"impossible\")\n  }\n}\n\n///|\n/// Converts a `Byte` to its string representation in hexadecimal format.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value to be converted.\n///\n/// Returns a `String` representing the `Byte` in the format `b'\\xHH'`, where\n/// `HH` is the hexadecimal representation of the byte.\npub fn Byte::to_string(self : Byte) -> String {\n  let i = self.to_int()\n  let hi = alphabet(i / 16)\n  let lo = alphabet(i % 16)\n  \"b'\\\\x\\{hi}\\{lo}'\"\n}\n\n///|\n/// Implements the `Hash` trait for `Byte` type by converting the byte to an\n/// integer and using it as the hash value.\n///\n/// Parameters:\n///\n/// * `self` : The byte value to be hashed.\n///\n/// Returns an integer representing the hash value of the byte.\n///\n/// Example:\n///\n/// ```moonbit\n///   let b = b'\\x42'\n///   inspect(Hash::hash(b), content=\"66\") // ASCII value of 'B'\n/// ```\npub impl Hash for Byte with hash(self) {\n  self.to_int()\n}\n\n///|\n/// Implements the `Hash` trait for `Byte` type by providing a `hash_combine`\n/// method that combines a byte value with a hasher.\n///\n/// Parameters:\n///\n/// * `self` : The byte value to be hashed.\n/// * `hasher` : The hasher object that will be used to combine the byte value\n/// into its internal state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// ```\npub impl Hash for Byte with hash_combine(self, hasher) {\n  hasher.combine_byte(self)\n}\n\n///|\n/// Returns the default value for a `Byte`, which is `b'\\x00'`.\n///\n/// Parameters:\n///\n/// - None\n///\n/// Returns the default `Byte` value, which is `b'\\x00'`.\npub impl Default for Byte with default() {\n  b'\\x00'\n}\n\n///|\n/// Performs a bitwise NOT operation on the given `Byte` value.\n///\n/// Parameters:\n///\n/// - `value` : The `Byte` value to apply the bitwise NOT operation on.\n///\n/// Returns the result of the bitwise NOT operation as a `Byte`.\npub fn Byte::lnot(self : Byte) -> Byte {\n  self.to_int().lnot().to_byte()\n}\n\n///|\n/// Performs a bitwise AND operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to perform the bitwise AND operation with.\n/// - `byte2` : The second `Byte` value to perform the bitwise AND operation\n///   with.\n///\n/// Returns the result of the bitwise AND operation as a `Byte`.\npub impl BitAnd for Byte with land(self : Byte, that : Byte) -> Byte {\n  (self.to_int() & that.to_int()).to_byte()\n}\n\n///|\n/// Performs a bitwise OR operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value.\n/// - `that` : The second `Byte` value.\n///\n/// Returns a new `Byte` value resulting from the bitwise OR operation.\npub impl BitOr for Byte with lor(self : Byte, that : Byte) -> Byte {\n  (self.to_int() | that.to_int()).to_byte()\n}\n\n///|\n/// Performs a bitwise XOR operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value.\n/// - `that` : The second `Byte` value.\n///\n/// Returns the result of the bitwise XOR operation as a `Byte`.\npub impl BitXOr for Byte with lxor(self : Byte, that : Byte) -> Byte {\n  (self.to_int() ^ that.to_int()).to_byte()\n}\n\n///|\n/// Converts a `Byte` to a `UInt`.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value to be converted.\n///\n/// Returns the `UInt` representation of the `Byte`.\npub fn Byte::to_uint(self : Byte) -> UInt {\n  self.to_int().reinterpret_as_uint()\n}\n\n///|\n/// Shifts the bits of the `Byte` value to the left by the specified number of\n/// positions.\n///\n/// Parameters:\n///\n/// - `byte_value` : The `Byte` value whose bits are to be shifted.\n/// - `shift_count` : The number of bit positions to shift the `byte_value` to\n///   the left.\n///\n/// Returns the resulting `Byte` value after the shift operation.\npub impl Shl for Byte with op_shl(self : Byte, count : Int) -> Byte {\n  (self.to_int() << count).to_byte()\n}\n\n///|\n/// Shifts the bits of the `Byte` value to the right by the specified number of\n/// positions.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value whose bits are to be shifted.\n/// - `count` : The number of bit positions to shift the `byte` value to the\n///   right.\n///\n/// Returns the resulting `Byte` value after the bitwise right shift operation.\npub impl Shr for Byte with op_shr(self : Byte, count : Int) -> Byte {\n  (self.to_uint() >> count).reinterpret_as_int().to_byte()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Evaluates an expression and discards its result. This is useful when you want\n/// to execute an expression for its side effects but don't care about its return\n/// value, or when you want to explicitly indicate that a value is intentionally\n/// unused.\n///\n/// Parameters:\n///\n/// * `value` : The value to be ignored. Can be of any type.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 42\n///   ignore(x) // Explicitly ignore the value\n///   let mut sum = 0\n///   ignore([1, 2, 3].iter().each((x) => { sum = sum + x })) // Ignore the Unit return value of each()\n/// ```\npub fn[T] ignore(t : T) -> Unit = \"%ignore\"\n\n///|\n/// Tests if two values are physically equal (i.e., point to the same memory\n/// location). Unlike structural equality testing (`==`), this function checks if\n/// two references point to exactly the same object in memory.\n///\n/// Parameters:\n///\n/// * `first` : The first value to compare.\n/// * `second` : The second value to compare.\n/// * `T` : The type parameter representing the type of values being compared.\n///\n/// Returns `true` if both values refer to the same object in memory, `false`\n/// otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr1 = [1, 2, 3]\n///   let arr2 = arr1\n///   let arr3 = [1, 2, 3]\n///   inspect(physical_equal(arr1, arr2), content=\"true\") // Same object\n///   inspect(physical_equal(arr1, arr3), content=\"false\") // Different objects with same content\n/// ```\npub fn[T] physical_equal(a : T, b : T) -> Bool = \"%refeq\"\n\n///|\npub fnalias @abort.abort\n\n///|\npub fn[T] panic() -> T = \"%panic\"\n\n// Bool primitive ops\n\n///|\n/// Performs logical negation on a boolean value.\n///\n/// Parameters:\n///\n/// * `value` : The boolean value to negate.\n///\n/// Returns the logical NOT of the input value: `true` if the input is `false`,\n/// and `false` if the input is `true`.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(not(true), content=\"false\")\n///   inspect(not(false), content=\"true\")\n/// ```\npub fn not(x : Bool) -> Bool = \"%bool_not\"\n\n///|\n/// Compares two boolean values for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare.\n///\n/// Returns `true` if both boolean values are equal (either both `true` or both\n/// `false`), `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(true == true, content=\"true\")\n///   inspect(false == true, content=\"false\")\n///   inspect(true == false, content=\"false\")\n///   inspect(false == false, content=\"true\")\n/// ```\npub impl Eq for Bool with op_equal(self : Bool, other : Bool) -> Bool = \"%bool_eq\"\n\n///|\n/// Compares two boolean values and returns their relative order. This is a\n/// deprecated method and users should use `compare` instead.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other` (i.e., `self` is `false`\n/// and `other` is `true`)\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other` (i.e., `self` is `true`\n/// and `other` is `false`)\n///\n/// Example:\n///\n/// ```moonbit\n///   let t = true\n///   let f = false\n///   // This usage is deprecated, use compare() instead\n///   inspect(t.compare(f), content=\"1\")\n///   inspect(f.compare(t), content=\"-1\")\n///   inspect(t.compare(t), content=\"0\")\n/// ```\n///\n#deprecated(\"Use `compare` instead\")\n#coverage.skip\npub fn Bool::op_compare(self : Bool, other : Bool) -> Int = \"%bool_compare\"\n\n///|\n/// Compares two boolean values and returns their relative order. The comparison\n/// follows the rule that `false` is less than `true`.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is `false` and `other` is `true`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is `true` and `other` is `false`\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(true.compare(false), content=\"1\") // true > false\n///   inspect(false.compare(true), content=\"-1\") // false < true\n///   inspect(true.compare(true), content=\"0\") // true = true\n/// ```\npub impl Compare for Bool with compare(self, other) = \"%bool_compare\"\n\n///|\n/// Returns the default value for the `Bool` type, which is `false`.\n///\n/// Returns a `Bool` value that represents the default state of a boolean value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let b : Bool = Bool::default()\n///   inspect(b, content=\"false\")\n/// ```\npub impl Default for Bool with default() = \"%bool_default\"\n\n// int32 primitive ops\n\n///|\n/// Performs arithmetic negation on an integer value, returning its additive\n/// inverse.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to negate.\n///\n/// Returns the negation of the input value. For all inputs except\n/// `Int::min_value()`, returns the value with opposite sign. When the input is\n/// `Int::min_value()`, returns `Int::min_value()` due to two's complement\n/// representation.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(-42, content=\"-42\")\n///   inspect(42, content=\"42\")\n///   inspect(--2147483647, content=\"2147483647\") // negating near min value\n/// ```\npub impl Neg for Int with op_neg(self) = \"%i32_neg\"\n\n///|\n/// Adds two 32-bit signed integers. Performs two's complement arithmetic, which\n/// means the operation will wrap around if the result exceeds the range of a\n/// 32-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer that is the sum of the two operands. If the\n/// mathematical sum exceeds the range of a 32-bit integer (-2,147,483,648 to\n/// 2,147,483,647), the result wraps around according to two's complement rules.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(42 + 1, content=\"43\")\n///   inspect(2147483647 + 1, content=\"-2147483648\") // Overflow wraps around to minimum value\n/// ```\npub impl Add for Int with op_add(self, other) = \"%i32_add\"\n\n///|\n/// Performs subtraction between two 32-bit integers, following standard two's\n/// complement arithmetic rules. When the result overflows or underflows, it\n/// wraps around within the 32-bit integer range.\n///\n/// Parameters:\n///\n/// * `self` : The minuend (the number being subtracted from).\n/// * `other` : The subtrahend (the number to subtract).\n///\n/// Returns the difference between `self` and `other`.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 42\n///   let b = 10\n///   inspect(a - b, content=\"32\")\n///   let max = 2147483647 // Int maximum value\n///   inspect(max - -1, content=\"-2147483648\") // Overflow case\n/// ```\npub impl Sub for Int with op_sub(self, other) = \"%i32_sub\"\n\n///|\n/// Multiplies two 32-bit integers. This is the implementation of the `*`\n/// operator for `Int`.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns the product of the two integers. If the result overflows the range of\n/// `Int`, it wraps around according to two's complement arithmetic.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(42 * 2, content=\"84\")\n///   inspect(-10 * 3, content=\"-30\")\n///   let max = 2147483647 // Int.max_value\n///   inspect(max * 2, content=\"-2\") // Overflow wraps around\n/// ```\npub impl Mul for Int with op_mul(self, other) = \"%i32_mul\"\n\n///|\n/// Performs integer division between two 32-bit integers. The result is\n/// truncated towards zero (rounds down for positive numbers and up for negative\n/// numbers).\n///\n/// Parameters:\n///\n/// * `dividend` : The first integer operand to be divided.\n/// * `divisor` : The second integer operand that divides the dividend.\n///\n/// Returns the quotient of the division operation.\n///\n/// Throws a panic if `divisor` is zero.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(10 / 3, content=\"3\") // truncates towards zero\n///   inspect(-10 / 3, content=\"-3\")\n///   inspect(10 / -3, content=\"-3\")\n/// ```\npub impl Div for Int with op_div(self, other) = \"%i32_div\"\n\n///|\n/// Calculates the remainder of dividing one integer by another. The result\n/// follows the formula `dividend - (dividend / divisor) * divisor`, maintaining\n/// the same sign as the dividend.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (the number being divided).\n/// * `other` : The divisor (the number to divide by).\n///\n/// Returns the remainder of the division. If `other` is 0, the behavior is\n/// undefined.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(7 % 3, content=\"1\")\n///   inspect(-7 % 3, content=\"-1\")\n///   inspect(7 % -3, content=\"1\")\n/// ```\npub impl Mod for Int with op_mod(self, other) = \"%i32_mod\"\n\n///|\n/// Performs a bitwise NOT operation on a 32-bit integer. Flips each bit in the\n/// integer's binary representation (0 becomes 1 and 1 becomes 0).\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit integer on which to perform the bitwise NOT operation.\n///\n/// Returns a new integer with all bits flipped from the input value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = -1 // All bits are 1\n///   let b = 0 // All bits are 0\n///   inspect(a.lnot(), content=\"0\")\n///   inspect(b.lnot(), content=\"-1\")\n/// ```\npub fn Int::lnot(self : Int) -> Int = \"%i32_lnot\"\n\n///|\n/// Performs a bitwise AND operation between two 32-bit integers. Each bit in the\n/// result is set to 1 only if the corresponding bits in both operands are 1.\n///\n/// Parameters:\n///\n/// * `self` : The first 32-bit integer operand.\n/// * `other` : The second 32-bit integer operand.\n///\n/// Returns the result of the bitwise AND operation. The resulting value has a\n/// bit set to 1 at each position where both input integers have a bit set to 1.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 0xF0 // 11110000\n///   let y = 0xAA // 10101010\n///   inspect(x & y, content=\"160\") // 10100000 = 160\n/// ```\npub fn Int::land(self : Int, other : Int) -> Int = \"%i32_land\"\n\n///|\n/// Performs a bitwise OR operation between two 32-bit integers. For each bit\n/// position, the result is 1 if at least one of the corresponding bits in either\n/// operand is 1.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer where each bit is set to 1 if at least one of the\n/// corresponding bits in either operand is 1, and 0 otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 0xF0F0 // 1111_0000_1111_0000\n///   let y = 0x0F0F // 0000_1111_0000_1111\n///   inspect(x | y, content=\"65535\") // 1111_1111_1111_1111 = 65535\n/// ```\npub fn Int::lor(self : Int, other : Int) -> Int = \"%i32_lor\"\n\n///|\n/// Performs a bitwise XOR operation between two integers.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer where each bit is set to 1 if the corresponding bits in\n/// the operands are different, and 0 if they are the same.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 0xF0F0 // 1111_0000_1111_0000\n///   let y = 0x0F0F // 0000_1111_0000_1111\n///   inspect(x ^ y, content=\"65535\") // 1111_1111_1111_1111\n///   inspect(x ^ x, content=\"0\") // XOR with self gives 0\n/// ```\npub fn Int::lxor(self : Int, other : Int) -> Int = \"%i32_lxor\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts each bit in the\n/// integer to the left by the specified number of positions, filling the\n/// rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift. Must be a non-negative value\n/// less than 32. Values outside this range will be masked with `& 31`.\n///\n/// Returns a new integer with bits shifted left by the specified number of\n/// positions. For each position shifted, the rightmost bit is filled with 0, and\n/// the leftmost bit is discarded.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = -4\n///   inspect(y << 2, content=\"-16\") // Binary: 100 -> 10000\n/// ```\npub impl Shl for Int with op_shl(self, other) = \"%i32_shl\"\n\n///|\n/// Performs an arithmetic right shift operation on an integer value. Shifts the\n/// bits of the first operand to the right by the number of positions specified\n/// by the second operand. The sign bit is preserved and copied to the leftmost\n/// positions.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift the bits to the right. Must be\n/// non-negative.\n///\n/// Returns an integer representing the result of the arithmetic right shift\n/// operation.\n///\n/// Example:\n///\n/// ```moonbit\n///   let n = -16\n///   inspect(n >> 2, content=\"-4\") // Sign bit is preserved during shift\n///   let p = 16\n///   inspect(p >> 2, content=\"4\") // Regular right shift for positive numbers\n/// ```\npub impl Shr for Int with op_shr(self, other) = \"%i32_shr\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts each bit in the\n/// integer to the left by the specified number of positions, filling the vacated\n/// bit positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift the bits to the left.\n///\n/// Returns an integer containing the result of shifting `self` left by `shift`\n/// positions.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = 42\n///   inspect(y << 2, content=\"168\") // Binary: 101010 -> 10101000\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int::lsl(self : Int, other : Int) -> Int = \"%i32_shl\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts the bits of the\n/// first operand to the left by the specified number of positions. The rightmost\n/// positions are filled with zeros.\n///\n/// Parameters:\n///\n/// * `value` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift left. Must be non-negative and\n/// less than 32.\n///\n/// Returns a new integer value after performing the left shift operation. The\n/// value is equal to multiplying the input by 2 raised to the power of the shift\n/// count.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Equivalent to x << 3\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int::shl(self : Int, other : Int) -> Int = \"%i32_shl\"\n\n///|\n/// Performs a logical right shift operation on a signed 32-bit integer. In a\n/// logical right shift, zeros are shifted in from the left, regardless of the\n/// sign bit. This function is DEPRECATED and users should use `UInt` type with\n/// the infix operator `>>` instead.\n///\n/// Parameters:\n///\n/// * `self` : The signed 32-bit integer value to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a signed 32-bit integer containing the same bits as if the input were\n/// treated as an unsigned integer and shifted right logically.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = -4 // Binary: 11111...11100\n///   let unsigned = x.reinterpret_as_uint() // Convert to UInt first\n///   inspect(unsigned >> 1, content=\"2147483646\") // Using the recommended operator\n/// ```\n///\n#deprecated(\"Use UInt type and infix operator `>>` instead\")\n#coverage.skip\npub fn Int::lsr(self : Int, other : Int) -> Int {\n  (self.reinterpret_as_uint() >> other).reinterpret_as_int()\n}\n\n///|\n/// Performs an arithmetic right shift operation on a 32-bit integer value,\n/// preserving the sign bit by replicating it into the positions vacated by the\n/// shift. This is a deprecated function; use the infix operator `>>` instead.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new integer value that is the result of arithmetically shifting\n/// `self` right by `shift` positions.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = -16\n///   inspect(x >> 2, content=\"-4\") // Right shift preserves sign bit\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int::asr(self : Int, other : Int) -> Int = \"%i32_shr\"\n\n///|\n/// Performs an arithmetic right shift operation on a 32-bit integer by the\n/// specified number of positions. The operation preserves the sign bit,\n/// replicating it into the positions vacated by the shift.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift right.\n///\n/// Returns a new integer representing the result of shifting `self` right by\n/// `shift` positions.\n///\n/// Example:\n///\n/// ```moonbit\n///   let n = -1024\n///   inspect(n >> 3, content=\"-128\") // Preserves sign bit during right shift\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int::shr(self : Int, other : Int) -> Int = \"%i32_shr\"\n\n///|\n/// Counts the number of consecutive zero bits at the least significant end of\n/// the integer's binary representation.\n///\n/// Parameters:\n///\n/// * `self` : The integer value whose trailing zeros are to be counted.\n///\n/// Returns the number of trailing zero bits (0 to 32). For example, returns 0 if\n/// the value is odd (least significant bit is 1), returns 32 if the value is 0\n/// (all bits are zeros).\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 0\n///   inspect(x.ctz(), content=\"32\") // All bits are zero\n///   let y = 1\n///   inspect(y.ctz(), content=\"0\") // No trailing zeros\n///   let z = 16\n///   inspect(z.ctz(), content=\"4\") // Binary: ...10000\n/// ```\npub fn Int::ctz(self : Int) -> Int = \"%i32_ctz\"\n\n///|\npub fn Int::clz(self : Int) -> Int = \"%i32_clz\"\n\n///|\n/// Counts the number of set bits (1s) in the binary representation of a 32-bit\n/// integer.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer whose bits are to be counted.\n///\n/// Returns the number of bits set to 1 in the binary representation of the input\n/// integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 0b1011 // Binary: 1011 (3 bits set)\n///   inspect(x.popcnt(), content=\"3\")\n///   let y = -1 // All bits set in two's complement\n///   inspect(y.popcnt(), content=\"32\")\n/// ```\npub fn Int::popcnt(self : Int) -> Int = \"%i32_popcnt\"\n\n///|\n/// Compares two integers for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare.\n///\n/// Returns `true` if both integers have the same value, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(42 == 42, content=\"true\")\n///   inspect(42 == -42, content=\"false\")\n/// ```\npub impl Eq for Int with op_equal(self : Int, other : Int) -> Bool = \"%i32_eq\"\n\n///|\n/// Compares two integers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 42\n///   let b = 24\n///   inspect(a.compare(b), content=\"1\") // 42 > 24\n///   inspect(b.compare(a), content=\"-1\") // 24 < 42\n///   inspect(a.compare(a), content=\"0\") // 42 = 42\n/// ```\npub impl Compare for Int with compare(self, other) = \"%i32_compare\"\n\n///|\npub fn Int::is_pos(self : Int) -> Bool = \"%i32_is_pos\"\n\n///|\n/// Tests whether an integer is negative.\n///\n/// Parameters:\n///\n/// * `self` : The integer to test.\n///\n/// Returns `true` if the integer is negative, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let neg = -42\n///   let zero = 0\n///   let pos = 42\n///   inspect(neg.is_neg(), content=\"true\")\n///   inspect(zero.is_neg(), content=\"false\")\n///   inspect(pos.is_neg(), content=\"false\")\n/// ```\npub fn Int::is_neg(self : Int) -> Bool = \"%i32_is_neg\"\n\n///|\npub fn Int::is_non_pos(self : Int) -> Bool = \"%i32_is_non_pos\"\n\n///|\npub fn Int::is_non_neg(self : Int) -> Bool = \"%i32_is_non_neg\"\n\n///|\n/// Returns the default value for integers, which is 0.\n///\n/// Returns an integer value of 0.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x : Int = Int::default()\n///   inspect(x, content=\"0\")\n/// ```\npub impl Default for Int with default() = \"%i32_default\"\n\n///|\n/// Converts a 32-bit integer to a double-precision floating-point number. The\n/// conversion preserves the exact value since all integers in the range of `Int`\n/// can be represented exactly as `Double` values.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that represents the same\n/// numerical value as the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let n = 42\n///   inspect(n.to_double(), content=\"42\")\n///   let neg = -42\n///   inspect(neg.to_double(), content=\"-42\")\n/// ```\npub fn Int::to_double(self : Int) -> Double = \"%i32_to_f64\"\n\n///|\n/// Converts a double-precision floating-point number to an unsigned 32-bit\n/// integer by truncating the decimal part. When the input is NaN or negative,\n/// returns 0. When the input exceeds the maximum value of UInt (4294967295),\n/// returns 4294967295.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the truncated value.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(UInt::trunc_double(42.75), content=\"42\")\n/// ```\npub fn UInt::trunc_double(val : Double) -> UInt = \"%f64.to_u32\"\n\n///|\n/// reinterpret the signed int as unsigned int, when the value is\n/// non-negative, i.e, 0..=2^31-1, the value is the same. When the\n/// value is negative, it turns into a large number,\n/// for example, -1 turns into 2^32-1\npub fn Int::reinterpret_as_uint(self : Int) -> UInt = \"%i32.to_u32_reinterpret\"\n\n///|\n/// Reinterprets a signed 32-bit integer as an unsigned 32-bit integer. For\n/// numbers within the range \\[0, 2^31-1], the value remains the same. For\n/// negative numbers, they are reinterpreted as large positive numbers in the\n/// range \\[2^31, 2^32-1].\n///\n/// Parameters:\n///\n/// * `value` : The signed 32-bit integer to be reinterpreted.\n///\n/// Returns an unsigned 32-bit integer that has the same bit pattern as the\n/// input.\n///\n/// Example:\n///\n/// ```moonbit\n///   let pos = 42\n///   let neg = -1\n///   inspect(pos.reinterpret_as_uint(), content=\"42\")\n///   inspect(neg.reinterpret_as_uint(), content=\"4294967295\") // 2^32 - 1\n/// ```\n///\n#deprecated(\"Use `reinterpret_as_uint` instead\")\n#coverage.skip\npub fn Int::to_uint(self : Int) -> UInt = \"%i32.to_u32_reinterpret\"\n// Double primitive ops\n\n///|\n/// Converts a 32-bit signed integer to an unsigned 64-bit integer by first\n/// converting it to a signed 64-bit integer and then reinterpreting the bits as\n/// an unsigned value.\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit signed integer to be converted.\n///\n/// Returns an unsigned 64-bit integer representing the same bit pattern as the\n/// input value when extended to 64 bits.\n///\n/// Example:\n///\n/// ```moonbit\n///   let pos = 42\n///   inspect(pos.to_uint64(), content=\"42\")\n///   let neg = -1\n///   inspect(neg.to_uint64(), content=\"18446744073709551615\") // 2^64 - 1\n/// ```\npub fn Int::to_uint64(self : Int) -> UInt64 {\n  self.to_int64().reinterpret_as_uint64()\n}\n\n///|\n/// Negates a double-precision floating-point number. For non-NaN inputs, changes\n/// the sign of the number. For NaN inputs, returns NaN.\n///\n/// Parameters:\n///\n/// * `number` : The double-precision floating-point number to negate.\n///\n/// Returns a new double-precision floating-point number that is the negation of\n/// the input number.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(-42.0, content=\"-42\")\n///   inspect(--42.0, content=\"42\")\n///   inspect(-(0.0 / 0.0), content=\"NaN\") // Negating NaN returns NaN\n/// ```\npub impl Neg for Double with op_neg(self) = \"%f64_neg\"\n\n///|\n/// Adds two double-precision floating-point numbers together following IEEE 754\n/// standards.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number.\n/// * `other` : The second double-precision floating-point number to add.\n///\n/// Returns the sum of the two numbers. Special cases follow IEEE 754 rules:\n///\n/// * If either operand is NaN, returns NaN\n/// * If adding +∞ and -∞, returns NaN\n/// * If adding ±∞ with any finite number, returns ±∞\n/// * If adding +0.0 and -0.0, returns +0.0\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(2.5 + 3.7, content=\"6.2\")\n///   inspect(1.0 / 0.0 + -1.0 / 0.0, content=\"NaN\") // Infinity + -Infinity = NaN\n/// ```\npub impl Add for Double with op_add(self, other) = \"%f64_add\"\n\n///|\n/// Performs subtraction between two double-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first operand (minuend).\n/// * `other` : The second operand (subtrahend).\n///\n/// Returns the difference between the two numbers according to IEEE 754\n/// double-precision arithmetic rules.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 5.0\n///   let b = 3.0\n///   inspect(a - b, content=\"2\")\n///   inspect(0.0 / 0.0 - 1.0, content=\"NaN\") // NaN - anything = NaN\n/// ```\npub impl Sub for Double with op_sub(self, other) = \"%f64_sub\"\n\n///|\n/// Multiplies two double-precision floating-point numbers. This is the\n/// implementation of the `*` operator for `Double` type.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point operand.\n/// * `other` : The second double-precision floating-point operand.\n///\n/// Returns a new double-precision floating-point number representing the product\n/// of the two operands. Special cases follow IEEE 754 standard:\n///\n/// * If either operand is NaN, returns NaN\n/// * If one operand is infinity and the other is zero, returns NaN\n/// * If one operand is infinity and the other is a non-zero finite number,\n/// returns infinity with the appropriate sign\n/// * If both operands are infinity, returns infinity with the appropriate sign\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(2.5 * 2.0, content=\"5\")\n///   inspect(-2.0 * 3.0, content=\"-6\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect(nan * 1.0, content=\"NaN\")\n/// ```\npub impl Mul for Double with op_mul(self, other) = \"%f64_mul\"\n\n///|\n/// Performs division between two double-precision floating-point numbers.\n/// Follows IEEE 754 standard for floating-point arithmetic, including handling\n/// of special cases like division by zero (returns infinity) and operations\n/// involving NaN.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (numerator) in the division operation.\n/// * `other` : The divisor (denominator) in the division operation.\n///\n/// Returns the result of dividing `self` by `other`. Special cases follow IEEE\n/// 754:\n///\n/// * Division by zero returns positive or negative infinity based on the\n/// dividend's sign\n/// * Operations involving NaN return NaN\n/// * Division of infinity by infinity returns NaN\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(6.0 / 2.0, content=\"3\")\n///   inspect(-6.0 / 2.0, content=\"-3\")\n///   inspect(1.0 / 0.0, content=\"Infinity\")\n/// ```\npub impl Div for Double with op_div(self, other) = \"%f64_div\"\n\n///|\n/// Calculates the square root of a double-precision floating-point number. For\n/// non-negative numbers, returns the positive square root. For negative numbers\n/// or NaN, returns NaN.\n///\n/// Parameters:\n///\n/// * `self` : The double-precision floating-point number whose square root is to\n/// be calculated.\n///\n/// Returns the square root of the input number, or NaN if the input is negative\n/// or NaN.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(4.0.sqrt(), content=\"2\")\n///   inspect(0.0.sqrt(), content=\"0\")\n///   inspect((-1.0).sqrt(), content=\"NaN\")\n/// ```\npub fn Double::sqrt(self : Double) -> Double = \"%f64_sqrt\"\n\n///|\n/// Compares two double-precision floating-point numbers for equality following\n/// IEEE 754 rules. Returns `true` if both numbers are equal, including when both\n/// are `NaN`. Note that this differs from the standard IEEE 754 behavior where\n/// `NaN` is not equal to any value, including itself.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare.\n///\n/// Returns `true` if both numbers are equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 3.14\n///   let b = 3.14\n///   let c = 2.718\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect(nan == nan, content=\"false\") // Note: NaN equals itself in MoonBit\n/// ```\npub impl Eq for Double with op_equal(self : Double, other : Double) -> Bool = \"%f64_eq\"\n\n///|\n/// Tests for inequality between two double-precision floating-point numbers.\n/// Takes into account special cases like NaN, where two NaN values are\n/// considered not equal to each other.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare.\n///\n/// Returns `true` if the two numbers are not equal according to IEEE 754 rules,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(1.0 != 2.0, content=\"true\")\n///   inspect(1.0 != 1.0, content=\"false\")\n///   inspect(0.0 / 0.0 != 0.0 / 0.0, content=\"true\") // NaN != NaN\n/// ```\npub fn Double::op_neq(self : Double, other : Double) -> Bool = \"%f64_ne\"\n\n///|\n/// Compares two double-precision floating-point numbers and returns their\n/// relative order. Follows IEEE 754 rules for floating-point comparisons,\n/// including handling of special values like NaN.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare\n/// against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n/// * If either value is NaN, returns an implementation-defined value that is\n/// consistent with total ordering\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 3.14\n///   let b = 2.718\n///   inspect(a.compare(b), content=\"1\") // 3.14 > 2.718\n///   inspect(b.compare(a), content=\"-1\") // 2.718 < 3.14\n///   inspect(a.compare(a), content=\"0\") // 3.14 = 3.14\n/// ```\npub impl Compare for Double with compare(self, other) = \"%f64_compare\"\n\n///|\n/// Returns the default value for double-precision floating-point numbers (0.0).\n///\n/// Returns a `Double` value initialized to 0.0.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(Double::default(), content=\"0\")\n/// ```\npub impl Default for Double with default() = \"%f64_default\"\n\n///|\n/// Converts an unsigned 32-bit integer to a double-precision floating-point\n/// number. Since the range of unsigned 32-bit integers is smaller than what can\n/// be precisely represented by a double-precision floating-point number, this\n/// conversion is guaranteed to be exact.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that exactly represents the\n/// input value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let n = 42U\n///   inspect(Double::convert_uint(n), content=\"42\")\n///   let max = 4294967295U // maximum value of UInt\n///   inspect(Double::convert_uint(max), content=\"4294967295\")\n/// ```\npub fn Double::convert_uint(val : UInt) -> Double = \"%u32.to_f64\"\n\n// Char primitive ops\n\n///|\n/// Converts a character to its Unicode code point value as an integer.\n///\n/// Parameters:\n///\n/// * `self` : The character to be converted.\n///\n/// Returns an integer representing the Unicode code point value of the\n/// character.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect('A'.to_int(), content=\"65\") // ASCII value of 'A'\n///   inspect('あ'.to_int(), content=\"12354\") // Unicode code point of 'あ'\n/// ```\npub fn Char::to_int(self : Char) -> Int = \"%char_to_int\"\n\n///|\n/// Converts a Unicode character to its unsigned 32-bit integer code point\n/// representation. The character's code point value is first converted to a\n/// signed integer and then reinterpreted as an unsigned integer.\n///\n/// Parameters:\n///\n/// * `character` : The Unicode character to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the character's Unicode code\n/// point.\n///\n/// Example:\n///\n/// ```moonbit\n///   let c = 'A'\n///   inspect(c.to_uint(), content=\"65\") // ASCII value of 'A'\n///   let emoji = '🤣'\n///   inspect(emoji.to_uint(), content=\"129315\") // Unicode code point U+1F923\n/// ```\npub fn Char::to_uint(self : Char) -> UInt {\n  self.to_int().reinterpret_as_uint()\n}\n\n///|\n#deprecated(\"Use `Int::unsafe_to_char` instead, and use `Int::to_char` for safe conversion\")\npub fn Char::from_int(val : Int) -> Char = \"%char_from_int\"\n\n///|\n/// Compares two characters for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare.\n///\n/// Returns `true` if both characters represent the same Unicode code point,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 'A'\n///   let b = 'A'\n///   let c = 'B'\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n/// ```\npub impl Eq for Char with op_equal(self : Char, other : Char) -> Bool = \"%char_eq\"\n\n///|\n/// Compares two characters based on their Unicode code points. Returns a\n/// negative value if the first character comes before the second, zero if they\n/// are equal, and a positive value if the first character comes after the\n/// second.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare against.\n///\n/// Returns an integer indicating the relative ordering:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect('a'.compare('b'), content=\"-1\")\n///   inspect('b'.compare('a'), content=\"1\")\n///   inspect('a'.compare('a'), content=\"0\")\n/// ```\npub impl Compare for Char with compare(self, other) = \"%char_compare\"\n\n///|\n/// Returns the default value for the `Char` type, which is the null character\n/// (`'\\x00'`).\n///\n/// Returns a `Char` value representing the null character.\n///\n/// Example:\n///\n/// ```moonbit\n///   assert_true(Char::default().to_string() == \"\\u0000\")\n/// ```\npub impl Default for Char with default() = \"%char_default\"\n\n// Bytes primitive ops\n\n///|\n/// Retrieves a byte at the specified index from a byte sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence to access.\n/// * `index` : The position in the byte sequence from which to retrieve the\n/// byte.\n///\n/// Returns a byte value from the specified position in the sequence.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the byte sequence.\n///\n/// Example:\n///\n/// ```moonbit\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes[1], content=\"b'\\\\x02'\")\n/// ```\npub fn Bytes::op_get(self : Bytes, idx : Int) -> Byte = \"%bytes_get\"\n\n///|\n/// Retrieves a byte at the specified index from a byte sequence without\n/// performing bounds checking. This is a low-level operation that should be used\n/// with caution.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence to retrieve the byte from.\n/// * `index` : The position in the byte sequence from which to retrieve the\n/// byte.\n///\n/// Returns a single byte from the specified position in the byte sequence.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the byte sequence.\n///\n/// Example:\n///\n/// ```moonbit\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes.unsafe_get(1), content=\"b'\\\\x02'\")\n/// ```\n///\n#internal(unsafe, \"Panic if index is out of bounds\")\npub fn Bytes::unsafe_get(self : Bytes, idx : Int) -> Byte = \"%bytes.unsafe_get\"\n\n///|\n/// Returns the number of bytes in a byte sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence whose length is to be determined.\n///\n/// Returns an integer representing the length (number of bytes) of the sequence.\n///\n/// Example:\n///\n/// ```moonbit\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes.length(), content=\"3\")\n///   let empty = b\"\"\n///   inspect(empty.length(), content=\"0\")\n/// ```\npub fn Bytes::length(self : Bytes) -> Int = \"%bytes_length\"\n\n///|\n/// Creates a new byte sequence of the specified length, where each byte is\n/// initialized to the given value. Returns an empty byte sequence if the\n/// length is negative.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. Must be non-negative.\n/// * `initial_value` : The byte value used to initialize each position in the\n/// sequence.\n///\n/// Example:\n///\n/// ```moonbit\n///   let bytes = Bytes::make(3, b'\\xFF')\n///   inspect(\n///     bytes, \n///     content=(\n///       #|b\"\\xff\\xff\\xff\"\n///     ),\n///   )\n///   let empty = Bytes::make(0, b'\\x00')\n///   inspect(empty, content=\"b\\\"\\\"\")\n/// ```\npub fn Bytes::make(len : Int, init : Byte) -> Bytes {\n  if len < 0 {\n    return []\n  }\n  Bytes::unsafe_make(len, init)\n}\n\n///|\nfn Bytes::unsafe_make(len : Int, init : Byte) -> Bytes = \"%bytes_make\"\n\n///|\n/// Creates a new byte sequence filled with zero bytes.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. Must be a\n/// non-negative integer.\n///\n/// Returns a new byte sequence of the specified length, with all bytes\n/// initialized to zero.\n///\n/// Example:\n///\n/// ```moonbit\n///   let bytes = Bytes::new(3)\n///   inspect(bytes, content=\"b\\\"\\\\x00\\\\x00\\\\x00\\\"\")\n///\n///   let bytes = Bytes::new(0)\n///   inspect(bytes, content=\"b\\\"\\\"\")\n/// ```\npub fn Bytes::new(len : Int) -> Bytes {\n  Bytes::make(len, b'\\x00')\n}\n\n///|\n/// Converts a 32-bit signed integer to a byte by taking its least significant 8\n/// bits. Any bits beyond the first 8 bits are truncated.\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit signed integer to be converted. Only the least\n/// significant 8 bits will be used.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let n = 258 // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n///   let neg = -1 // In binary: all 1's\n///   inspect(neg.to_byte(), content=\"b'\\\\xFF'\") // Only keeps 11111111\n/// ```\npub fn Int::to_byte(self : Int) -> Byte = \"%i32_to_byte\"\n\n///|\npub fn Int::unsafe_to_char(self : Int) -> Char = \"%char_from_int\"\n\n///|\npub fn Int::to_char(self : Int) -> Char? {\n  if self is (0..=0xD7FF) || self is (0xE000..=0x10FFFF) {\n    Some(self.unsafe_to_char())\n  } else {\n    None\n  }\n}\n\n///|\n/// Converts an unsigned 64-bit integer to a byte by truncating it to fit within\n/// the byte range (0 to 255).\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer to be converted.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let n = 258UL // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n/// ```\npub fn UInt64::to_byte(self : UInt64) -> Byte {\n  self.to_int().to_byte()\n}\n\n// FixedArray primitive ops\n\n///|\n/// Retrieves an element at the specified index from a fixed-size array. This\n/// function implements the array indexing operator `[]`.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to access.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (negative or greater\n/// than or equal to the length of the array).\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr[1], content=\"42\")\n/// ```\npub fn[T] FixedArray::op_get(self : FixedArray[T], idx : Int) -> T = \"%fixedarray.get\"\n\n///|\n/// Retrieves an element from a fixed-size array at the specified index without\n/// performing bounds checking. This is an unsafe operation that may cause\n/// undefined behavior if used incorrectly.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to retrieve the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index in the array.\n///\n/// Throws a panic if the index is out of bounds (negative or greater than or\n/// equal to the array's length).\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr.unsafe_get(1), content=\"42\")\n/// ```\n///\n#internal(unsafe, \"Panic if index is out of bounds\")\npub fn[T] FixedArray::unsafe_get(self : FixedArray[T], idx : Int) -> T = \"%fixedarray.unsafe_get\"\n\n///|\n#internal(unsafe, \"Panic if index is out of bounds\")\npub fn[T] FixedArray::unsafe_set(\n  self : FixedArray[T],\n  idx : Int,\n  val : T,\n) -> Unit = \"%fixedarray.unsafe_set\"\n\n///|\n/// Sets a value at the specified index in a fixed-size array. The original value\n/// at that index is overwritten.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to modify.\n/// * `index` : The position in the array where the value will be set.\n/// * `value` : The new value to assign at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (less than 0 or greater\n/// than or equal to the length of the array).\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   arr[1] = 42\n///   inspect(arr, content=\"[1, 42, 3]\")\n/// ```\n///\n#intrinsic(\"%fixedarray.set\")\npub fn[T] FixedArray::op_set(self : FixedArray[T], idx : Int, val : T) -> Unit = \"%fixedarray.set\"\n\n///|\n/// Sets the value at the specified index in a fixed-size array.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to be modified.\n/// * `index` : The index at which to set the value. Must be non-negative and\n/// less than the array's length.\n/// * `value` : The value to be set at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (less than 0 or greater\n/// than or equal to the array's length).\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = FixedArray::make(3, 0)\n///   arr.set(1, 42)\n///   inspect(arr[1], content=\"42\")\n/// ```\npub fn[T] FixedArray::set(self : FixedArray[T], idx : Int, val : T) -> Unit = \"%fixedarray.set\"\n\n///|\n/// Returns the number of elements in a fixed-size array.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array whose length is to be determined.\n///\n/// Returns an integer representing the number of elements in the array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr.length(), content=\"3\")\n/// ```\npub fn[T] FixedArray::length(self : FixedArray[T]) -> Int = \"%fixedarray.length\"\n\n///|\n/// Creates a new fixed-size array with the specified length, initializing all\n/// elements with the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be non-negative.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new fixed-size array of type `FixedArray[T]` with `length`\n/// elements, where each element is initialized to `initial_value`.\n///\n/// Throws a panic if `length` is negative.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr[0], content=\"42\")\n///   inspect(arr.length(), content=\"3\")\n/// ```\n/// \n/// WARNING: A common pitfall is creating with the same initial value, for example:\n/// ```moonbit\n///   let two_dimension_array = FixedArray::make(10, FixedArray::make(10, 0))\n///   two_dimension_array[0][5] = 10\n///   assert_eq(two_dimension_array[5][5], 10)\n/// ```\n/// This is because all the cells reference to the same object (the FixedArray[Int] in this case). \n/// One should use makei() instead which creates an object for each index.\npub fn[T] FixedArray::make(len : Int, init : T) -> FixedArray[T] = \"%fixedarray.make\"\n\n// String primitive ops\n\n///|\n/// Returns the number of UTF-16 code units in the string. Note that this is not\n/// necessarily equal to the number of Unicode characters (code points) in the\n/// string, as some characters may be represented by multiple UTF-16 code units.\n///\n/// Parameters:\n///\n/// * `string` : The string whose length is to be determined.\n///\n/// Returns the number of UTF-16 code units in the string.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(\"hello\".length(), content=\"5\")\n///   inspect(\"🤣\".length(), content=\"2\") // Emoji uses two UTF-16 code units\n///   inspect(\"\".length(), content=\"0\") // Empty string\n/// ```\npub fn String::length(self : String) -> Int = \"%string_length\"\n\n///|\n#deprecated(\"use `length` instead\")\npub fn String::charcode_length(self : String) -> Int = \"%string_length\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n///\n/// Parameters:\n///\n/// * `string` : The string to access.\n/// * `index` : The position in the string from which to retrieve the code unit.\n///\n/// This method has O(1) complexity.\npub fn String::op_get(self : String, idx : Int) -> Int = \"%string_get\"\n\n///|\n/// Returns the UTF-16 code unit at a given position in the string without\n/// performing bounds checking. This is a low-level function that provides direct\n/// access to the internal representation of the string.\n///\n/// Parameters:\n///\n/// * `string` : The string from which to retrieve the code unit.\n/// * `index` : The position of the code unit to retrieve.\n///\n/// Returns the UTF-16 code unit at the specified position as an integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let str = \"B🤣🤣C\"\n///   inspect(str.unsafe_charcode_at(0), content=\"66\") // 'B'\n///   inspect(str.unsafe_charcode_at(1), content=\"55358\") // First surrogate of 🤣\n///   inspect(str.unsafe_charcode_at(2), content=\"56611\") // Second surrogate of 🤣\n///   inspect(str.unsafe_charcode_at(3), content=\"55358\") // First surrogate of 🤣\n///   inspect(str.unsafe_charcode_at(4), content=\"56611\") // Second surrogate of 🤣\n///   inspect(str.unsafe_charcode_at(5), content=\"67\") // 'C'\n/// ```\n/// TODO: rename to `unsafe_get`\n#internal(unsafe, \"Panic if index is out of bounds.\")\npub fn String::unsafe_charcode_at(self : String, idx : Int) -> Int = \"%string.unsafe_get\"\n\n///|\n/// Concatenates two strings, creating a new string that contains all characters\n/// from the first string followed by all characters from the second string.\n///\n/// Parameters:\n///\n/// * `self` : The first string to concatenate.\n/// * `other` : The second string to concatenate.\n///\n/// Returns a new string containing the concatenation of both input strings.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hello = \"Hello\"\n///   let world = \" World!\"\n///   inspect(hello + world, content=\"Hello World!\")\n///   inspect(\"\" + \"abc\", content=\"abc\") // concatenating with empty string\n/// ```\npub impl Add for String with op_add(self, other) = \"%string_add\"\n\n///|\n/// Tests whether two strings are equal by comparing their characters.\n///\n/// Parameters:\n///\n/// * `self` : The first string to compare.\n/// * `other` : The second string to compare.\n///\n/// Returns `true` if both strings contain exactly the same sequence of\n/// characters, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let str1 = \"hello\"\n///   let str2 = \"hello\"\n///   let str3 = \"world\"\n///   inspect(str1 == str2, content=\"true\")\n///   inspect(str1 == str3, content=\"false\")\n/// ```\npub impl Eq for String with op_equal(self : String, other : String) -> Bool = \"%string_eq\"\n\n///|\n/// Returns the string itself without any modifications. This method is primarily\n/// used to implement the `Show` trait, which requires a `to_string` function.\n///\n/// Parameters:\n///\n/// * `string` : The string value to be returned.\n///\n/// Returns the same string that was passed in.\n///\n/// Example:\n///\n/// ```moonbit\n///   let s = \"hello\"\n///   inspect(s.to_string(), content=\"hello\")\n/// ```\npub fn String::to_string(self : String) -> String = \"%string_to_string\"\n\n///|\n// For internal use only\npriv type UnsafeMaybeUninit[_]\n\n///|\n/// Converts a byte value to a 32-bit signed integer. The resulting integer will\n/// have the same binary representation as the byte value, preserving the\n/// numerical value in the range \\[0, 255].\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to an integer.\n///\n/// Returns a 32-bit signed integer representing the same numerical value as the\n/// input byte.\n///\n/// Example:\n///\n/// ```moonbit\n///   let b = b'\\xFF' // byte with value 255\n///   inspect(b.to_int(), content=\"255\")\n///   let zero = b'\\x00'\n///   inspect(zero.to_int(), content=\"0\")\n/// ```\npub fn Byte::to_int(self : Byte) -> Int = \"%byte_to_int\"\n\n///|\n/// Converts a byte value to a character.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns the character corresponding to the byte value.\npub fn Byte::to_char(self : Byte) -> Char {\n  self.to_int().unsafe_to_char()\n}\n\n///|\n/// Converts a byte value to a 64-bit signed integer by first converting it to a\n/// 32-bit integer and then extending it to a 64-bit integer.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns a 64-bit signed integer representing the same numerical value as the\n/// input byte.\n///\n/// Example:\n///\n/// ```moonbit\n///   let b = b'\\xFF'\n///   inspect(b.to_int64(), content=\"255\")\n/// ```\npub fn Byte::to_int64(self : Byte) -> Int64 {\n  self.to_int().to_int64()\n}\n\n///|\n/// reinterpret the unsigned int as signed int\n/// For number within the range of 0..=2^31-1,\n/// the value is the same. For number within the range of 2^31..=2^32-1,\n/// the value is negative\npub fn UInt::reinterpret_as_int(self : UInt) -> Int = \"%u32.to_i32_reinterpret\"\n\n///|\n/// Reinterprets an unsigned 32-bit integer as a signed 32-bit integer. For\n/// values within the range of 0 to 2^31-1, the value remains the same. For\n/// values within the range of 2^31 to 2^32-1, the value becomes negative due to\n/// two's complement representation.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be reinterpreted.\n///\n/// Returns a signed 32-bit integer that has the same bit pattern as the input\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 42U\n///   inspect(a.reinterpret_as_int(), content=\"42\")\n///   let b = 4294967295U // maximum value of UInt (2^32 - 1)\n///   inspect(b.reinterpret_as_int(), content=\"-1\") // becomes -1 when reinterpreted as Int\n/// ```\n///\n#deprecated(\"Use `reinterpret_as_int` instead\")\n#coverage.skip\npub fn UInt::to_int(self : UInt) -> Int = \"%u32.to_i32_reinterpret\"\n\n///|\n/// Performs addition between two unsigned 32-bit integers. If the result\n/// overflows, it wraps around according to the rules of modular arithmetic\n/// (2^32).\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand to be added.\n///\n/// Returns the sum of the two unsigned integers, wrapped around if necessary.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 42U\n///   let b = 100U\n///   inspect(a + b, content=\"142\")\n///\n///   // Demonstrate overflow behavior\n///   let max = 4294967295U // UInt::max_value\n///   inspect(max + 1U, content=\"0\")\n/// ```\npub impl Add for UInt with op_add(self, other) = \"%u32.add\"\n\n///|\n/// Performs subtraction between two unsigned 32-bit integers. When the result\n/// would be negative, the function wraps around using modular arithmetic (2^32).\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer (minuend).\n/// * `other` : The second unsigned 32-bit integer to subtract from the first\n/// (subtrahend).\n///\n/// Returns a new unsigned 32-bit integer representing the difference between the\n/// two numbers. If the result would be negative, it wraps around to a positive\n/// number by adding 2^32 repeatedly until the result is in range.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 5U\n///   let b = 3U\n///   inspect(a - b, content=\"2\")\n///   let c = 3U\n///   let d = 5U\n///   inspect(c - d, content=\"4294967294\") // wraps around to 2^32 - 2\n/// ```\npub impl Sub for UInt with op_sub(self, other) = \"%u32.sub\"\n\n///|\n/// Performs multiplication between two unsigned 32-bit integers. The result\n/// wraps around if it exceeds the maximum value of `UInt`.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand.\n///\n/// Returns the product of the two unsigned integers. If the result exceeds the\n/// maximum value of `UInt` (4294967295), it wraps around to the corresponding\n/// value modulo 2^32.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 3U\n///   let b = 4U\n///   inspect(a * b, content=\"12\")\n///   let max = 4294967295U\n///   inspect(max * 2U, content=\"4294967294\") // Wraps around to max * 2 % 2^32\n/// ```\npub impl Mul for UInt with op_mul(self, other) = \"%u32.mul\"\n\n///|\n/// Performs division between two unsigned 32-bit integers. The operation follows\n/// standard unsigned integer division rules, where the result is truncated\n/// towards zero.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (the number to be divided).\n/// * `other` : The divisor (the number to divide by).\n///\n/// Returns an unsigned 32-bit integer representing the quotient of the division.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 42U\n///   let b = 5U\n///   inspect(a / b, content=\"8\") // Using infix operator\n/// ```\npub impl Div for UInt with op_div(self, other) = \"%u32.div\"\n\n///|\n/// Calculates the remainder of dividing one unsigned integer by another.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned integer dividend.\n/// * `other` : The unsigned integer divisor.\n///\n/// Returns the remainder of the division operation.\n///\n/// Throws a panic if `other` is zero.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 17U\n///   let b = 5U\n///   inspect(a % b, content=\"2\") // 17 divided by 5 gives quotient 3 and remainder 2\n///   inspect(7U % 4U, content=\"3\")\n/// ```\npub impl Mod for UInt with op_mod(self, other) = \"%u32.mod\"\n\n///|\n/// Compares two unsigned 32-bit integers for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand to compare with.\n///\n/// Returns `true` if both integers have the same value, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 42U\n///   let b = 42U\n///   let c = 24U\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n/// ```\npub impl Eq for UInt with op_equal(self : UInt, other : UInt) -> Bool = \"%u32.eq\"\n\n///|\n/// Checks if two unsigned 32-bit integers are not equal.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer to compare.\n/// * `other` : The second unsigned integer to compare.\n///\n/// Returns `true` if the two integers are not equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 42U\n///   let b = 24U\n///   inspect(a != b, content=\"true\")\n///   inspect(a != a, content=\"false\")\n/// ```\npub fn UInt::op_neq(self : UInt, other : UInt) -> Bool = \"%u32.ne\"\n\n///|\n/// Compares two unsigned 32-bit integers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer to compare.\n/// * `other` : The second unsigned integer to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 42U\n///   let b = 24U\n///   inspect(a.compare(b), content=\"1\") // 42 > 24\n///   inspect(b.compare(a), content=\"-1\") // 24 < 42\n///   inspect(a.compare(a), content=\"0\") // 42 = 42\n/// ```\npub impl Compare for UInt with compare(self, other) = \"%u32.compare\"\n\n///|\n/// Performs a bitwise AND operation between two unsigned 32-bit integers. For\n/// each bit position, the result is 1 if the bits at that position in both\n/// operands are 1, and 0 otherwise.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns an unsigned 32-bit integer representing the result of the bitwise AND\n/// operation.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 0xF0F0U // 1111_0000_1111_0000\n///   let b = 0xFF00U // 1111_1111_0000_0000\n///   inspect(a & b, content=\"61440\") // 1111_0000_0000_0000 = 61440\n/// ```\npub fn UInt::land(self : UInt, other : UInt) -> UInt = \"%u32.bitand\"\n\n///|\n/// Performs a bitwise OR operation between two unsigned 32-bit integers. For\n/// each bit position, the result is 1 if at least one of the corresponding bits\n/// in either operand is 1.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns the result of the bitwise OR operation as an unsigned 32-bit integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 0xF0F0U // Binary: 1111_0000_1111_0000\n///   let b = 0x0F0FU // Binary: 0000_1111_0000_1111\n///   inspect(a | b, content=\"65535\") // Binary: 1111_1111_1111_1111\n/// ```\npub fn UInt::lor(self : UInt, other : UInt) -> UInt = \"%u32.bitor\"\n\n///|\n/// Performs a bitwise XOR (exclusive OR) operation between two unsigned 32-bit\n/// integers. Each bit in the result is set to 1 if the corresponding bits in the\n/// operands are different, and 0 if they are the same.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns the result of the bitwise XOR operation.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 0xFF00U // Binary: 1111_1111_0000_0000\n///   let b = 0x0F0FU // Binary: 0000_1111_0000_1111\n///   inspect(a ^ b, content=\"61455\") // Binary: 1111_0000_0000_1111\n/// ```\npub fn UInt::lxor(self : UInt, other : UInt) -> UInt = \"%u32.bitxor\"\n\n///|\n/// Performs a bitwise NOT operation on an unsigned 32-bit integer. Flips all\n/// bits in the number (changes each 0 to 1 and each 1 to 0).\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer value on which to perform the bitwise\n/// NOT operation.\n///\n/// Returns a new unsigned 32-bit integer where each bit is inverted from the\n/// input value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 0xFF00U // Binary: 1111_1111_0000_0000\n///   inspect(x.lnot(), content=\"4294902015\") // Binary: ...0000_0000_1111_1111\n/// ```\npub fn UInt::lnot(self : UInt) -> UInt = \"%u32.bitnot\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Shifts each\n/// bit in the number to the left by the specified number of positions, filling\n/// the rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift the bits. Must be non-negative\n/// and less than 32. Values outside this range are wrapped to fit within it\n/// (i.e., `shift & 31`).\n///\n/// Returns a new `UInt` value representing the result of shifting the bits left\n/// by the specified number of positions. Each position shifted multiplies the\n/// number by 2.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Using the recommended operator\n///   let y = 8U\n///   inspect(y << 1, content=\"16\") // Using the recommended operator\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt::lsl(self : UInt, shift : Int) -> UInt = \"%u32.shl\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Shifts each\n/// bit in the integer to the left by the specified number of positions, filling\n/// the rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift left. Must be between 0 and 31\n/// inclusive. Values outside this range will be masked with `& 31`.\n///\n/// Returns a new `UInt` value containing the result of the left shift operation.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt::shl(self : UInt, shift : Int) -> UInt = \"%u32.shl\"\n\n///|\n/// Performs a logical right shift on an unsigned 32-bit integer. Each bit in the\n/// input value is shifted right by the specified number of positions, with zeros\n/// shifted in from the left. DEPRECATED: Use the `>>` operator instead.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new `UInt` value representing the result of the logical right shift\n/// operation.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 0xF0000000U\n///   inspect(x >> 4, content=\"251658240\") // Using the recommended operator\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt::lsr(self : UInt, shift : Int) -> UInt = \"%u32.shr\"\n\n///|\n/// Performs a logical right shift operation on an unsigned 32-bit integer by a\n/// specified number of positions. All bits shifted in from the left are zeros.\n///\n/// Parameters:\n///\n/// * `number` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new `UInt` value that represents the result of shifting all bits in\n/// `number` to the right by `shift` positions.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 0xFF000000U\n///   inspect(x >> 8, content=\"16711680\") // 0x00FF0000\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt::shr(self : UInt, shift : Int) -> UInt = \"%u32.shr\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Each bit in\n/// the integer is shifted left by the specified number of positions, and zeros\n/// are filled in from the right.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift. Only the least significant 5\n/// bits are used, effectively making the shift count always between 0 and 31.\n///\n/// Returns a new unsigned 32-bit integer that is the result of shifting `self`\n/// left by `shift` positions.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = 0xFFFFFFFFU\n///   inspect(y << 16, content=\"4294901760\") // All bits after position 16 are discarded\n/// ```\npub impl Shl for UInt with op_shl(self, shift) = \"%u32.shl\"\n\n///|\n/// Performs a logical right shift operation on an unsigned 32-bit integer. The\n/// operation shifts all bits to the right by a specified number of positions,\n/// filling the leftmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. If this value is\n/// negative, the behavior is undefined. Values larger than 31 are masked with `&\n/// 31`.\n///\n/// Returns a new unsigned 32-bit integer containing the result of the right\n/// shift operation.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 0xFF000000U\n///   inspect(x >> 8, content=\"16711680\") // 0x00FF0000\n///   inspect(x >> 24, content=\"255\") // 0x000000FF\n///\n///   let x = 0xFF000000U\n///   inspect(x >> 32, content=\"4278190080\") // Same as x >> 0 due to masking\n/// ```\npub impl Shr for UInt with op_shr(self, shift) = \"%u32.shr\"\n\n///|\n/// Counts the number of leading zero bits in an unsigned 32-bit integer,\n/// starting from the most significant bit.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer whose leading zeros are to be\n/// counted.\n///\n/// Returns the number of consecutive zeros starting from the most significant\n/// bit. For a zero value, returns 32.\n///\n/// Example:\n///\n/// ```moonbit\n///   inspect(0U.clz(), content=\"32\")\n///   inspect(1U.clz(), content=\"31\")\n///   inspect(0x80000000U.clz(), content=\"0\")\n/// ```\npub fn UInt::clz(self : UInt) -> Int = \"%u32.clz\"\n\n///|\n/// Counts the number of trailing zero bits in an unsigned 32-bit integer,\n/// starting from the least significant bit. For a zero input, returns 32.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose trailing zeros are to be\n/// counted.\n///\n/// Returns the number of consecutive zeros at the least significant end of the\n/// binary representation. Returns 32 if the input is zero.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 24U // Binary: ...011000\n///   inspect(x.ctz(), content=\"3\") // 3 trailing zeros\n///   let y = 0U\n///   inspect(y.ctz(), content=\"32\") // All bits are zero\n/// ```\npub fn UInt::ctz(self : UInt) -> Int = \"%u32.ctz\"\n\n///|\n/// Counts the number of 1 bits (population count) in the binary representation\n/// of an unsigned 32-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose bits are to be counted.\n///\n/// Returns an integer representing the count of set bits (1s) in the binary\n/// representation.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 0xF0F0U // Binary: 1111 0000 1111 0000\n///   inspect(x.popcnt(), content=\"8\") // Has 8 bits set to 1\n/// ```\npub fn UInt::popcnt(self : UInt) -> Int = \"%u32.popcnt\"\n\n///|\n/// Converts an unsigned 32-bit integer to an unsigned 64-bit integer by\n/// zero-extending it. The resulting value preserves the original number's\n/// magnitude while using 64 bits to represent it.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer (`UInt`) to be converted.\n///\n/// Returns an unsigned 64-bit integer (`UInt64`) representing the same numerical\n/// value as the input.\n///\n/// Example:\n///\n/// ```moonbit\n///   let n = 42U\n///   inspect(n.to_uint64(), content=\"42\")\n///   let max = 4294967295U // Maximum value of UInt\n///   inspect(max.to_uint64(), content=\"4294967295\")\n/// ```\npub fn UInt::to_uint64(self : UInt) -> UInt64 {\n  UInt64::extend_uint(self)\n}\n\n///|\n/// Converts an unsigned 32-bit integer to a byte by taking its least significant\n/// 8 bits. Any bits beyond the first 8 bits are truncated.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be converted. Only the least\n/// significant 8 bits will be used.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let n = 258U // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n///   let big = 4294967295U // Maximum value of UInt\n///   inspect(big.to_byte(), content=\"b'\\\\xFF'\") // Only keeps 11111111\n/// ```\npub fn UInt::to_byte(self : UInt) -> Byte {\n  self.reinterpret_as_int().to_byte()\n}\n\n///|\n/// Converts an unsigned 32-bit integer to a double-precision floating-point\n/// number. Since the range of unsigned 32-bit integers is smaller than what can\n/// be precisely represented by a double-precision floating-point number, this\n/// conversion is guaranteed to be exact.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that exactly represents the\n/// input value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let n = 42U\n///   inspect(n.to_double(), content=\"42\")\n///   let max = 4294967295U // maximum value of UInt\n///   inspect(max.to_double(), content=\"4294967295\")\n/// ```\npub fn UInt::to_double(self : UInt) -> Double = \"%u32.to_f64\"\n\n///|\n/// Performs unary negation on a 32-bit floating-point number. Returns the\n/// arithmetic inverse of the operand.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number to negate.\n///\n/// Returns a new floating-point number with the same magnitude but opposite sign\n/// as the input. Special cases:\n///\n/// * Negating NaN returns NaN\n/// * Negating +0.0 returns -0.0\n/// * Negating -0.0 returns +0.0\n/// * Negating +Infinity returns -Infinity\n/// * Negating -Infinity returns +Infinity\n///\n/// Example:\n///\n/// ```moonbit\n///   let f = 3.14.to_float()\n///   inspect((-f).to_double(), content=\"-3.140000104904175\")\n///   let zero = 0.0.to_float()\n///   inspect((-zero).to_double(), content=\"0\")\n/// ```\npub impl Neg for Float with op_neg(self) = \"%f32.neg\"\n\n///|\n/// Performs addition between two single-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point operand.\n/// * `other` : The second floating-point operand to be added to the first\n/// operand.\n///\n/// Returns a single-precision floating-point number representing the sum of the\n/// two operands.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 3.14.to_float()\n///   let b = 2.86.to_float()\n///   let sum = a + b\n///   inspect(sum.to_double(), content=\"6\")\n/// ```\npub impl Add for Float with op_add(self, other) = \"%f32.add\"\n\n///|\n/// Performs subtraction between two single-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number (minuend).\n/// * `other` : The second floating-point number (subtrahend).\n///\n/// Returns a new floating-point number representing the difference between\n/// `self` and `other`.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 3.14.to_float()\n///   let y = 1.0.to_float()\n///   let result = x - y\n///   inspect(result.to_double(), content=\"2.140000104904175\")\n/// ```\npub impl Sub for Float with op_sub(self, other) = \"%f32.sub\"\n\n///|\n/// Performs multiplication between two single-precision floating-point numbers\n/// according to IEEE 754 rules.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number operand.\n/// * `other` : The second floating-point number operand to multiply with the\n/// first.\n///\n/// Returns a single-precision floating-point number that is the product of the\n/// two operands.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = Int::to_float(2)\n///   let y = Int::to_float(3)\n///   let z = x * y\n///   inspect(z.to_double(), content=\"6\")\n/// ```\npub impl Mul for Float with op_mul(self, other) = \"%f32.mul\"\n\n///|\n/// Performs division between two 32-bit floating-point numbers according to IEEE\n/// 754 rules.\n///\n/// Parameters:\n///\n/// * `self` : The dividend floating-point number.\n/// * `other` : The divisor floating-point number.\n///\n/// Returns a new floating-point number representing the quotient of the\n/// division. Special cases follow IEEE 754 rules:\n///\n/// * Division by zero returns infinity (with the appropriate sign)\n/// * Division of zero by zero returns NaN\n/// * Division of infinity by infinity returns NaN\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 6.0.to_float()\n///   let b = 2.0.to_float()\n///   let result = (a / b).to_double()\n///   inspect(result, content=\"3\")\n///   inspect((0.0.to_float() / 0.0.to_float()).to_double(), content=\"NaN\")\n/// ```\npub impl Div for Float with op_div(self, other) = \"%f32.div\"\n\n///|\n/// Calculates the square root of a floating-point number. For non-negative\n/// numbers, returns the principal square root. For negative numbers or NaN,\n/// returns NaN.\n///\n/// Parameters:\n///\n/// * `self` : The floating-point number whose square root is to be calculated.\n///\n/// Returns a 32-bit floating-point number representing the square root of the\n/// input value:\n///\n/// * For a positive number, returns its principal square root\n/// * For zero (positive or negative), returns zero with the same sign\n/// * For NaN or negative numbers, returns NaN\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 16.0.to_float()\n///   let root = x.sqrt()\n///   inspect(root.to_double(), content=\"4\")\n///   let neg = (-4.0).to_float()\n///   let neg_root = neg.sqrt()\n///   inspect(neg_root.to_double(), content=\"NaN\")\n/// ```\npub fn Float::sqrt(self : Float) -> Float = \"%f32.sqrt\"\n\n///|\n/// Tests two floating-point numbers for equality. Follows IEEE 754 equality\n/// comparison rules, where NaN values are not equal to any value, including\n/// themselves.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n///\n/// Returns `true` if both numbers are equal, `false` otherwise. Note that `-0.0`\n/// and `+0.0` are considered equal.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 3.14\n///   let y = 3.14\n///   let z = 0.0 / 0.0 // NaN\n///   inspect(x == y, content=\"true\")\n///   inspect(z == z, content=\"false\") // NaN is not equal to itself\n/// ```\npub impl Eq for Float with op_equal(self : Float, other : Float) -> Bool = \"%f32.eq\"\n\n///|\n/// Tests if two single-precision floating-point numbers are not equal. This\n/// operation follows IEEE 754 rules for floating-point comparison, including\n/// special handling of NaN values.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n///\n/// Returns `true` if the two floating-point numbers are not equal, `false` if\n/// they are equal. Note that if either operand is NaN, the result is `true`.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 1.0.to_float()\n///   let y = 2.0.to_float()\n///   let nan = (0.0 / 0.0).to_float()\n///   inspect(x != y, content=\"true\")\n///   inspect(x != x, content=\"false\")\n///   inspect(nan != nan, content=\"true\") // NaN is not equal to itself\n/// ```\npub fn Float::op_neq(self : Float, other : Float) -> Bool = \"%f32.ne\"\n\n///|\n/// Compares two 32-bit floating-point numbers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first floating-point number to compare.\n/// * `other` : The second floating-point number to compare.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = 3.14\n///   let b = 2.718\n///   inspect(a.compare(b), content=\"1\") // 3.14 > 2.718\n///   inspect(b.compare(a), content=\"-1\") // 2.718 < 3.14\n///   inspect(a.compare(a), content=\"0\") // 3.14 = 3.14\n/// ```\npub impl Compare for Float with compare(self, other) = \"%f32.compare\"\n\n///|\n/// Converts a 32-bit floating-point number to a double-precision (64-bit)\n/// floating-point number.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit floating-point number to be converted.\n///\n/// Returns a double-precision floating-point number that preserves the exact\n/// value of the input. Since double-precision has more bits than\n/// single-precision, this conversion is always exact and never loses precision.\n///\n/// Example:\n///\n/// ```moonbit\n///   let f = 3.14.to_float()\n///   inspect(f.to_double(), content=\"3.140000104904175\")\n/// ```\npub fn Float::to_double(self : Float) -> Double = \"%f32.to_f64\"\n\n///|\n/// Reinterprets the bits of a 32-bit floating-point number as a 32-bit signed\n/// integer without performing any numeric conversion. The bit pattern is\n/// preserved exactly, only the type interpretation changes.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit floating-point number whose bits are to be\n/// reinterpreted.\n///\n/// Returns a 32-bit signed integer that has the same bit pattern as the input\n/// floating-point number.\n///\n/// Example:\n///\n/// ```moonbit\n///   let f = 1.0.to_float()\n///   // IEEE 754 representation of 1.0 is 0x3F800000\n///   inspect(f.reinterpret_as_int(), content=\"1065353216\")\n/// ```\npub fn Float::reinterpret_as_int(self : Float) -> Int = \"%f32.to_i32_reinterpret\"\n\n///|\n/// Reinterprets the bits of a 32-bit floating-point number as an unsigned 32-bit\n/// integer without performing any numeric conversion. Preserves the exact bit\n/// pattern of the input value, only changing how these bits are interpreted.\n///\n/// Parameters:\n///\n/// * `float` : The 32-bit floating-point number whose bits are to be\n/// reinterpreted.\n///\n/// Returns an unsigned 32-bit integer (`UInt`) that has the same bit pattern as\n/// the input floating-point number.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x : Float = 1.0\n///   inspect(x.reinterpret_as_uint(), content=\"1065353216\") // Decimal representation of 0x3F800000\n/// ```\npub fn Float::reinterpret_as_uint(self : Float) -> UInt = \"%f32.to_i32_reinterpret\"\n\n///|\n/// Converts an integer to a 32-bit floating-point number. The conversion is\n/// exact for small integers, but may lose precision for large integers due to\n/// the limited precision of the floating-point format.\n///\n/// Parameters:\n///\n/// * `number` : The integer value to be converted to a floating-point number.\n///\n/// Returns a 32-bit floating-point number representing the same value as the\n/// input integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let n = 42\n///   let f = n.to_float()\n///   // Convert back to double for comparison since Float doesn't implement Show\n///   inspect(f.to_double(), content=\"42\")\n/// ```\npub fn Int::to_float(self : Int) -> Float = \"%i32.to_f32\"\n\n///|\n/// Reinterprets the bits of a 32-bit integer as a single-precision\n/// floating-point number according to IEEE 754 standard. The bit pattern of the\n/// input is preserved, only the type interpretation changes.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer whose bits are to be reinterpreted as a\n/// single-precision floating-point number.\n///\n/// Returns a 32-bit floating-point number (`Float`) that has the same bit\n/// pattern as the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   // 0x3F800000 represents 1.0 in IEEE 754 single-precision format\n///   let n = 1065353216 // 0x3F800000\n///   inspect(n.reinterpret_as_float().to_double(), content=\"1\")\n/// ```\npub fn Int::reinterpret_as_float(self : Int) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n/// Reinterprets the bits of an unsigned 32-bit integer as a single-precision\n/// floating-point number (IEEE 754). The bit pattern is preserved exactly, only\n/// the type interpretation changes.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose bits are to be reinterpreted as\n/// a single-precision floating-point number.\n///\n/// Returns a single-precision floating-point number (`Float`) whose bit pattern\n/// is identical to the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let n = 0x3F800000U // Bit pattern for 1.0f\n///   inspect(n.reinterpret_as_float().to_double(), content=\"1\")\n/// ```\npub fn UInt::reinterpret_as_float(self : UInt) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n/// Converts a byte value to a 32-bit floating-point number (IEEE 754\n/// single-precision format). The byte value is treated as an unsigned 8-bit\n/// integer during the conversion.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to a float.\n///\n/// Returns a 32-bit floating-point number representing the byte value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let b = b'\\xFF' // 255 in decimal\n///   let f = b.to_float()\n///   // Convert to double for comparison since Float doesn't implement Show\n///   inspect(f.to_double(), content=\"255\")\n/// ```\npub fn Byte::to_float(self : Byte) -> Float = \"%byte.to_f32\"\n\n///| TODO: use intrinsics implement this\npub fn Byte::to_double(self : Byte) -> Double {\n  self.to_int().to_double()\n}\n\n///|\n/// Converts a double-precision floating-point number to a single-precision\n/// floating-point number. The conversion may result in a loss of precision due\n/// to the reduced number of bits available in the single-precision format.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to be converted.\n///\n/// Returns a single-precision floating-point number that represents the closest\n/// possible value to the input double-precision number.\n///\n/// Example:\n///\n/// ```moonbit\n///   let d = 3.14159265359\n///   inspect(d.to_float().to_double(), content=\"3.1415927410125732\") // Note the loss of precision\n/// ```\npub fn Double::to_float(self : Double) -> Float = \"%f64.to_f32\"\n\n///|\n/// Converts an unsigned 32-bit integer to a single-precision floating-point\n/// number. Due to the limited precision of the 32-bit floating-point format,\n/// values above 16777216 (2^24) may lose precision during conversion.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a 32-bit floating-point number that represents the same numerical\n/// value as the input unsigned integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let n = 42U\n///   inspect(n.to_float().to_double(), content=\"42\")\n///   let big = 16777216U // 2^24\n///   inspect(big.to_float().to_double(), content=\"16777216\") // Last precisely representable integer\n/// ```\npub fn UInt::to_float(self : UInt) -> Float = \"%u32.to_f32\"\n\n///|\n/// Converts a 16-bit signed integer to a 32-bit signed integer by sign\n/// extension.\n///\n/// Parameters:\n///\n/// * `value` : The 16-bit signed integer to be converted.\n///\n/// Returns a 32-bit signed integer that has the same value as the input.\n///\n/// Example:\n///\n/// ```moonbit\n///   let n = Int::to_int16(42)\n///   inspect(n.to_int(), content=\"42\")\n///   let neg = Int::to_int16(-42)\n///   inspect(neg.to_int(), content=\"-42\")\n/// ```\npub fn Int16::to_int(self : Int16) -> Int = \"%i16_to_i32\"\n\n///|\n/// Converts a 16-bit signed integer to a byte by truncating its value to fit\n/// within the byte range (0 to 255). Only the least significant 8 bits of the\n/// integer are retained.\n///\n/// Parameters:\n///\n/// * `value` : The 16-bit signed integer to be converted to a byte.\n///\n/// Returns a byte containing the least significant 8 bits of the input value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = Int::to_int16(258) // In binary: 0000_0001_0000_0010\n///   inspect(x.to_byte(), content=\"b'\\\\x02'\") // Only keeps 0000_0010\n/// ```\npub fn Int16::to_byte(self : Int16) -> Byte = \"%i16_to_byte\"\n\n///|\npub fn Int::to_int16(self : Int) -> Int16 = \"%i32_to_i16\"\n\n///|\n/// Converts a byte value to a 16-bit signed integer. The byte value is\n/// sign-extended to 16 bits during the conversion.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to an `Int16`.\n///\n/// Returns a 16-bit signed integer representing the same value as the input\n/// byte.\n///\n/// Example:\n///\n/// ```moonbit\n///   let b = b'\\xFF' // -1 as a signed byte\n///   inspect(b.to_int16(), content=\"255\") // Sign is preserved\n///   let p = b'\\x7F' // 127 as a signed byte\n///   inspect(p.to_int16(), content=\"127\")\n/// ```\npub fn Byte::to_int16(self : Byte) -> Int16 = \"%byte_to_i16\"\n\n///|\n/// Converts an unsigned 16-bit integer to a 32-bit signed integer. The value is\n/// zero-extended to fill the higher bits.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 16-bit integer to be converted.\n///\n/// Returns a 32-bit signed integer. Since the input value is always non-negative\n/// and less than 65536, the conversion never results in overflow.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = Int::to_uint16(42)\n///   inspect(x.to_int(), content=\"42\")\n///   let max = Int::to_uint16(65535) // maximum value of UInt16\n///   inspect(max.to_int(), content=\"65535\")\n/// ```\npub fn UInt16::to_int(self : UInt16) -> Int = \"%u16_to_i32\"\n\n///|\n/// Converts a 16-bit unsigned integer to an 8-bit byte by truncating the higher\n/// bits.\n///\n/// Parameters:\n///\n/// * `value` : The 16-bit unsigned integer to be converted.\n///\n/// Returns a byte containing the least significant 8 bits of the input value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = Int::to_uint16(258) // Binary: 0000_0001_0000_0010\n///   inspect(x.to_byte(), content=\"b'\\\\x02'\") // Only keeps 0000_0010\n/// ```\npub fn UInt16::to_byte(self : UInt16) -> Byte = \"%u16_to_byte\"\n\n///|\n/// Converts a 32-bit signed integer to a 16-bit unsigned integer by truncating\n/// its value to fit within the range of 0 to 65535.\n///\n/// Parameters:\n///\n/// * `integer` : The 32-bit signed integer to be converted. Values outside the\n/// range of UInt16 will be truncated to fit.\n///\n/// Returns a 16-bit unsigned integer containing the lower 16 bits of the input\n/// value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let n = 42\n///   inspect(n.to_uint16(), content=\"42\")\n///   let neg = -1\n///   inspect(neg.to_uint16(), content=\"65535\") // -1 becomes max value of UInt16\n///   let large = 65536\n///   inspect(large.to_uint16(), content=\"0\") // Values wrap around\n/// ```\npub fn Int::to_uint16(self : Int) -> UInt16 = \"%i32_to_u16\"\n\n///|\n/// Converts a byte value to a 16-bit unsigned integer by zero-extending it.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns a 16-bit unsigned integer (`UInt16`) representing the same value as\n/// the input byte.\n///\n/// Example:\n///\n/// ```moonbit\n///   let b = b'\\xFF' // byte with value 255\n///   inspect(b.to_uint16(), content=\"255\")\n///   let zero = b'\\x00'\n///   inspect(zero.to_uint16(), content=\"0\")\n/// ```\npub fn Byte::to_uint16(self : Byte) -> UInt16 = \"%byte_to_u16\"\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct UninitializedArray[T](FixedArray[UnsafeMaybeUninit[T]])\n\n///|\n/// Creates an uninitialized array of the specified size.\n///\n/// Parameters:\n///\n/// - `size` : The number of elements the array should hold.\n///\n/// Returns an uninitialized array of type `T` with the specified size.\npub fn[T] UninitializedArray::make(size : Int) -> UninitializedArray[T] = \"%fixedarray.make_uninit\"\n\n///|\n/// Retrieves the element at the specified index from an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array from which to retrieve the element.\n/// - `index` : The index of the element to retrieve.\n///\n/// Returns the element at the specified index.\npub fn[T] UninitializedArray::op_get(\n  self : UninitializedArray[T],\n  index : Int,\n) -> T = \"%fixedarray.get\"\n\n///|\n/// Sets the value at the specified index in an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array where the value will be set.\n/// - `index` : The position in the array where the value will be set.\n/// - `value` : The value to be set at the specified index.\npub fn[T] UninitializedArray::op_set(\n  self : UninitializedArray[T],\n  index : Int,\n  value : T,\n) = \"%fixedarray.set\"\n\n///|\n/// Creates a view into a portion of the uninitialized array.\n///\n/// Parameters:\n///\n/// * `array` : The uninitialized array to create a view from.\n/// * `start` : The starting index of the view (inclusive). Defaults to 0.\n/// * `end` : The ending index of the view (exclusive). If not provided, defaults\n/// to the length of the array.\n///\n/// Returns an `ArrayView` that provides a window into the specified portion of\n/// the array.\n///\n/// Throws an error if the indices are out of bounds or if `start` is greater\n/// than `end`.\npub fn[T] UninitializedArray::op_as_view(\n  self : UninitializedArray[T],\n  start~ : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => end\n  }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View start index out of bounds\")\n  }\n  ArrayView::make(self, start, end - start)\n}\n\n///|\n/// Returns the length of an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array whose length is to be determined.\n///\n/// Returns the length of the uninitialized array as an integer.\npub fn[A] UninitializedArray::length(self : UninitializedArray[A]) -> Int {\n  let UninitializedArray(self) = self\n  self.length()\n}\n\n///|\n#internal(unsafe, \"For internal use only.\")\npub fn[T] UninitializedArray::unsafe_blit(\n  dst : UninitializedArray[T],\n  dst_offset : Int,\n  src : UninitializedArray[T],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  FixedArray::unsafe_blit(dst.0, dst_offset, src.0, src_offset, len)\n}\n\n///|\ntest \"op_as_view with valid_range\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  let view = arr[1:4]\n  inspect(view.start(), content=\"1\")\n  inspect(view.len(), content=\"3\")\n}\n\n///|\ntest \"panic op_as_view with invalid_start\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  ignore(arr[-1:])\n}\n\n///|\ntest \"panic op_as_view with invalid_end\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  ignore(arr[2:10])\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl[X : Eq] Eq for X? with op_equal(self, other) {\n  match (self, other) {\n    (None, None) => true\n    (Some(x), Some(y)) => x == y\n    _ => false\n  }\n}\n\n///|\npub fn[X : Show] Option::to_string(self : X?) -> String {\n  match self {\n    None => \"None\"\n    Some(x) => \"Some(\" + x.to_string() + \")\"\n  }\n}\n\n///|\n/// Extract the value in `Some`.\n/// \n/// If the value is `None`, it throws a panic.\npub fn[X] Option::unwrap(self : X?) -> X {\n  match self {\n    None => panic()\n    Some(x) => x\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the offset (charcode index) of the first occurrence of the given\n/// substring. If the substring is not found, it returns None.\npub fn View::find(self : View, str : View) -> Int? {\n  if str.length() <= 4 {\n    brute_force_find(self, str)\n  } else {\n    boyer_moore_horspool_find(self, str)\n  }\n  // TODO: When the pattern string is long (>= 256),\n  // consider using Two-Way algorithm to ensure linear time complexity.\n}\n\n///|\n/// Simple brute force string search algorithm\n/// Scans the haystack left to right, matching the needle at each position\nfn brute_force_find(haystack : View, needle : View) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(0) }\n  guard haystack_len >= needle_len else { return None }\n  let needle_first = needle.unsafe_charcode_at(0)\n  let forward_len = haystack_len - needle_len\n  let mut i = 0\n  while i <= forward_len {\n    // Skip positions where first charcode doesn't match\n    while i <= forward_len && haystack.unsafe_charcode_at(i) != needle_first {\n      i += 1\n    }\n    if i <= forward_len {\n      // Check remaining charcodes for full match\n      for j in 1..<needle_len {\n        if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n          break\n        }\n      } else {\n        return Some(i)\n      }\n      i += 1\n    }\n  }\n  None\n}\n\n///|\n/// Boyer-Moore-Horspool algorithm for string search (left to right)\n/// More efficient than brute force for longer patterns by using bad char heuristic\nfn boyer_moore_horspool_find(haystack : View, needle : View) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(0) }\n  guard haystack_len >= needle_len else { return None }\n  // Build skip table\n  let skip_table = FixedArray::make(1 << 8, needle_len)\n  for i in 0..<(needle_len - 1) {\n    skip_table[needle.unsafe_charcode_at(i) & 0xFF] = needle_len - 1 - i\n  }\n  for i = 0\n      i <= haystack_len - needle_len\n      i = i + skip_table[haystack.unsafe_charcode_at(i + needle_len - 1) & 0xFF] {\n    // Check all charcodes for match at current position\n    for j in 0..=(needle_len - 1) {\n      if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n        break\n      }\n    } else {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\ntest \"boyer_moore_horspool_find edge cases\" {\n  inspect(boyer_moore_horspool_find(\"abc\"[:], \"\"[:]), content=\"Some(0)\")\n  inspect(boyer_moore_horspool_find(\"ab\"[:], \"abcd\"[:]), content=\"None\")\n}\n\n///|\ntest \"boyer_moore_horspool_rev_find edge cases\" {\n  inspect(boyer_moore_horspool_rev_find(\"abc\"[:], \"\"[:]), content=\"Some(3)\")\n  inspect(boyer_moore_horspool_rev_find(\"ab\"[:], \"abcd\"[:]), content=\"None\")\n}\n\n///|\n/// Returns the offset of the first occurrence of the given substring. If the\n/// substring is not found, it returns None.\npub fn String::find(self : String, str : View) -> Int? {\n  self[:].find(str)\n}\n\n///|\ntest \"find\" {\n  inspect(\"hello\".find(\"o\"), content=\"Some(4)\")\n  inspect(\"hello\".find(\"l\"), content=\"Some(2)\")\n  inspect(\"hello\".find(\"hello\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"h\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"world\"), content=\"None\")\n  inspect(\"\".find(\"\"), content=\"Some(0)\")\n  inspect(\"\".find(\"a\"), content=\"None\")\n  inspect(\"hello hello\".find(\"hello\"), content=\"Some(0)\")\n  inspect(\"aaa\".find(\"aa\"), content=\"Some(0)\")\n  inspect(\"😀😀\".find(\"😀\"), content=\"Some(0)\")\n  inspect(\n    (\"😀😀aa\".repeat(20) + \"😀😀😀😀\").find(\"😀😀😀😀\"),\n    content=\"Some(120)\",\n  )\n  inspect(\n    (\"😀😀😀😀\" + \"😀😀aa\".repeat(20)).find(\"😀😀😀😀\"),\n    content=\"Some(0)\",\n  )\n}\n\n///|\n/// Returns the offset of the first character that satisfies the given predicate.\n/// If no such character is found, it returns None.\npub fn View::find_by(self : View, pred : (Char) -> Bool) -> Int? {\n  for i, c in self {\n    if pred(c) {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\n/// Returns the offset of the first character that satisfies the given predicate.\n/// If no such character is found, it returns None.\npub fn String::find_by(self : String, pred : (Char) -> Bool) -> Int? {\n  self[:].find_by(pred)\n}\n\n///|\ntest \"find_by\" {\n  inspect(\"hello\".find_by(c => c == 'o'), content=\"Some(4)\")\n  inspect(\"hello\".find_by(c => c == 'l'), content=\"Some(2)\")\n  inspect(\"hello\".find_by(c => c == 'z'), content=\"None\")\n  inspect(\"\".find_by(c => c == 'a'), content=\"None\")\n  inspect(\"hello\".find_by(c => c is ('0'..='9')), content=\"None\")\n  inspect(\"hello123\".find_by(c => c is ('0'..='9')), content=\"Some(5)\")\n  inspect(\"hello\".find_by(c => c is ('A'..='Z')), content=\"None\")\n  inspect(\"Hello\".find_by(c => c is ('A'..='Z')), content=\"Some(0)\")\n  inspect(\"αβγ\".find_by(c => c == 'β'), content=\"Some(1)\")\n  inspect(\"😀😁😂\".find_by(c => c == '😂'), content=\"Some(2)\")\n}\n\n///|\n/// Returns the offset of the last occurrence of the given substring. If the\n/// substring is not found, it returns None.\npub fn View::rev_find(self : View, str : View) -> Int? {\n  if str.length() <= 4 {\n    brute_force_rev_find(self, str)\n  } else {\n    boyer_moore_horspool_rev_find(self, str)\n  }\n  // TODO: When the pattern string is long (>= 256),\n  // consider using Two-Way algorithm to ensure linear time complexity.\n}\n\n///|\n/// Simple brute force string search algorithm\n/// Scans the haystack right to left, matching the needle at each position\nfn brute_force_rev_find(haystack : View, needle : View) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(haystack_len) }\n  guard haystack_len >= needle_len else { return None }\n  let needle_first = needle.unsafe_charcode_at(0)\n  let mut i = haystack_len - needle_len\n  while i >= 0 {\n    // Skip positions where first charcode doesn't match\n    while i >= 0 && haystack.unsafe_charcode_at(i) != needle_first {\n      i -= 1\n    }\n    if i >= 0 {\n      // Check remaining charcodes for full match\n      for j in 1..<needle_len {\n        if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n          break\n        }\n      } else {\n        return Some(i)\n      }\n      i -= 1\n    }\n  }\n  None\n}\n\n///|\n/// Boyer-Moore-Horspool algorithm for reverse string search (right to left)\n/// More efficient than brute force for longer patterns by using bad char heuristic\nfn boyer_moore_horspool_rev_find(haystack : View, needle : View) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(haystack_len) }\n  guard haystack_len >= needle_len else { return None }\n  let skip_table = FixedArray::make(1 << 8, needle_len)\n  for i = needle_len - 1; i > 0; i = i - 1 {\n    skip_table[needle.unsafe_charcode_at(i) & 0xFF] = i\n  }\n  for i = haystack_len - needle_len\n      i >= 0\n      i = i - skip_table[haystack.unsafe_charcode_at(i) & 0xFF] {\n    // Check all charcodes for match at current position\n    for j in 0..<needle_len {\n      if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n        break\n      }\n    } else {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\n/// Returns the offset (charcode index) of the last occurrence of the given\n/// substring. If the substring is not found, it returns None.\npub fn String::rev_find(self : String, str : View) -> Int? {\n  self[:].rev_find(str)\n}\n\n///|\ntest \"rev_find\" {\n  inspect(\"hello\".rev_find(\"o\"), content=\"Some(4)\")\n  inspect(\"hello\".rev_find(\"l\"), content=\"Some(3)\")\n  inspect(\"hello\".rev_find(\"hello\"), content=\"Some(0)\")\n  inspect(\"hello\".rev_find(\"h\"), content=\"Some(0)\")\n  inspect(\"hello\".rev_find(\"\"), content=\"Some(5)\")\n  inspect(\"hello\".rev_find(\"world\"), content=\"None\")\n  inspect(\"\".rev_find(\"\"), content=\"Some(0)\")\n  inspect(\"\".rev_find(\"a\"), content=\"None\")\n  inspect(\"hello hello\".rev_find(\"hello\"), content=\"Some(6)\")\n  inspect(\"aaa\".rev_find(\"aa\"), content=\"Some(1)\")\n  inspect(\"😀😀\".rev_find(\"😀\"), content=\"Some(2)\")\n  inspect(\n    (\"😀😀aa\".repeat(20) + \"😀😀😀😀\").rev_find(\"😀😀😀😀\"),\n    content=\"Some(120)\",\n  )\n  inspect(\n    (\"😀😀😀😀\" + \"😀😀aa\".repeat(20)).rev_find(\"😀😀😀😀\"),\n    content=\"Some(4)\",\n  )\n}\n\n///| \n/// Returns true if the given substring is suffix of this string.\npub fn View::has_suffix(self : View, str : View) -> Bool {\n  self.rev_find(str) is Some(i) && i == self.length() - str.length()\n}\n\n///|\n/// Returns true if the given substring is suffix of this string.\npub fn String::has_suffix(self : String, str : View) -> Bool {\n  self[:].has_suffix(str)\n}\n\n///|\ntest \"has_suffix\" {\n  inspect(\"hello\".has_suffix(\"lo\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"hello\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"world\"), content=\"false\")\n  inspect(\"hello\".has_suffix(\"hel\"), content=\"false\")\n  inspect(\"\".has_suffix(\"\"), content=\"true\")\n  inspect(\"\".has_suffix(\"a\"), content=\"false\")\n  inspect(\"hello world\".has_suffix(\"world\"), content=\"true\")\n  inspect(\"😀😀\".has_suffix(\"😀\"), content=\"true\")\n  inspect(\"😀😀\".has_suffix(\"😀😀\"), content=\"true\")\n}\n\n///|\n/// Returns true if this string starts with the given substring.\npub fn View::has_prefix(self : View, str : View) -> Bool {\n  self.find(str) is Some(i) && i == 0\n}\n\n///|\n/// Returns true if this string starts with the given substring.\npub fn String::has_prefix(self : String, str : View) -> Bool {\n  self[:].has_prefix(str)\n}\n\n///|\ntest \"has_prefix\" {\n  inspect(\"hello\".has_prefix(\"h\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"he\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"world\"), content=\"false\")\n  inspect(\"hello\".has_prefix(\"lo\"), content=\"false\")\n  inspect(\"\".has_prefix(\"\"), content=\"true\")\n  inspect(\"\".has_prefix(\"a\"), content=\"false\")\n  inspect(\"😀hello\".has_prefix(\"😀\"), content=\"true\")\n  inspect(\"😀😃hello\".has_prefix(\"😀😃\"), content=\"true\")\n  inspect(\"😀hello\".has_prefix(\"😃\"), content=\"false\")\n  inspect(\"hello😀\".has_prefix(\"😀\"), content=\"false\")\n}\n\n///|\n/// Removes the given suffix from the string if it exists.\n/// \n/// Returns `Some(prefix)` if the string ends with the given suffix,\n/// where `prefix` is the string without the suffix.\n/// Returns `None` if the string does not end with the suffix.\n/// \n/// # Example\n/// \n/// ```moonbit\n///   inspect(\"hello world\".strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n///   inspect(\"hello world\".strip_suffix(\" moon\"), content=\"None\")\n///   inspect(\"hello\".strip_suffix(\"hello\"), content=\"Some(\\\"\\\")\")\n/// ```\n#alias(ends_with, deprecated)\npub fn strip_suffix(self : String, suffix : View) -> View? {\n  if self.has_suffix(suffix) {\n    Some(self.charcodes(end=self.length() - suffix.length()))\n  } else {\n    None\n  }\n}\n\n///|\ntest \"strip_prefix\" {\n  inspect(\"hello world\".strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n  inspect(\"hello world\".strip_prefix(\"hi \"), content=\"None\")\n  inspect(\"hello\".strip_prefix(\"hello\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_prefix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_prefix(\"a\"), content=\"None\")\n  inspect(\"abc\".strip_prefix(\"\"), content=\"Some(\\\"abc\\\")\")\n  inspect(\"😀hello\".strip_prefix(\"😀\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"😀😃hello\".strip_prefix(\"😀😃\"), content=\"Some(\\\"hello\\\")\")\n}\n\n///|\ntest \"strip_suffix\" {\n  inspect(\"hello world\".strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"hello world\".strip_suffix(\" moon\"), content=\"None\")\n  inspect(\"hello\".strip_suffix(\"hello\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_suffix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_suffix(\"a\"), content=\"None\")\n  inspect(\"abc\".strip_suffix(\"\"), content=\"Some(\\\"abc\\\")\")\n  inspect(\"hello😀\".strip_suffix(\"😀\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"hello😀😃\".strip_suffix(\"😀😃\"), content=\"Some(\\\"hello\\\")\")\n}\n\n///|\n/// Removes the given prefix from the string if it exists.\n/// \n/// Returns `Some(suffix)` if the string starts with the given prefix,\n/// where `suffix` is the string without the prefix.\n/// Returns `None` if the string does not start with the prefix.\n/// \n/// # Example\n/// \n/// ```moonbit\n///   inspect(\"hello world\".strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n///   inspect(\"hello world\".strip_prefix(\"hi \"), content=\"None\")\n///   inspect(\"hello\".strip_prefix(\"hello\"), content=\"Some(\\\"\\\")\")\n/// ```\n#alias(starts_with, deprecated)\npub fn strip_prefix(self : String, prefix : View) -> View? {\n  if self.has_prefix(prefix) {\n    Some(self.charcodes(start=prefix.length()))\n  } else {\n    None\n  }\n}\n\n///|\n/// Removes the given prefix from the view if it exists.\n/// \n/// Returns `Some(suffix)` if the view starts with the given prefix,\n/// where `suffix` is the view without the prefix.\n/// Returns `None` if the view does not start with the prefix.\n/// \n/// # Example\n/// \n/// ```moonbit\n///   let view = \"hello world\"[:]\n///   inspect(view.strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n///   inspect(view.strip_prefix(\"hi \"), content=\"None\")\n///   inspect(view.strip_prefix(\"hello world\"), content=\"Some(\\\"\\\")\")\n/// ```\npub fn View::strip_prefix(self : View, prefix : View) -> View? {\n  if self.has_prefix(prefix) {\n    Some(self.view(start_offset=prefix.length()))\n  } else {\n    None\n  }\n}\n\n///|\n/// Removes the given suffix from the view if it exists.\n/// \n/// Returns `Some(prefix)` if the view ends with the given suffix,\n/// where `prefix` is the view without the suffix.\n/// Returns `None` if the view does not end with the suffix.\n/// \n/// # Example\n/// \n/// ```moonbit\n///   let view = \"hello world\"[:]\n///   inspect(view.strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n///   inspect(view.strip_suffix(\" moon\"), content=\"None\")\n///   inspect(view.strip_suffix(\"hello world\"), content=\"Some(\\\"\\\")\")\n/// ```\npub fn View::strip_suffix(self : View, suffix : View) -> View? {\n  if self.has_suffix(suffix) {\n    Some(self.view(end_offset=self.length() - suffix.length()))\n  } else {\n    None\n  }\n}\n\n///|\n/// Converts the View into an array of Chars.\n/// \n/// # Example\n/// \n/// ```moonbit\n///   let view = \"Hello🤣xa\"[1:-1]\n///   let chars = view.to_array()\n///   inspect(chars, content=\"['e', 'l', 'l', 'o', '🤣', 'x']\")\n/// ```\npub fn View::to_array(self : View) -> Array[Char] {\n  self\n  .iter()\n  .fold(init=Array::new(capacity=self.length()), (rv, c) => {\n    rv.push(c)\n    rv\n  })\n}\n\n///|\n/// Converts the View into bytes using UTF-16 little endian format.\n/// \n/// # Example\n/// \n/// ```moonbit\n///   let view = \"Hellox\"[1:-1]\n///   let bytes = view.to_bytes()\n///   inspect(bytes.to_unchecked_string(), content=\"ello\")\n/// ```\npub fn View::to_bytes(self : View) -> Bytes {\n  let array = FixedArray::make(self.length() * 2, Byte::default())\n  array.blit_from_string(0, self.data(), self.start_offset(), self.length())\n  array |> unsafe_to_bytes\n}\n\n///|\ntest \"View::strip_prefix\" {\n  let view = \"hello world\"[:]\n  inspect(view.strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n  inspect(view.strip_prefix(\"hi \"), content=\"None\")\n  inspect(view.strip_prefix(\"hello world\"), content=\"Some(\\\"\\\")\")\n  inspect(view.strip_prefix(\"\"), content=\"Some(\\\"hello world\\\")\")\n  let empty_view = \"\"[:]\n  inspect(empty_view.strip_prefix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(empty_view.strip_prefix(\"a\"), content=\"None\")\n  let unicode_view = \"😀hello😃\"[:]\n  inspect(unicode_view.strip_prefix(\"😀\"), content=\"Some(\\\"hello😃\\\")\")\n  inspect(unicode_view.strip_prefix(\"😃\"), content=\"None\")\n}\n\n///|\ntest \"View::strip_suffix\" {\n  let view = \"hello world\"[:]\n  inspect(view.strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n  inspect(view.strip_suffix(\" moon\"), content=\"None\")\n  inspect(view.strip_suffix(\"hello world\"), content=\"Some(\\\"\\\")\")\n  inspect(view.strip_suffix(\"\"), content=\"Some(\\\"hello world\\\")\")\n  let empty_view = \"\"[:]\n  inspect(empty_view.strip_suffix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(empty_view.strip_suffix(\"a\"), content=\"None\")\n  let unicode_view = \"😀hello😃\"[:]\n  inspect(unicode_view.strip_suffix(\"😃\"), content=\"Some(\\\"😀hello\\\")\")\n  inspect(unicode_view.strip_suffix(\"😀\"), content=\"None\")\n}\n\n///|\ntest \"View::to_array\" {\n  let view = \"Hello🤣\"[:]\n  let chars = view.to_array()\n  assert_eq(chars, ['H', 'e', 'l', 'l', 'o', '🤣'])\n  let empty_view = \"\"[:]\n  let empty_chars = empty_view.to_array()\n  assert_eq(empty_chars, [])\n  let sub_view = \"Hello World\"[6:11] // \"World\"\n  let sub_chars = sub_view.to_array()\n  assert_eq(sub_chars, ['W', 'o', 'r', 'l', 'd'])\n}\n\n///|\ntest \"View::to_bytes\" {\n  let view = \"Hello\"[:]\n  let bytes = view.to_bytes()\n  assert_eq(bytes.to_unchecked_string(), \"Hello\")\n  let unicode_view = \"🤣🤔\"[:]\n  let unicode_bytes = unicode_view.to_bytes()\n  assert_eq(unicode_bytes.to_unchecked_string(), \"🤣🤔\")\n  let sub_view = \"Hello World\"[0:5] // \"Hello\"\n  let sub_bytes = sub_view.to_bytes()\n  assert_eq(sub_bytes.to_unchecked_string(), \"Hello\")\n}\n\n///|\n/// Returns true if this string contains the given substring.\npub fn View::contains(self : View, str : View) -> Bool {\n  self.find(str) is Some(_)\n}\n\n///|\n/// Returns true if this string contains the given substring.\npub fn contains(self : String, str : View) -> Bool {\n  self[:].contains(str)\n}\n\n///|\ntest \"contains\" {\n  inspect(\"hello\".contains(\"o\"), content=\"true\")\n  inspect(\"hello\".contains(\"l\"), content=\"true\")\n  inspect(\"hello\".contains(\"hello\"), content=\"true\")\n  inspect(\"hello\".contains(\"h\"), content=\"true\")\n  inspect(\"hello\".contains(\"\"), content=\"true\")\n  inspect(\"hello\".contains(\"world\"), content=\"false\")\n  inspect(\"\".contains(\"\"), content=\"true\")\n  inspect(\"\".contains(\"a\"), content=\"false\")\n  inspect(\"hello hello\".contains(\"hello\"), content=\"true\")\n  inspect(\"aaa\".contains(\"aa\"), content=\"true\")\n  inspect(\"😀😀\".contains(\"😀\"), content=\"true\")\n}\n\n///|\n/// Returns true if this string contains the given character.\npub fn View::contains_char(self : View, c : Char) -> Bool {\n  let len = self.length()\n  // Check empty\n  guard len > 0 else { return false }\n  let c = c.to_int()\n  if c <= 0xFFFF {\n    // Search BMP\n    for i in 0..<len {\n      if self.unsafe_charcode_at(i) == c {\n        return true\n      }\n    }\n  } else {\n    // Check insufficient\n    guard len >= 2 else { return false }\n    // Calc surrogate pair\n    let adj = c - 0x10000\n    let high = 0xD800 + (adj >> 10)\n    let low = 0xDC00 + (adj & 0x3FF)\n    // Search surrogate pair\n    let mut i = 0\n    while i < len - 1 {\n      if self.unsafe_charcode_at(i) == high {\n        i += 1\n        if self.unsafe_charcode_at(i) == low {\n          return true\n        }\n      }\n      i += 1\n    }\n  }\n  false\n}\n\n///|\n/// Returns true if this string contains the given character.\npub fn contains_char(self : String, c : Char) -> Bool {\n  self[:].contains_char(c)\n}\n\n///|\ntest \"contains_char\" {\n  inspect(\"hello\".contains_char('h'), content=\"true\")\n  inspect(\"hello\".contains_char('e'), content=\"true\")\n  inspect(\"hello\".contains_char('l'), content=\"true\")\n  inspect(\"hello\".contains_char('o'), content=\"true\")\n  inspect(\"hello\".contains_char('x'), content=\"false\")\n  inspect(\"\".contains_char('a'), content=\"false\")\n  inspect(\"hello world\".contains_char(' '), content=\"true\")\n  inspect(\"hello world\".contains_char('w'), content=\"true\")\n  inspect(\"😀😀\".contains_char('😀'), content=\"true\")\n  inspect(\"😀😀\".contains_char('😃'), content=\"false\")\n  inspect(\"hello\".contains_char((104).unsafe_to_char()), content=\"true\") // 'h' is 104 in ASCII\n}\n\n///|\n/// Returns the view of the string without the leading characters that are in\n/// the given string.\npub fn View::trim_start(self : View, char_set : View) -> View {\n  loop self {\n    [] as v => v\n    [c, .. rest] as v =>\n      if char_set.contains_char(c) {\n        continue rest\n      } else {\n        v\n      }\n  }\n}\n\n///|\n/// Returns the view of the string without the leading characters that are in\n/// the given string.\npub fn trim_start(self : String, char_set : View) -> View {\n  self[:].trim_start(char_set)\n}\n\n///|\ntest \"trim_start\" {\n  inspect(\"hello\".trim_start(\"h\"), content=\"ello\")\n  inspect(\"hello\".trim_start(\"he\"), content=\"llo\")\n  inspect(\"hello\".trim_start(\"eh\"), content=\"llo\")\n  inspect(\"hello\".trim_start(\"x\"), content=\"hello\")\n  inspect(\"hello\".trim_start(\"\"), content=\"hello\")\n  inspect(\"\".trim_start(\"a\"), content=\"\")\n  inspect(\"   hello\".trim_start(\" \"), content=\"hello\")\n  inspect(\"hello world\".trim_start(\"helo\"), content=\" world\")\n  inspect(\"😀😀hello\".trim_start(\"😀\"), content=\"hello\")\n  inspect(\"😀😃hello\".trim_start(\"😀😃\"), content=\"hello\")\n  inspect(\"aaaabc\".trim_start(\"a\"), content=\"bc\")\n  inspect(\"aaaa\".trim_start(\"a\"), content=\"\")\n}\n\n///|\n/// Returns the view of the string without the trailing characters that are in\n/// the given string.\npub fn View::trim_end(self : View, char_set : View) -> View {\n  loop self {\n    [] as v => v\n    [.. rest, c] as v =>\n      if char_set.contains_char(c) {\n        continue rest\n      } else {\n        v\n      }\n  }\n}\n\n///|\n/// Returns the view of the string without the trailing characters that are in\n/// the given string.\npub fn trim_end(self : String, char_set : View) -> View {\n  self[:].trim_end(char_set)\n}\n\n///|\ntest \"trim_end\" {\n  inspect(\"hello\".trim_end(\"o\"), content=\"hell\")\n  inspect(\"hello\".trim_end(\"lo\"), content=\"he\")\n  inspect(\"hello\".trim_end(\"x\"), content=\"hello\")\n  inspect(\"hello\".trim_end(\"\"), content=\"hello\")\n  inspect(\"\".trim_end(\"a\"), content=\"\")\n  inspect(\"hello   \".trim_end(\" \"), content=\"hello\")\n  inspect(\"hello world\".trim_end(\"dlrow \"), content=\"he\")\n  inspect(\"hello😀😀\".trim_end(\"😀\"), content=\"hello\")\n  inspect(\"hello😀😃\".trim_end(\"😀😃\"), content=\"hello\")\n  inspect(\"abcccc\".trim_end(\"c\"), content=\"ab\")\n  inspect(\"cccc\".trim_end(\"c\"), content=\"\")\n}\n\n///|\n/// Returns the view of the string without the leading and trailing characters\n/// that are in the given string.\npub fn View::trim(self : View, char_set : View) -> View {\n  self.trim_start(char_set).trim_end(char_set)\n}\n\n///|\n/// Returns the view of the string without the leading and trailing characters\n/// that are in the given string.\npub fn trim(self : String, char_set : View) -> View {\n  self[:].trim(char_set)\n}\n\n///|\ntest \"trim\" {\n  inspect(\"hello\".trim(\"h\"), content=\"ello\")\n  inspect(\"hello\".trim(\"o\"), content=\"hell\")\n  inspect(\"hello\".trim(\"ho\"), content=\"ell\")\n  inspect(\"hello\".trim(\"oh\"), content=\"ell\")\n  inspect(\"hello\".trim(\"x\"), content=\"hello\")\n  inspect(\"hello\".trim(\"\"), content=\"hello\")\n  inspect(\"\".trim(\"a\"), content=\"\")\n  inspect(\"   hello   \".trim(\" \"), content=\"hello\")\n  inspect(\"hello world\".trim(\"hd\"), content=\"ello worl\")\n  inspect(\"😀hello😀\".trim(\"😀\"), content=\"hello\")\n  inspect(\"😀😃hello😀😃\".trim(\"😀😃\"), content=\"hello\")\n  inspect(\"aaaabcaaa\".trim(\"a\"), content=\"bc\")\n  inspect(\"aaaa\".trim(\"a\"), content=\"\")\n  inspect(\"  hello world  \".trim(\" \"), content=\"hello world\")\n  inspect(\"abcabc\".trim(\"abc\"), content=\"\")\n}\n\n///| \n/// Returns the view of the string without the leading and trailing spaces.\npub fn View::trim_space(self : View) -> View {\n  self.trim(\" \\n\\r\\t\")\n}\n\n///|\n/// Returns the view of the string without the leading and trailing spaces.\npub fn trim_space(self : String) -> View {\n  self[:].trim_space()\n}\n\n///|\ntest \"trim_space\" {\n  inspect(\"hello\".trim_space(), content=\"hello\")\n  inspect(\"  hello  \".trim_space(), content=\"hello\")\n  inspect(\"hello  \".trim_space(), content=\"hello\")\n  inspect(\"  hello\".trim_space(), content=\"hello\")\n  inspect(\"\\t\\nhello\\r\\n\".trim_space(), content=\"hello\")\n  inspect(\"  hello world  \".trim_space(), content=\"hello world\")\n  inspect(\"  \".trim_space(), content=\"\")\n  inspect(\"\\n\\r\\t\".trim_space(), content=\"\")\n  inspect(\"\".trim_space(), content=\"\")\n  inspect(\"  hello\\nworld\\t\".trim_space(), content=\"hello\\nworld\")\n}\n\n///|\n/// Returns true if this string is empty.\npub fn View::is_empty(self : View) -> Bool {\n  self.length() == 0\n}\n\n///|\n/// Returns true if this string is empty.\npub fn is_empty(self : String) -> Bool {\n  self == \"\"\n}\n\n///|\ntest \"is_empty\" {\n  inspect(\"\".is_empty(), content=\"true\")\n  inspect(\"hello\".is_empty(), content=\"false\")\n  inspect(\" \".is_empty(), content=\"false\")\n  inspect(\"\\n\".is_empty(), content=\"false\")\n  inspect(\"\\t\".is_empty(), content=\"false\")\n  inspect(\"   \".is_empty(), content=\"false\")\n\n  // Test with string views\n  let s = \"hello\"\n  let empty_view = s[0:0]\n  let non_empty_view = s[0:3]\n  inspect(empty_view.is_empty(), content=\"true\")\n  inspect(non_empty_view.is_empty(), content=\"false\")\n}\n\n///|\n/// Returns true if this string is blank.\npub fn View::is_blank(self : View) -> Bool {\n  self.trim_space().is_empty()\n}\n\n///|\n/// Returns true if this string is blank.\npub fn is_blank(self : String) -> Bool {\n  self[:].is_blank()\n}\n\n///|\ntest \"is_blank\" {\n  inspect(\"\".is_blank(), content=\"true\")\n  inspect(\"hello\".is_blank(), content=\"false\")\n  inspect(\" \".is_blank(), content=\"true\")\n  inspect(\"\\n\".is_blank(), content=\"true\")\n  inspect(\"\\t\".is_blank(), content=\"true\")\n  inspect(\"   \".is_blank(), content=\"true\")\n  inspect(\" \\n\\t\\r \".is_blank(), content=\"true\")\n  inspect(\"hello world\".is_blank(), content=\"false\")\n  inspect(\"  hello  \".is_blank(), content=\"false\")\n\n  // Test with string views\n  let s = \"   hello  \"\n  let blank_view = s[0:3] // \"   \"\n  let non_blank_view = s[3:8] // \"hello\"\n  inspect(blank_view.is_blank(), content=\"true\")\n  inspect(non_blank_view.is_blank(), content=\"false\")\n}\n\n///|\n/// Returns a new string with `padding_char`s prefixed to `self` if\n/// `self.char_length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn View::pad_start(\n  self : View,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self.to_string() }\n  let padding = String::make(total_width - len, padding_char)\n  [..padding, ..self]\n}\n\n///|\n/// Returns a new string with `padding_char`s prefixed to `self` if\n/// `self.char_length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn pad_start(\n  self : String,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self }\n  let padding = String::make(total_width - len, padding_char)\n  [..padding, ..self]\n}\n\n///|\ntest \"pad_start\" {\n  // Test with regular strings\n  inspect(\"2\".pad_start(3, '0'), content=\"002\")\n  inspect(\"abc\".pad_start(5, 'x'), content=\"xxabc\")\n  inspect(\"hello\".pad_start(4, ' '), content=\"hello\") // No padding needed\n  inspect(\"\".pad_start(3, '-'), content=\"---\")\n\n  // Test with different padding characters\n  inspect(\"test\".pad_start(8, '*'), content=\"****test\")\n  inspect(\"123\".pad_start(6, '0'), content=\"000123\")\n\n  // Test with string views\n  let s = \"hello\"\n  let view = s[2:5] // \"llo\"\n  inspect(view.pad_start(5, 'x'), content=\"xxllo\")\n\n  // Test with Unicode characters\n  inspect(\"🌟\".pad_start(3, '✨'), content=\"✨🌟\")\n\n  // Edge cases\n  inspect(\"abc\".pad_start(0, 'x'), content=\"abc\") // width less than string length\n  inspect(\"abc\".pad_start(3, 'x'), content=\"abc\") // width equal to string length\n}\n\n///|\n/// Returns a new string with `padding_char`s appended to `self` if\n/// `self.length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn View::pad_end(\n  self : View,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self.to_string() }\n  let padding = String::make(total_width - len, padding_char)\n  [..self, ..padding]\n}\n\n///|\n/// Returns a new string with `padding_char`s appended to `self` if\n/// `self.length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn String::pad_end(\n  self : String,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self }\n  let padding = String::make(total_width - len, padding_char)\n  [..self, ..padding]\n}\n\n///|\ntest \"pad_end\" {\n  // Test with regular strings\n  inspect(\"2\".pad_end(3, '0'), content=\"200\")\n  inspect(\"abc\".pad_end(5, 'x'), content=\"abcxx\")\n  inspect(\"hello\".pad_end(4, ' '), content=\"hello\") // No padding needed\n  inspect(\"\".pad_end(3, '-'), content=\"---\")\n\n  // Test with different padding characters\n  inspect(\"test\".pad_end(8, '*'), content=\"test****\")\n  inspect(\"123\".pad_end(6, '0'), content=\"123000\")\n\n  // Test with string views\n  let s = \"hello\"\n  let view = s[2:5] // \"llo\"\n  inspect(view.pad_end(5, 'x'), content=\"lloxx\")\n\n  // Test with Unicode characters\n  inspect(\"🌟\".pad_end(3, '✨'), content=\"🌟✨\")\n\n  // Edge cases\n  inspect(\"abc\".pad_end(0, 'x'), content=\"abc\") // width less than string length\n  inspect(\"abc\".pad_end(3, 'x'), content=\"abc\") // width equal to string length\n}\n\n///|\n/// Returns a new string with `self` repeated `n` times.\npub fn View::repeat(self : View, n : Int) -> View {\n  match n {\n    _..=0 => \"\"\n    1 => self\n    _ => {\n      let len = self.length()\n      let buf = StringBuilder::new(size_hint=len * n)\n      let str = self.to_string()\n      for _ in 0..<n {\n        buf.write_string(str)\n      }\n      buf.to_string()\n    }\n  }\n}\n\n///|\n/// Returns a new string with `self` repeated `n` times.\npub fn repeat(self : String, n : Int) -> String {\n  match n {\n    _..=0 => \"\"\n    1 => self\n    _ => {\n      let len = self.length()\n      let buf = StringBuilder::new(size_hint=len * n)\n      let str = self.to_string()\n      for _ in 0..<n {\n        buf.write_string(str)\n      }\n      buf.to_string()\n    }\n  }\n}\n\n///|\ntest \"repeat\" {\n  // Test with regular strings\n  inspect(\"abc\".repeat(3), content=\"abcabcabc\")\n  inspect(\"x\".repeat(5), content=\"xxxxx\")\n  inspect(\"hello \".repeat(2), content=\"hello hello \")\n\n  // Test with empty string\n  inspect(\"\".repeat(10), content=\"\")\n\n  // Test with string views\n  let s = \"hello world\"\n  let view = s[6:11] // \"world\"\n  inspect(view.repeat(2), content=\"worldworld\")\n\n  // Test with Unicode characters\n  inspect(\"🌟\".repeat(3), content=\"🌟🌟🌟\")\n  inspect(\"✨🌟\".repeat(2), content=\"✨🌟✨🌟\")\n\n  // Edge cases\n  inspect(\"abc\".repeat(0), content=\"\")\n  inspect(\"abc\".repeat(-5), content=\"\")\n  inspect(\"abc\".repeat(1), content=\"abc\")\n}\n\n///|\n/// Returns a new string with the characters in reverse order. It respects\n/// Unicode characters and surrogate pairs but not grapheme clusters.\npub fn View::rev(self : View) -> String {\n  let buf = StringBuilder::new(size_hint=self.length())\n  for c in self.rev_iter() {\n    buf.write_char(c)\n  }\n  buf.to_string()\n}\n\n///|\n/// Returns a new string with the characters in reverse order. It respects\n/// Unicode characters and surrogate pairs but not grapheme clusters.\npub fn rev(self : String) -> String {\n  self[:].rev()\n}\n\n///|\ntest \"rev\" {\n  inspect(\"hello\".rev(), content=\"olleh\")\n  inspect(\"\".rev(), content=\"\")\n  inspect(\"abc\".rev(), content=\"cba\")\n  inspect(\"😀😃\".rev(), content=\"😃😀\")\n}\n\n///|\n/// Splits the string into all substrings separated by the given separator.\n/// \n/// If the string does not contain the separator and the separator is not empty,\n/// the returned iterator will contain only one element, which is the original\n/// string.\n/// \n/// If the separator is empty, the returned iterator will contain all the\n/// characters in the string as single elements.\npub fn View::split(self : View, sep : View) -> Iter[View] {\n  let sep_len = sep.length()\n  if sep_len == 0 {\n    return self.iter().map(c => c.to_string().view())\n  }\n  Iter::new(yield_ => {\n    let mut view = self\n    while view.find(sep) is Some(end) {\n      guard yield_(view.view(end_offset=end)) is IterContinue else {\n        break IterEnd\n      }\n      view = view.view(start_offset=end + sep_len)\n    } else {\n      yield_(view)\n    }\n  })\n}\n\n///|\n/// Splits the string into all substrings separated by the given separator.\n/// \n/// If the string does not contain the separator and the separator is not empty,\n/// the returned iterator will contain only one element, which is the original\n/// string.\n/// \n/// If the separator is empty, the returned iterator will contain all the\n/// characters in the string as single elements.\npub fn split(self : String, sep : View) -> Iter[View] {\n  self[:].split(sep)\n}\n\n///|\ntest \"split\" {\n  assert_eq(\"a,b,c\".split(\",\").map(View::to_string).collect(), [\"a\", \"b\", \"c\"])\n  assert_eq(\"a,b,c\".split(\"\").map(View::to_string).collect(), [\n    \"a\", \",\", \"b\", \",\", \"c\",\n  ])\n  assert_eq(\n    \"apple::orange::banana\".split(\"::\").map(View::to_string).collect(),\n    [\"apple\", \"orange\", \"banana\"],\n  )\n  assert_eq(\"abc\".split(\"\").map(View::to_string).collect(), [\"a\", \"b\", \"c\"])\n  assert_eq(\"hello\".split(\",\").map(View::to_string).collect(), [\"hello\"])\n  assert_eq(\",a,b,c\".split(\",\").map(View::to_string).collect(), [\n    \"\", \"a\", \"b\", \"c\",\n  ])\n  assert_eq(\"a,b,c,\".split(\",\").map(View::to_string).collect(), [\n    \"a\", \"b\", \"c\", \"\",\n  ])\n  assert_eq(\"a,b,c\".split(\"\").map(View::to_string).collect(), [\n    \"a\", \",\", \"b\", \",\", \"c\",\n  ])\n  assert_eq(\"\".split(\"\").map(View::to_string).collect(), [])\n  assert_eq(\"\".split(\",\").map(View::to_string).collect(), [\"\"])\n  assert_eq(\"😀,😃,😄\".split(\",\").map(View::to_string).collect(), [\n    \"😀\", \"😃\", \"😄\",\n  ])\n  assert_eq(\"a😀b😀c\".split(\"😀\").map(View::to_string).collect(), [\n    \"a\", \"b\", \"c\",\n  ])\n}\n\n///|\n/// Replaces the first occurrence of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches the beginning of the string, and `new` is\n/// prepended to the string.\npub fn View::replace(self : View, old~ : View, new~ : View) -> View {\n  match self.find(old) {\n    Some(end) =>\n      [\n        ..self.view(end_offset=end),\n        ..new,\n        ..self.view(start_offset=end + old.length()),\n      ]\n    None => self\n  }\n}\n\n///|\n/// Replaces the first occurrence of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches the beginning of the string, and `new` is\n/// prepended to the string.\npub fn replace(self : String, old~ : View, new~ : View) -> String {\n  match self.find(old) {\n    Some(end) =>\n      [\n        ..self.view(end_offset=end),\n        ..new,\n        ..self.view(start_offset=end + old.length()),\n      ]\n    None => self\n  }\n}\n\n///|\ntest \"replace\" {\n  inspect(\"hello\".replace(old=\"o\", new=\"a\"), content=\"hella\")\n  inspect(\"hello\".replace(old=\"l\", new=\"a\"), content=\"healo\")\n  inspect(\"hello\".replace(old=\"hello\", new=\"a\"), content=\"a\")\n  inspect(\"hello\".replace(old=\"h\", new=\"a\"), content=\"aello\")\n  inspect(\"hello\".replace(old=\"\", new=\"a\"), content=\"ahello\")\n  inspect(\"hello\".replace(old=\"world\", new=\"a\"), content=\"hello\")\n  inspect(\"\".replace(old=\"\", new=\"a\"), content=\"a\")\n}\n\n///|\n/// Replaces all non-overlapping occurrences of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches at the beginning of the string and after each\n/// character in the string, so `new` is inserted at the beginning of the string\n/// and after each character.\npub fn View::replace_all(self : View, old~ : View, new~ : View) -> View {\n  let len = self.length()\n  let buf = StringBuilder::new(size_hint=len)\n  let old_len = old.length()\n  let new = new.to_string()\n  // use write_substring to avoid intermediate allocations\n  if old_len == 0 {\n    buf.write_string(new)\n    for c in self {\n      buf.write_char(c)\n      buf.write_string(new)\n    }\n    buf.to_string()\n  } else {\n    let first_end = self.find(old)\n    if first_end is Some(end) {\n      for view = self, end = end {\n        let seg = view.view(end_offset=end)\n        buf.write_substring(seg.data(), seg.start_offset(), seg.length())\n        buf.write_string(new)\n        // check if there is no more characters after the last occurrence of `old`\n        guard end + old_len <= len else { break }\n        let next_view = view.view(start_offset=end + old_len)\n        guard next_view.find(old) is Some(next_end) else {\n          buf.write_substring(\n            next_view.data(),\n            next_view.start_offset(),\n            next_view.length(),\n          )\n          break\n        }\n        continue next_view, next_end\n      }\n      buf.to_string()\n    } else {\n      self\n    }\n  }\n}\n\n///|\n/// Replaces all non-overlapping occurrences of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches at the beginning of the string and after each\n/// character in the string, so `new` is inserted at the beginning of the string\n/// and after each character.\npub fn replace_all(self : String, old~ : View, new~ : View) -> String {\n  let len = self.length()\n  let buf = StringBuilder::new(size_hint=len)\n  let old_len = old.length()\n  let new = new.to_string()\n  // use write_substring to avoid intermediate allocations\n  if old_len == 0 {\n    buf.write_string(new)\n    for c in self {\n      buf.write_char(c)\n      buf.write_string(new)\n    }\n    buf.to_string()\n  } else {\n    let first_end = self.find(old)\n    if first_end is Some(end) {\n      for view = self[:], end = end {\n        let seg = view.view(end_offset=end)\n        buf.write_substring(seg.data(), seg.start_offset(), seg.length())\n        buf.write_string(new)\n        // check if there is no more characters after the last occurrence of `old`\n        guard end + old_len <= len else { break }\n        let next_view = view.view(start_offset=end + old_len)\n        guard next_view.find(old) is Some(next_end) else {\n          buf.write_substring(\n            next_view.data(),\n            next_view.start_offset(),\n            next_view.length(),\n          )\n          break\n        }\n        continue next_view, next_end\n      }\n      buf.to_string()\n    } else {\n      self\n    }\n  }\n}\n\n///|\ntest \"replace_all\" {\n  assert_eq(\"hello\".replace_all(old=\"o\", new=\"a\"), \"hella\")\n  assert_eq(\"hello\".replace_all(old=\"l\", new=\"a\"), \"heaao\")\n  assert_eq(\"hello\".replace_all(old=\"ll\", new=\"rr\"), \"herro\")\n  assert_eq(\"hello\".replace_all(old=\"hello\", new=\"world\"), \"world\")\n  assert_eq(\"hello hello hello\".replace_all(old=\"hello\", new=\"hi\"), \"hi hi hi\")\n  assert_eq(\n    \"hello hello helloi\".replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hii\",\n  )\n  assert_eq(\n    \"hi hi hii\".replace_all(old=\"hi\", new=\"hello\"),\n    \"hello hello helloi\",\n  )\n  assert_eq(\"hello\".replace_all(old=\"\", new=\"a\"), \"ahaealalaoa\")\n  assert_eq(\"hello\".replace_all(old=\"world\", new=\"a\"), \"hello\")\n  assert_eq(\"\".replace_all(old=\"\", new=\"a\"), \"a\")\n  assert_eq(\"aaa\".replace_all(old=\"a\", new=\"b\"), \"bbb\")\n  assert_eq(\"aaa\".replace_all(old=\"a\", new=\"bb\"), \"bbbbbb\")\n  assert_eq(\"aaa\".replace_all(old=\"aa\", new=\"b\"), \"ba\")\n  assert_eq(\"🤣🤣🤣\".replace_all(old=\"🤣\", new=\"😊\"), \"😊😊😊\")\n  assert_eq(\"abc123abc\".replace_all(old=\"abc\", new=\"xyz\"), \"xyz123xyz\")\n  assert_eq(\"abcabcabc\".replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\".replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\".replace_all(old=\"\", new=\"x\"), \"xaxbxcx\")\n}\n\n///|\ntest \"View::replace_all\" {\n  assert_eq(\"hello\"[:].replace_all(old=\"o\", new=\"a\"), \"hella\")\n  assert_eq(\"hello\"[:].replace_all(old=\"l\", new=\"a\"), \"heaao\")\n  assert_eq(\"hello\"[:].replace_all(old=\"ll\", new=\"rr\"), \"herro\")\n  assert_eq(\"hello\"[:].replace_all(old=\"hello\", new=\"world\"), \"world\")\n  assert_eq(\n    \"hello hello hello\"[:].replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hi\",\n  )\n  assert_eq(\n    \"hello hello helloi\"[:].replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hii\",\n  )\n  assert_eq(\n    \"hi hi hii\"[:].replace_all(old=\"hi\", new=\"hello\"),\n    \"hello hello helloi\",\n  )\n  assert_eq(\"hello\"[:].replace_all(old=\"\", new=\"a\"), \"ahaealalaoa\")\n  assert_eq(\"hello\"[:].replace_all(old=\"world\", new=\"a\"), \"hello\")\n  assert_eq(\"\"[:].replace_all(old=\"\", new=\"a\"), \"a\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"a\", new=\"b\"), \"bbb\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"a\", new=\"bb\"), \"bbbbbb\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"aa\", new=\"b\"), \"ba\")\n  assert_eq(\n    \"🤣🤣🤣\"[:].replace_all(old=\"🤣\", new=\"😊\"),\n    \"😊😊😊\",\n  )\n  assert_eq(\"abc123abc\"[:].replace_all(old=\"abc\", new=\"xyz\"), \"xyz123xyz\")\n  assert_eq(\"abcabcabc\"[:].replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\"[:].replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\"[:].replace_all(old=\"\", new=\"x\"), \"xaxbxcx\")\n}\n\n///|\n/// Converts this string to lowercase.\npub fn View::to_lower(self : View) -> View {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(x => x.is_ascii_uppercase()) is Some(idx) else {\n    return self\n  }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_uppercase() {\n      // 'A' is 65 in ASCII, 'a' is 97, the difference is 32\n      buf.write_char((c.to_int() + 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\n/// Converts this string to lowercase.\npub fn to_lower(self : String) -> String {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(x => x.is_ascii_uppercase()) is Some(idx) else {\n    return self\n  }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_uppercase() {\n      // 'A' is 65 in ASCII, 'a' is 97, the difference is 32\n      buf.write_char((c.to_int() + 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\ntest \"to_lower\" {\n  assert_eq(\"Hello\".to_lower(), \"hello\")\n  assert_eq(\"HELLO\".to_lower(), \"hello\")\n  assert_eq(\"Hello, World!\".to_lower(), \"hello, world!\")\n}\n\n///|\ntest \"View::to_lower\" {\n  assert_eq(\"Hello\"[:].to_lower(), \"hello\")\n  assert_eq(\"HELLO\"[:].to_lower(), \"hello\")\n  assert_eq(\"Hello, World!\"[:].to_lower(), \"hello, world!\")\n}\n\n///|\n/// Converts this string to uppercase.\npub fn View::to_upper(self : View) -> View {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(_.is_ascii_lowercase()) is Some(idx) else { return self }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_lowercase() {\n      buf.write_char((c.to_int() - 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\n/// Converts this string to uppercase.\npub fn to_upper(self : String) -> String {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(_.is_ascii_lowercase()) is Some(idx) else { return self }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_lowercase() {\n      buf.write_char((c.to_int() - 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\ntest \"to_upper\" {\n  assert_eq(\"hello\".to_upper(), \"HELLO\")\n  assert_eq(\"HELLO\".to_upper(), \"HELLO\")\n  assert_eq(\"Hello, World!\".to_upper(), \"HELLO, WORLD!\")\n}\n\n///|\ntest \"View::to_upper\" {\n  assert_eq(\"hello\"[:].to_upper(), \"HELLO\")\n  assert_eq(\"HELLO\"[:].to_upper(), \"HELLO\")\n  assert_eq(\"Hello, World!\"[:].to_upper(), \"HELLO, WORLD!\")\n}\n\n///|\n/// Folds the characters of the string into a single value.\npub fn[A] View::fold(self : View, init~ : A, f : (A, Char) -> A) -> A {\n  let mut rv = init\n  for c in self {\n    rv = f(rv, c)\n  }\n  rv\n}\n\n///| Folds the characters of the string into a single value.\npub fn[A] fold(self : String, init~ : A, f : (A, Char) -> A) -> A {\n  self[:].fold(init~, f)\n}\n\n///|\ntest \"fold\" {\n  assert_eq(\n    \"hello\".fold(init=[], (acc, c) => {\n      acc.push(c)\n      acc\n    }),\n    ['h', 'e', 'l', 'l', 'o'],\n  )\n  assert_eq(\n    \"hello\".fold(init=0, (acc, c) => acc + c.to_int()),\n    104 + 101 + 108 + 108 + 111,\n  )\n}\n\n///|\npub fn[A] View::rev_fold(self : View, init~ : A, f : (A, Char) -> A) -> A {\n  let mut rv = init\n  for c in self.rev_iter() {\n    rv = f(rv, c)\n  }\n  rv\n}\n\n///|\npub fn[A] rev_fold(self : String, init~ : A, f : (A, Char) -> A) -> A {\n  self[:].rev_fold(init~, f)\n}\n\n///|\ntest \"rev_fold\" {\n  assert_eq(\n    \"hello\".rev_fold(init=[], (acc, c) => {\n      acc.push(c)\n      acc\n    }),\n    ['o', 'l', 'l', 'e', 'h'],\n  )\n  assert_eq(\n    \"hello\".rev_fold(init=0, (acc, c) => acc + c.to_int()),\n    111 + 108 + 108 + 101 + 104,\n  )\n}\n\n///|\n/// Returns the UTF-16 code unit at the given index. Returns `None` if the index\n/// is out of bounds.\npub fn String::get(self : String, idx : Int) -> Int? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  Some(self.unsafe_charcode_at(idx))\n}\n\n///|\n/// Returns the UTF-16 code unit at the given index. Returns `None` if the index\n/// is out of bounds.\npub fn View::get(self : View, idx : Int) -> Int? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  Some(self.unsafe_charcode_at(idx))\n}\n\n///|\ntest \"String::get supports emoji (surrogate pair)\" {\n  let s = \"hello\"\n  inspect(s.get(0), content=\"Some(104)\")\n  inspect(s.get(4), content=\"Some(111)\")\n  inspect(s.get(5), content=\"None\")\n  inspect(s.get(-1), content=\"None\")\n  let s = \"a🤣b\"\n  inspect(s.get(0), content=\"Some(97)\")\n  inspect(s.get(1), content=\"Some(55358)\")\n  inspect(s.get(2), content=\"Some(56611)\")\n  inspect(s.get(3), content=\"Some(98)\")\n  inspect(s.get(4), content=\"None\")\n}\n\n///|\ntest \"View::get basic cases\" {\n  let v = \"hello\"[1:-1]\n  inspect(v.get(0), content=\"Some(101)\")\n  inspect(v.get(2), content=\"Some(108)\")\n  inspect(v.get(3), content=\"None\")\n  inspect(v.get(-1), content=\"None\")\n  let v = \"ab🤣cd\"[1:-1]\n  inspect(v.get(0), content=\"Some(98)\")\n  inspect(v.get(1), content=\"Some(55358)\")\n  inspect(v.get(2), content=\"Some(56611)\")\n}\n\n///|\n/// Returns the character at the given index. Returns `None` if the index is out\n/// of bounds or the index splits a surrogate pair.\npub fn String::get_char(self : String, idx : Int) -> Char? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  let c = self.unsafe_charcode_at(idx)\n  if c.is_leading_surrogate() {\n    guard idx + 1 < self.length() else { return None }\n    let next = self.unsafe_charcode_at(idx + 1)\n    if next.is_trailing_surrogate() {\n      Some(code_point_of_surrogate_pair(c, next))\n    } else {\n      None\n    }\n  } else if c.is_trailing_surrogate() {\n    None\n  } else {\n    Some(c.unsafe_to_char())\n  }\n}\n\n///|\n/// Returns the character at the given index. Returns `None` if the index is out\n/// of bounds or the index splits a surrogate pair.\npub fn View::get_char(self : View, idx : Int) -> Char? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  let c = self.unsafe_charcode_at(idx)\n  if c.is_leading_surrogate() {\n    guard idx + 1 < self.length() else { return None }\n    let next = self.unsafe_charcode_at(idx + 1)\n    if next.is_trailing_surrogate() {\n      Some(code_point_of_surrogate_pair(c, next))\n    } else {\n      None\n    }\n  } else if c.is_trailing_surrogate() {\n    None\n  } else {\n    Some(c.unsafe_to_char())\n  }\n}\n\n///|\ntest \"String::get_char basic cases\" {\n  // Basic ASCII characters\n  let s = \"hello\"\n  inspect(s.get_char(0), content=\"Some('h')\")\n  inspect(s.get_char(1), content=\"Some('e')\")\n  inspect(s.get_char(4), content=\"Some('o')\")\n  inspect(s.get_char(5), content=\"None\")\n  inspect(s.get_char(-1), content=\"None\")\n\n  // Contains emoji (surrogate pair)\n  let s = \"a🤣b\"\n  inspect(s.get_char(0), content=\"Some('a')\")\n  inspect(s.get_char(1), content=\"Some('🤣')\")\n  inspect(s.get_char(2), content=\"None\") // Second half of surrogate pair is not a valid char\n  inspect(s.get_char(3), content=\"Some('b')\")\n  inspect(s.get_char(4), content=\"None\")\n}\n\n///|\ntest \"View::get_char basic cases\" {\n  let s = \"a🤣b\"\n  let v = s[0:-1]\n  inspect(v.get_char(0), content=\"Some('a')\")\n  inspect(v.get_char(1), content=\"Some('🤣')\")\n  inspect(v.get_char(2), content=\"None\")\n  inspect(v.get_char(3), content=\"None\")\n  inspect(v.get_char(4), content=\"None\")\n\n  // Test substring view\n  let v2 = s[1:3] // Only contains the emoji surrogate pair\n  inspect(v2.get_char(0), content=\"Some('🤣')\")\n  inspect(v2.get_char(1), content=\"None\")\n  inspect(v2.get_char(2), content=\"None\")\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// A `@string.View` represents a view of a String that maintains proper Unicode\n/// character boundaries. It allows safe access to a substring while handling \n/// multi-byte characters correctly.\npub typealias StringView as View\n\n///|\n/// Returns the source string being viewed.\nfn View::str(self : View) -> String = \"%stringview.str\"\n\n///|\n/// Returns the starting UTF-16 code unit index into the string.\nfn View::start(self : View) -> Int = \"%stringview.start\"\n\n///|\n/// Returns the ending UTF-16 code unit index into the string (not included).\nfn View::end(self : View) -> Int = \"%stringview.end\"\n\n///|\nfn View::make_view(str : String, start : Int, end : Int) -> View = \"%stringview.make\"\n\n///| \n/// Returns the charcode(UTF-16 code unit) at the given index.\n/// \n/// This method has O(1) complexity.\n/// \n/// # Example\n/// \n/// ```mbt\n///   let str = \"Hello🤣🤣🤣\"\n///   let view = str.view(start_offset = str.offset_of_nth_char(1).unwrap(), end_offset = str.offset_of_nth_char(6).unwrap())\n///   inspect(view[0].to_char(), content=\"Some('e')\")\n///   inspect(view[4], content=\"55358\")\n/// ```\npub fn View::op_get(self : View, index : Int) -> Int {\n  guard index >= 0 && index < self.length() else {\n    abort(\"Index out of bounds\")\n  }\n  self.str().unsafe_charcode_at(self.start() + index)\n}\n\n///|\n/// Returns the original string that is being viewed.\npub fn data(self : View) -> String {\n  self.str()\n}\n\n///|\n/// Returns the starting offset (in UTF-16 code units) of this view into its\n/// underlying string.\npub fn start_offset(self : View) -> Int {\n  self.start()\n}\n\n///|\n/// Returns the length of the view.\n/// \n/// This method counts the charcodes(code unit) in the view and has O(1) complexity.\npub fn length(self : View) -> Int {\n  self.end() - self.start()\n}\n\n///|\n/// Creates a `View` into a `String`.\n/// \n/// # Example\n/// \n/// ```mbt\n///   let str = \"Hello🤣🤣🤣\"\n///   let view1 = str.view()\n///   inspect(view1, content=\n///    \"Hello🤣🤣🤣\"\n///   )\n///   let start_offset = str.offset_of_nth_char(1).unwrap()\n///   let end_offset = str.offset_of_nth_char(6).unwrap() // the second emoji\n///   let view2 = str.view(start_offset~, end_offset~)\n///   inspect(view2, content=\n///    \"ello🤣\"\n///   )\n/// ```\npub fn String::view(\n  self : String,\n  start_offset~ : Int = 0,\n  end_offset? : Int,\n) -> View {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"Invalid index for View\")\n  }\n  View::make_view(self, start_offset, end_offset)\n}\n\n///|\n/// Returns a new view of the view with the given start and end offsets.\npub fn View::view(\n  self : View,\n  start_offset~ : Int = 0,\n  end_offset? : Int,\n) -> View {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"Invalid index for View\")\n  }\n  View::make_view(\n    self.str(),\n    self.start() + start_offset,\n    self.start() + end_offset,\n  )\n}\n\n///|\n/// Creates a `View` into a `String`.\n/// \n/// # Example\n/// \n/// ```mbt\n///   let str = \"Hello🤣🤣🤣\"\n///   let view1 = str.view()\n///   inspect(view1, content=\"Hello🤣🤣🤣\")\n///   let start = str.offset_of_nth_char(1).unwrap()\n///   let end = str.offset_of_nth_char(6).unwrap() // the second emoji\n///   let view2 = str.view(start_offset=start, end_offset=end)\n///   inspect(view2, content=\"ello🤣\")\n/// ```\n/// \n/// This method has O(1) complexity.\n#deprecated(\"use view instead\")\npub fn String::charcodes(self : String, start~ : Int = 0, end? : Int) -> View {\n  self.view(start_offset=start, end_offset?=end)\n}\n\n///|\n/// Creates a `View` into a `View`.\n/// \n/// # Example\n/// \n/// ```mbt\n///   let str = \"Hello🤣🤣🤣\"\n///   let view1 = str.view()\n///   let view2 = view1.view(start_offset=1, end_offset=7) // From 2nd to 6th character\n///   inspect(view2, content=\n///    \"ello🤣\"\n///   )\n/// ```\n/// \n/// This method is similar to `String::charcodes` but operates on an existing view.\n/// It allows you to create a sub-view of an existing view with the specified character range.\n/// \n/// This method has O(1) complexity.\n#deprecated(\"use view instead\")\npub fn View::charcodes(self : View, start~ : Int = 0, end? : Int) -> View {\n  self.view(start_offset=start, end_offset?=end)\n}\n\n///|\n/// Returns the UTF-16 index of the i-th (zero-indexed) Unicode character of\n/// the view. If i is negative, it returns the index of the (n + i)-th character\n/// where n is the total number of Unicode characters in the view.\npub fn View::offset_of_nth_char(self : View, i : Int) -> Int? {\n  if self\n    .str()\n    .offset_of_nth_char(i, start_offset=self.start(), end_offset=self.end())\n    is Some(index) {\n    Some(index - self.start())\n  } else {\n    None\n  }\n}\n\n///|\n/// Returns the charcode(code unit) at the given index without checking if the\n/// index is within bounds.\n/// \n/// This method has O(1) complexity.\n/// #Example\n/// \n/// ```mbt\n///   let str = \"B🤣🤣C\"\n///   let view = str[:]\n///   inspect(view.unsafe_charcode_at(0), content=\"66\")\n///   inspect(view.unsafe_charcode_at(1), content=\"55358\")\n///   inspect(view.unsafe_charcode_at(2), content=\"56611\")\n///   inspect(view.unsafe_charcode_at(3), content=\"55358\")\n///   inspect(view.unsafe_charcode_at(4), content=\"56611\")\n///   inspect(view.unsafe_charcode_at(5), content=\"67\")\n/// ```\n/// TODO: rename to `unsafe_get`\npub fn View::unsafe_charcode_at(self : View, index : Int) -> Int {\n  self.str().unsafe_charcode_at(self.start() + index)\n}\n\n///| \n/// Returns the number of Unicode characters in this view.\n/// \n/// Note this has O(n) complexity where n is the length of the code points in \n/// the view.\npub fn View::char_length(self : View) -> Int {\n  self.str().char_length(start_offset=self.start(), end_offset=self.end())\n}\n\n///|\n/// Test if the length of the view is equal to the given length.\n/// \n/// This has O(n) complexity where n is the length in the parameter.\npub fn View::char_length_eq(self : View, len : Int) -> Bool {\n  self\n  .str()\n  .char_length_eq(len, start_offset=self.start(), end_offset=self.end())\n}\n\n///|\n/// Test if the length of the view is greater than or equal to the given length.\n/// \n/// This has O(n) complexity where n is the length in the parameter.\npub fn View::char_length_ge(self : View, len : Int) -> Bool {\n  self\n  .str()\n  .char_length_ge(len, start_offset=self.start(), end_offset=self.end())\n}\n\n///|\npub impl Show for View with output(self, logger) {\n  let substr = self.str().substring(start=self.start(), end=self.end())\n  String::output(substr, logger)\n}\n\n///|\n/// Returns a new String containing a copy of the characters in this view.\n/// \n/// # Examples\n/// \n/// ```mbt\n///   let str = \"Hello World\"\n///   let view = str.view(start_offset = str.offset_of_nth_char(0).unwrap(),end_offset = str.offset_of_nth_char(5).unwrap()) // \"Hello\"\n///   inspect(view.to_string(), content=\"Hello\")\n/// ```\npub impl Show for StringView with to_string(self) {\n  self.str().substring(start=self.start(), end=self.end())\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view.\npub fn View::iter(self : View) -> Iter[Char] {\n  Iter::new(yield_ => for index in self.start()..<self.end() {\n    let c1 = self.str().unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < self.end() {\n      let c2 = self.str().unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        let c = code_point_of_surrogate_pair(c1, c2)\n        guard yield_(c) is IterContinue else { break IterEnd }\n        continue index + 2\n      }\n    }\n    guard yield_(c1.unsafe_to_char()) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  })\n}\n\n///|\npub fn View::iter2(self : View) -> Iter2[Int, Char] {\n  Iter2::new(yield_ => {\n    let len = self.length()\n    for index = 0, n = 0; index < len; index = index + 1, n = n + 1 {\n      let c1 = self.str().unsafe_charcode_at(self.start() + index)\n      if c1.is_leading_surrogate() && index + 1 < len {\n        let c2 = self.str().unsafe_charcode_at(self.start() + index + 1)\n        if c2.is_trailing_surrogate() {\n          let c = code_point_of_surrogate_pair(c1, c2)\n          guard yield_(n, c) is IterContinue else { break IterEnd }\n          continue index + 2, n + 1\n        }\n      }\n      guard yield_(n, c1.unsafe_to_char()) is IterContinue else {\n        break IterEnd\n      }\n    } else {\n      IterContinue\n    }\n  })\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view in reverse order.\npub fn View::rev_iter(self : View) -> Iter[Char] {\n  Iter::new(yield_ => for index = self.end() - 1\n                          index >= self.start()\n                          index = index - 1 {\n    let c1 = self.str().unsafe_charcode_at(index)\n    if c1.is_trailing_surrogate() && index - 1 >= 0 {\n      let c2 = self.str().unsafe_charcode_at(index - 1)\n      if c2.is_leading_surrogate() {\n        let c = code_point_of_surrogate_pair(c2, c1)\n        guard yield_(c) is IterContinue else { break IterEnd }\n        continue index - 2\n      }\n    }\n    guard yield_(c1.unsafe_to_char()) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  })\n}\n\n///|\n/// Compares two views for equality. Returns true only if both views\n/// have the same length and contain identical characters in the same order.\npub impl Eq for View with op_equal(self, other) {\n  let len = self.length()\n  guard len == other.length() else { return false }\n  if physical_equal(self.str(), other.str()) && self.start() == other.start() {\n    return true\n  }\n  for i in 0..<len {\n    guard self.str().unsafe_charcode_at(self.start() + i) ==\n      other.str().unsafe_charcode_at(other.start() + i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\n/// Views are ordered lexicographically by their charcodes(code unit). This \n/// orders Unicode characters based on their positions in the code charts. This is\n/// not necessarily the same as \"alphabetical\" order, which varies by language\n/// and locale.\npub impl Compare for View with compare(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  let cmp = self_len.compare(other_len)\n  guard cmp == 0 else { return cmp }\n  if physical_equal(self.str(), other.str()) && self.start() == other.start() {\n    return 0\n  }\n  for i in 0..<self_len {\n    let cmp = self\n      .str()\n      .unsafe_charcode_at(self.start() + i)\n      .compare(other.str().unsafe_charcode_at(other.start() + i))\n    guard cmp == 0 else { return cmp }\n  }\n  0\n}\n\n///|\n/// The empty view of a string\npub impl Default for View with default() {\n  // todo: remove .view() in new version\n  \"\".view()\n}\n\n///|\n/// Convert char array to string view.\npub fn View::from_array(chars : Array[Char]) -> View {\n  // todo: remove .view() in new version\n  String::from_array(chars).view()\n}\n\n///|\n/// Convert char iterator to string view.\npub fn View::from_iter(iter : Iter[Char]) -> View {\n  // todo: remove .view() in new version\n  String::from_iter(iter).view()\n}\n\n///|\n/// Create a new string by repeating the given character `value` `length` times.\npub fn View::make(length : Int, value : Char) -> View {\n  // todo: remove .view() in new version\n  String::make(length, value).view()\n}\n\n///|\npub impl ToJson for View with to_json(self) {\n  String::to_json(self.to_string())\n}\n\n///|\npub impl Hash for View with hash_combine(self : View, hasher : Hasher) -> Unit {\n  for i in 0..<self.length() {\n    hasher.combine_uint(self.unsafe_charcode_at(i).reinterpret_as_uint())\n  }\n}\n\n///|\npub suberror CreatingViewError {\n  IndexOutOfBounds\n  InvalidIndex\n} derive(Show)\n\n///|\n/// Creates a view of a string with proper UTF-16 boundary validation.\n/// \n/// # Parameters\n/// \n/// - `start` : Starting UTF-16 code unit index (default: 0)\n///   - If positive: counts from the beginning of the string\n///   - If negative: counts from the end of the string (e.g., -1 means last position)\n/// - `end` : Ending UTF-16 code unit index (optional)\n///   - If `None`: extends to the end of the string\n///   - If positive: counts from the beginning of the string\n///   - If negative: counts from the end of the string\n/// \n/// # Returns\n/// \n/// - A `View` representing the specified substring range\n/// \n/// # Errors\n/// \n/// - `IndexOutOfBounds` : If start or end indices are out of valid range\n/// - `InvalidIndex` : If start or end position would split a UTF-16 surrogate pair\n/// \n/// This prevents creating views that would split surrogate pairs, which would\n/// result in invalid Unicode characters.\n/// \n/// # Performance\n/// \n/// This function has O(1) complexity as it only performs boundary checks\n/// without scanning the string content.\n/// \n/// # Examples\n/// \n/// ```mbt\n/// let str = \"Hello🤣World\"\n/// let view1 = try? str[0:5]\n/// inspect(\n///   view1,\n///   content=(\n///     #|Ok(\"Hello\")\n///   ),\n/// )\n/// let view2 = try? str[-5:]\n/// inspect(\n///   view2,\n///   content=(\n///     #|Ok(\"World\")\n///   ),\n/// )\n/// let view3 = try? str[:6]\n/// inspect(view3, content=\"Err(InvalidIndex)\")\n/// ```\npub fn String::op_as_view(\n  self : String,\n  start~ : Int = 0,\n  end? : Int,\n) -> View raise CreatingViewError {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else { raise IndexOutOfBounds }\n  if start < len && self.unsafe_charcode_at(start).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  if end < len && self.unsafe_charcode_at(end).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  View::make_view(self, start, end)\n}\n\n///|\n/// Creates a subview of an existing view with proper UTF-16 boundary validation.\n/// \n/// # Parameters\n/// \n/// - `start` : Starting UTF-16 code unit index relative to this view (default: 0)\n///   - If positive: counts from the beginning of this view\n///   - If negative: counts from the end of this view\n/// - `end` : Ending UTF-16 code unit index relative to this view (optional)\n///   - If `None`: extends to the end of this view\n///   - If positive: counts from the beginning of this view\n///   - If negative: counts from the end of this view\n/// \n/// # Returns\n/// \n/// - A `View` representing the specified subrange of this view\n/// \n/// # Errors\n/// \n/// - `IndexOutOfBounds` : If start or end indices are out of this view's range\n/// - `InvalidIndex` : If start or end position would split a UTF-16 surrogate pair\n/// \n/// This prevents creating views that would split surrogate pairs, which would\n/// result in invalid Unicode characters.\n/// \n/// # Performance\n/// \n/// This function has O(1) complexity as it only performs boundary checks\n/// without scanning the string content.\n/// \n/// # Examples\n/// \n/// ```mbt\n///   let str = \"Hello🤣World\"[1:-1] // \"ello🤣Worl\"\n///   let view1 = try? str[0:6]\n///   inspect(view1, content=(\n///   #|Ok(\"ello🤣\")\n/// ))\n///   let view2 = try? str[-2:]\n///   inspect(view2, content=(\n///   #|Ok(\"rl\")\n/// ))\n///   let view3 = try? str[:5]\n///   inspect(view3, content=(\"Err(InvalidIndex)\"))\n/// ```\npub fn View::op_as_view(\n  self : View,\n  start~ : Int = 0,\n  end? : Int,\n) -> View raise CreatingViewError {\n  let str_len = self.str().length()\n\n  // Calculate absolute positions in the original string\n  let abs_end = match end {\n    None => self.end()\n    Some(end) => if end < 0 { self.end() + end } else { self.start() + end }\n  }\n  let abs_start = if start < 0 {\n    self.end() + start\n  } else {\n    self.start() + start\n  }\n\n  // Validate bounds against the original string\n  guard abs_start >= self.start() &&\n    abs_start <= abs_end &&\n    abs_end <= self.end() else {\n    raise IndexOutOfBounds\n  }\n\n  // Check for surrogate pair boundaries\n  if abs_start < str_len &&\n    self.str().unsafe_charcode_at(abs_start).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  if abs_end < str_len &&\n    self.str().unsafe_charcode_at(abs_end).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  View::make_view(self.str(), abs_start, abs_end)\n}\n\n///|\npub impl Add for View with op_add(self, other) {\n  [..self, ..other]\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Aborts the program with an error message. Always causes a panic, regardless\n/// of the message provided.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be displayed when\n/// aborting.\n///\n/// Returns a value of type `T`. However, this function never actually returns a\n/// value as it always causes a panic.\npub fn[T] abort(msg : String) -> T {\n  let _ = msg\n  panic_impl()\n}\n\n///|\nfn[T] panic_impl() -> T = \"%panic\"\n"],"mappings":"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"}